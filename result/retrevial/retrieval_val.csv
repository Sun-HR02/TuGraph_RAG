Q,K1,K2,K3,K4,K5,K6,K7,K8,K9,K10
RPC 及 HA 服务中，verbose 参数的设置有几个级别？,"page_content='src/server/lgraph_server.cpp/ #ifndef _WIN32
        // setup brpc and braft logger
        if (config_->enable_rpc) {
            int blog_level;
            switch (config_->verbose) {
            case 0:
                blog_level = logging::BLOG_ERROR;
                break;
            case 1:
            case 2:
                blog_level = logging::BLOG_WARNING;
                break;
            case 3:
            default:
                blog_level = logging::BLOG_DEBUG;
                break;
            }
            logging::LoggingSettings blog_setting;
            // blog_setting.logging_dest = logging::LoggingDestination::LOG_NONE;
            logging::InitLogging(blog_setting);
            logging::SetMinLogLevel(blog_level);
            blog_sink_ = std::make_unique<FMALogSink>();
            logging::SetLogSink(blog_sink_.get());
        }
#endif
        // starting services
        lgraph::HaStateMachine::Config config(*config_);
        if (config_->enable_ha) {
            // config_ gets updated when UpdateConfig is called
            state_machine_ = std::make_unique<lgraph::HaStateMachine>(config, config_);
        } else {
            state_machine_ = std::make_unique<lgraph::StateMachine>(config, config_);
        }' metadata={'file_name': 'lgraph_server.cpp', 'file_path': 'src/server/lgraph_server.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/server/lgraph_server.cpp'}",空,空,空,空,空,空,空,空,空
在磁盘IO监控的配置中，当哪个值大于10000时会触发危急颜色模式？,"page_content='运维监控

2.部署方案

2.4.第四步

10000
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\n  磁盘IO超过10MB/S"",
""name"": ""磁盘IO alert"",
""noDataState"": ""no_data"",
""notifications"": []
},
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='运维监控

2.部署方案

2.4.第四步

""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 10000,
""visible"": true
}
],
""title"": ""磁盘IO"",
""type"": ""timeseries""
}
],
""refresh"": """",
""schemaVersion"": 36,
""style"": ""dark"",
""tags"": [],
""templating"": {
""list"": []
},
""time"": {
""from"": ""now-24h"",
""to"": ""now""
},
""timepicker"": {
""hidden"": false,
""refresh_intervals"": [
""10s""
]
},
""timezone"": """",
""title"": ""TuGraph监控页面"",
""version"": 20,' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='运维监控

2.部署方案

2.4.第四步

""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""builder"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk_rate\"",type=~\""read|write\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 10000,
""visible"": true
}
],
""title"": ""磁盘IO"",
""type"": ""timeseries""
}
],
""refresh"": """",
""schemaVersion"": 36,' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}",空,空,空,空,空,空,空
`FieldData` 类中的函数 `IsReal()` 是用来查询数据是否为实数类型吗？,"page_content='src/cypher/arithmetic/ast_expr_evaluator.cpp/ static cypher::FieldData Neg(const cypher::FieldData& x) {
    if (!((IsNumeric(x) || x.IsNull()))) {
        throw lgraph::CypherException(""Type mismatch: expect Integer or Float in sub expr"");
    }
    cypher::FieldData ret;
    if (x.IsNull()) return ret;
    if (x.IsInteger()) {
        ret.scalar = ::lgraph::FieldData(-x.scalar.integer());
        return ret;
    } else {
        ret.scalar = ::lgraph::FieldData(-x.scalar.real());
        return ret;
    }
    NOT_SUPPORT_AND_THROW();
}

std::any cypher::AstExprEvaluator::visit(geax::frontend::GetField* node) {
    auto expr = std::any_cast<Entry>(node->expr()->accept(*this));
    return Entry(cypher::FieldData(expr.GetEntityField(ctx_, node->fieldName())));
}

std::any cypher::AstExprEvaluator::visit(geax::frontend::TupleGet* node) {
    NOT_SUPPORT_AND_THROW();
}

std::any cypher::AstExprEvaluator::visit(geax::frontend::Not* node) { DO_UNARY_EXPR(Not); }

std::any cypher::AstExprEvaluator::visit(geax::frontend::Neg* node) { DO_UNARY_EXPR(Neg); }

std::any cypher::AstExprEvaluator::visit(geax::frontend::Tilde* node) { NOT_SUPPORT_AND_THROW(); }

std::any cypher::AstExprEvaluator::visit(geax::frontend::VSome* node) { NOT_SUPPORT_AND_THROW(); }' metadata={'file_name': 'ast_expr_evaluator.cpp', 'file_path': 'src/cypher/arithmetic/ast_expr_evaluator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/ast_expr_evaluator.cpp'}","page_content='src/cypher/arithmetic/arithmetic_expression.cpp/ if (r.type == Entry::NODE && r.node && VALIDATE_IT(r)) {
        if (!r.node->IsValidAfterMaterialize(ctx)) CYPHER_INTL_ERR();
        res = lgraph::FieldData(r.node->ItRef()->Properties());
    } e' metadata={'file_name': 'arithmetic_expression.cpp', 'file_path': 'src/cypher/arithmetic/arithmetic_expression.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/arithmetic_expression.cpp'}","page_content='src/core/transaction.cpp/ emplate <typename FieldT>
typename std::enable_if<IS_FIELD_TYPE(FieldT), FieldData>::type Transaction::GetEdgeField(
    const EdgeUid& uid, const FieldT& fd) {
    _detail::CheckEdgeUid(uid);
    auto eit = graph_->GetUnmanagedOutEdgeIterator(txn_.get(), uid, false);
    if (!eit.IsValid()) THROW_CODE(InputError, ""Edge does not exist"");
    auto schema = curr_schema_->e_schema_manager.GetSchema(eit.GetLabelId());
    FMA_DBG_ASSERT(schema);
    Value prop = eit.GetProperty();
    FMA_DBG_ASSERT(prop.IsSlice());
    if (schema->DetachProperty()) {
        prop = schema->GetDetachedEdgeProperty(*txn_, uid);
    }
    return GetField(schema, prop, fd, blob_manager_, *txn_);
}

template <typename FieldT>
typename std::enable_if<IS_FIELD_TYPE(FieldT), void>::type Transaction::GetEdgeFields(
    const EdgeUid& uid, const size_t n_fields, const FieldT* fds, FieldData* fields) {
    _detail::CheckEdgeUid(uid);
    auto eit = graph_->GetUnmanagedOutEdgeIterator(txn_.get(), uid, false);
    if (!eit.IsValid()) THROW_CODE(InputError, ""Edge does not exist"");
    auto schema = curr_schema_->e_schema_manager.GetSchema(eit.GetLabelId());
    FMA_DBG_ASSERT(schema);
    Value prop = eit.GetProperty();
    FMA_DBG_ASSERT(prop.IsSlice());
    if (schema->DetachProperty()) {
        prop = schema->GetDetachedEdgeProperty(*txn_, eit.GetUid());
    }
    for (size_t i = 0; i < n_fields; i++) {
        fields[i] = GetField(schema, prop, fds[i], blob_manager_, *txn_);
    }
}' metadata={'file_name': 'transaction.cpp', 'file_path': 'src/core/transaction.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/transaction.cpp'}",空,空,空,空,空,空,空
如果成功修改一个用户的描述，应返回什么状态码？,"page_content='RESTful API Legacy

6.Deprecated

6.1.用户管理

""new_password"": ""A_NEW_PASSWORD""
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.6.修改用户描述  
用户可以修改自己的描述。管理员可以修改任意用户的描述。  
- **URI**: `/user/{user_name}/description`
- **METHOD**: PUT
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 用户描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/user1/description
• Accept: application/json; charset=UTF-8' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.1.用户管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

| description | 新描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/description
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
{
""description"": ""modified description""
}
```  
**Example response.**' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='RESTful API Legacy

6.Deprecated

6.1.用户管理

| password | 密码 | 字符串 |
| description | 用户描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
{
""user"": ""USER1"",
""password"": ""AN_INITIAL_PASSWORD"",' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.1.用户管理'}","page_content='RESTful API Legacy

6.Deprecated

6.1.用户管理

系统默认创建一个管理员，管理员用户名为 _admin_，密码为 _73@TuGraph_。为了安全起见，请用户在第一次启动服务器后更改密码。  
#### 6.1.1.添加用户  
添加一个新的用户，并为其设置初始密码。只有管理员有权限进行此操作。其中用户名只能由字母，数字以及下划线构成，密码则可以包含任意字符。用户名和密码长度不能超过 64 字节。添加用户时还可以为用户增加一个描述，用户描述可以包含任意字符，最长不超过 512 字节。  
新用户默认拥有同名的角色，不具备任何图的权限。  
- **URI**: `/user`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| user | 用户名 | 字符串 |
| password | 密码 | 字符串 |
| description | 用户描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.1.用户管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.2.2.修改角色描述  
修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。  
- **URI**: `/role/{role_name}/description`
- **METHOD**: PUT
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 新描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/description
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}",空,空,空,空,空
边关联的两个点的字段是否一定是点的主键？,"page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

| name | Label 名 | 字符串 |
| fields | 数据列定义 | 列表 |
| is_vertex | 是否是点 Label | 布尔值 |
| primary | 点的主键属性 | 字符串 |
| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。  
`edge_constraints` 在 `is_vertex` 为 `false` 的时候设置，这个字段只有边有。这个字段限制了该边的起点和终点只能是哪些点的组合，比如：`[[""vertex_label1"",""vertex_label2""],[""vertex_label3"",""vertex_label4""]]`，限制了该边只能是从 `vertex_label1` 到 `vertex_label2` 和 从 `vertex_label3` 到 `vertex_label4`。如果不想有任何限制，不设置该字段即可。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='业务开发指南

导入数据

批量upsert边数据

如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。  
第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。  
第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。  
注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。  
推荐使用driver里面的参数化特性，避免自己构造语句。
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据'}","page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | Label 名 | 字符串 |
| fields | 数据列定义 | 列表 |
| is_vertex | 是否是点 Label | 布尔值 |
| primary | 点的主键属性 | 字符串 |
| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='业务开发指南

导入数据

批量upsert边数据

第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。  
注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。  
推荐使用driver里面的参数化特性，避免自己构造语句。
```
CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据'}","page_content='图相关DDL

Create Graph

**Syntax**
一个图至少包含一对点边，点表必须包含一个id字段作为主键，边表必须包含srcId和targetId作为主键，边表还可以有一个时间戳字段标识时间。  
```
CREATE GRAPH <graph name>
(
<graph vertex>
[ { , <graph vertex> } ... ]
, <graph edge>
[ { , <graph edge> } ... ]
) WITH （
storeType = <graph store type>
[ { , <config key> = <config value> } ... ]
);

<graph vertex>  ::=
VERTEX <vertex name>
(
<column name> <data type> ID
[ {, <column name> <data type> } ... ]
)' metadata={'Header 1': '图相关DDL', 'Header 2': 'Create Graph'}",空,空,空,空,空
OutEdgeIterator 类的 Delete 方法执行什么操作？,"page_content='src/lgraph_api/lgraph_edge_iterator.cpp/ void InEdgeIterator::Delete() {
    ThrowIfInvalid();
    txn_->DeleteEdge(*it_);
    txn_->RefreshIterators();
}

std::string InEdgeIterator::ToString() const {
    ThrowIfInvalid();
    return txn_->EdgeToString(*it_);
}

bool operator==(const OutEdgeIterator& lhs, const OutEdgeIterator& rhs) {
    return lhs.GetSrc() == rhs.GetSrc() && lhs.GetDst() == rhs.GetDst() &&
           lhs.GetLabelId() == rhs.GetLabelId() && lhs.GetEdgeId() == rhs.GetEdgeId() &&
           lhs.GetTemporalId() == rhs.GetTemporalId();
}

bool operator==(const OutEdgeIterator& lhs, const InEdgeIterator& rhs) {
    return lhs.GetSrc() == rhs.GetSrc() && lhs.GetDst() == rhs.GetDst() &&
           lhs.GetLabelId() == rhs.GetLabelId() && lhs.GetEdgeId() == rhs.GetEdgeId() &&
           lhs.GetTemporalId() == rhs.GetTemporalId();
}

bool operator==(const InEdgeIterator& lhs, const OutEdgeIterator& rhs) {
    return lhs.GetSrc() == rhs.GetSrc() && lhs.GetDst() == rhs.GetDst() &&
           lhs.GetLabelId() == rhs.GetLabelId() && lhs.GetEdgeId() == rhs.GetEdgeId() &&
           lhs.GetTemporalId() == rhs.GetTemporalId();
}

bool operator==(const InEdgeIterator& lhs, const InEdgeIterator& rhs) {
    return lhs.GetSrc() == rhs.GetSrc() && lhs.GetDst() == rhs.GetDst() &&
           lhs.GetLabelId() == rhs.GetLabelId() && lhs.GetEdgeId() == rhs.GetEdgeId() &&
           lhs.GetTemporalId() == rhs.GetTemporalId();
}' metadata={'file_name': 'lgraph_edge_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_edge_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_edge_iterator.cpp'}","page_content='src/lgraph_api/lgraph_edge_iterator.cpp/ void OutEdgeIterator::Delete() {
    ThrowIfInvalid();
    txn_->DeleteEdge(*it_);
    txn_->RefreshIterators();
}

std::string OutEdgeIterator::ToString() const {
    ThrowIfInvalid();
    return txn_->EdgeToString(*it_);
}

InEdgeIterator::InEdgeIterator(lgraph::graph::InEdgeIterator&& impl,
                               const std::shared_ptr<lgraph::Transaction>& txn)
    : it_(new lgraph::graph::InEdgeIterator(std::move(impl))), txn_(txn) {}

InEdgeIterator::InEdgeIterator(InEdgeIterator&& rhs)
    : it_(std::move(rhs.it_)), txn_(std::move(rhs.txn_)) {}

InEdgeIterator& InEdgeIterator::operator=(InEdgeIterator&& rhs) {
    it_ = std::move(rhs.it_);
    txn_ = std::move(rhs.txn_);
    return *this;
}

InEdgeIterator::~InEdgeIterator() {}

void InEdgeIterator::Close() noexcept { it_->Close(); }

bool InEdgeIterator::Next() {
    ThrowIfInvalid();
    return it_->Next();
}

bool InEdgeIterator::Goto(EdgeUid euid, bool nearest) {
    if (!txn_->IsValid()) THROW_CODE(InvalidTxn);
    return it_->Goto(euid, nearest);
}

EdgeUid InEdgeIterator::GetUid() const {
    ThrowIfInvalid();
    return it_->GetUid();
}

int64_t InEdgeIterator::GetSrc() const {
    ThrowIfInvalid();
    return it_->GetSrc();
}

int64_t InEdgeIterator::GetDst() const {
    ThrowIfInvalid();
    return it_->GetDst();
}

int64_t InEdgeIterator::GetEdgeId() const {
    ThrowIfInvalid();
    return it_->GetEdgeId();
}' metadata={'file_name': 'lgraph_edge_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_edge_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_edge_iterator.cpp'}","page_content='src/python/python_api.cpp/ Delete"", &OutEdgeIterator::Delete,
             ""Deletes current edge.\n""
             ""The iterator will point to the next out edge if there is any."",
             pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/core/transaction.cpp/ bool Transaction::DeleteEdge(const EdgeUid& uid) {
    _detail::CheckEdgeUid(uid);
    ThrowIfReadOnlyTxn();
    auto eit = GetOutEdgeIterator(uid, false);
    if (!eit.IsValid()) return false;
    DeleteEdge(eit);
    return true;
}

template void Transaction::DeleteEdge<graph::InEdgeIterator>(graph::InEdgeIterator&);
template void Transaction::DeleteEdge<graph::OutEdgeIterator>(graph::OutEdgeIterator&);

void Transaction::GetStartAndEndVid(VertexId& start, VertexId& end) {
    auto vit = graph_->GetUnmanagedVertexIterator(txn_.get());
    if (!vit.IsValid()) {
        start = 0;
        end = 0;
    } else {
        start = vit.GetId();
        end = graph_->GetNextVid(*txn_);
    }
}

VertexIndex* Transaction::GetVertexIndex(const std::string& label, const std::string& field) {
    const Schema* s = curr_schema_->v_schema_manager.GetSchema(label);
    if (!s) THROW_CODE(InputError, ""Label \""{}\"" does not exist."", label);
    auto fe = s->GetFieldExtractor(field);
    return fe->GetVertexIndex();
}

VertexIndex* Transaction::GetVertexIndex(size_t label, size_t field) {
    const Schema* s = curr_schema_->v_schema_manager.GetSchema(label);
    if (!s) THROW_CODE(InputError, ""Label \""{}\"" does not exist."", label);
    auto fe = s->GetFieldExtractor(field);
    return fe->GetVertexIndex();
}' metadata={'file_name': 'transaction.cpp', 'file_path': 'src/core/transaction.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/transaction.cpp'}","page_content='src/core/graph.cpp/ oid lgraph::graph::Graph::_ScanAndDelete(
    KvStore& store, KvTransaction& txn,
    const std::function<bool(VertexIterator&)>& should_delete_node,
    const std::function<bool(InEdgeIterator&)>& should_delete_in_edge,
    const std::function<bool(OutEdgeIterator&)>& should_delete_out_edge, size_t& n_modified,
    size_t batch_size) {' metadata={'file_name': 'graph.cpp', 'file_path': 'src/core/graph.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/graph.cpp'}",空,空,空,空,空
如何调整TuGraph-DB的日志等级？,"page_content='日志信息

3.审计日志

审核日志记录每个请求和响应，以及发送请求的用户以及收到请求的时间。审核日志只能是打开或关闭状态。可以使用 TuGraph 可视化工具和 REST API 查询结果。  
开启审计日志需要在配置文件中将`enable_audit_log`参数设置为`true`。配置文件和配置参数说明详见：[数据库运行/服务配置](../../5.installation&running/7.tugraph-running.md)。' metadata={'Header 1': '日志信息', 'Header 2': '3.审计日志'}","page_content='日志信息

2.服务器日志

2.3.存储过程日志

extern ""C"" bool Process(GraphDB& db, const std::string& request, std::string& response) {
response = ""TuGraph log demo"";
LogExample();
return true;
}
```
将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。  
#### 2.3.1.python存储过程
请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.3.存储过程日志'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

一、高可用架构介绍

4.TuGraph-DB高可用架构—Raft 共识算法

-   有了一致性的保证后，安全性也就有了保证，当超过半数的节点达成一致之后，才应用日志，这样就能解决网络分区延迟、丢包、冗余和乱序的错误。
-   基于一致性和安全性，它的可用性也就得到了保证，只要少于半数的节点宕机，即使主机宕机，也可以快速恢复应用，通过一次选举的时间就可以重新选出一个leader对外提供服务。  
国标对于高可用系统的指标评估，RTO 和 RPO 分别是恢复时间指标和恢复点目标，有 6 个等级，TuGraph-DB 已经达到了最高等级。当少量节点故障时，RPO 是 0，也就是没有数据损失，数据恢复时间点指标是小于 15 秒。即使是在部署的时候，无论是在同城的两中心、三中心，还是多地的多中心，都可以达成 RTO 小于 15 秒的标准。  
Raft算法优点:  
• 易用性：状态简单，强Leader  
• 一致性：日志逐个复制，超过半数节点达成一致才提交，不存在日志空洞  
• 安全性：超半数节点达成一致才应用日志，能解决网络延迟、分区、丢包、冗余和乱序等错误' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '一、高可用架构介绍', 'Header 3': '4.TuGraph-DB高可用架构—Raft 共识算法'}","page_content='TuGraph-db

2. 快速上手

一个简单的方法是使用docker进行设置，可以在DockerHub)中找到, 名称为`tugraph/tugraph-runtime-[os]:[tugraph version]`,
例如， `tugraph/tugraph-runtime-centos7:3.3.0`。  
更多详情请参考 [快速上手文档](和 [业务开发指南]' metadata={'Header 1': 'TuGraph-db', 'Header 2': '2. 快速上手'}",空,空,空,空,空,空
在机器性能指标中，“memory”指的是什么？,空,空,空,空,空,空,空,空,空,空
如果不选择清空画布数据按钮，导入的数据会如何处理？,"page_content='可视化操作手册

2.操作指南

2.4.图项目

##### 2.4.4.2.配置查询  
在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-模板查询](../../../images/browser/graphanalysis-queryfilter-configurequery.png)  
##### 2.4.4.3.画布分析  
在`画布分析`功能中，用户可以对画布中的节点或边数据进行操作和分析，主要包括：选中节点进行扩展查询、收起/展开节点、固定节点，清空画布，套索，点/边检索，画布图例等。画布上的最基础操作是拖拽点数据，鼠标左键选住一个节点并移动鼠标，可以完成点数据位置的移动。  
###### a.扩展查询  
在`画布`区域右键点击一个节点数据，弹出操作悬窗，鼠标移至`扩展查询`处弹出二级悬窗，点击对应的扩展度数进行查询。
- 一度查询：双向扩展一度关系。
- 二度查询：双向扩展二度关系。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。
- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)  
##### 2.4.4.2.配置查询  
在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-模板查询](../../../images/browser/graphanalysis-queryfilter-configurequery.png)  
##### 2.4.4.3.画布分析' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

- 覆盖当前画布中的模型：选中该选项，导入时会先清空已有图模型再导入模型文件中的图模型；不选择，会导入模型文件中新增的点类型和边类型，但不会修改已有的点类型和边类型。  
![图构建-导入模型](../../../images/browser/graphbuild-importmodel.png)  
###### e.导出模型  
在`模型定义`界面点击`导出模型`按钮，可以将当前图项目中的图模型导出成json文件。  
![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel-button.png)  
模型文件为json格式，不建议手动修改。  
![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel.png)  
##### 2.4.2.2.数据导入  
完成`模型定义`之后，点击`数据导入`按钮进入数据导入页面。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

2、左边栏：查询、筛选、外观功能操作区域；
3、画布区域：展示图数据的区域，展示点和边数据，支持点扩展查询、收起节点、固定节点、删除节点、画布图数据统计、缩放、居中等功能；
4、右边栏：选中一个点数据或边数据后，会展示对应的属性信息；
5、布局切换：标签布局和卡片布局的切换。  
![图分析-操作区域](../../../images/browser/graphanalysis-operation-area.png)  
##### 2.4.4.1.语句查询  
在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。
- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

###### b.收起/展开节点  
在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`收起节点`会隐藏所选节点的一度关系节点；再次右键已`收起节点`的点数据可以进行`展开节点`操作，展示已隐藏的一度关系节点。  
![图分析-画布分析-收起节点](../../../images/browser/graphanalysis-canvas-collapse.png)  
![图分析-画布分析-展开节点](../../../images/browser/graphanalysis-canvas-expand.png)  
###### c.删除节点  
在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`删除节点`会将所选节点移出画布。  
![图分析-画布分析-删除节点](../../../images/browser/graphanalysis-canvas-delete.png)  
###### d.清空画布  
在`操作栏`区域点击`清空画布`按钮，会清除所有画布中的数据。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}",空,空,空,空,空
我应该如何通过邮件向TuGraph产品团队提出建议？,"page_content='如何贡献

4. 贡献代码流程

4.1. 提交issue

不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:  
- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。
- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。
- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。' metadata={'Header 1': '如何贡献', 'Header 2': '4. 贡献代码流程', 'Header 3': '4.1. 提交issue'}",空,空,空,空,空,空,空,空,空
边索引是否支持查询加速？,空,空,空,空,空,空,空,空,空,空
TuGraph Monitor的主要功能是什么？,"page_content='运维监控

1.设计思路

1.2.TuGraph Monitor

TuGraph Monitor是TuGraph周边生态中的一个工具，它作为TuGraph众多用户中的一个，通过C++ RPC Client与TuGraph进行通信，通过Procedure查询接口来查询TuGraph服务所在机器的性能指标，并将TuGraph返回的结果包装成Prometheus需要的数据模型，等待Prometheus获取。用户可以通过设置查询时间间隔来保证获取监控指标对于业务查询的影响最小化。' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路', 'Header 3': '1.2.TuGraph Monitor'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='可视化操作手册（旧版）

作用

TuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '作用'}","page_content='功能概览

4.核心功能

4.4.备份恢复

TUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.4.备份恢复'}",空,空,空,空,空
TuGraph HA 集群的管理工具是什么？,"page_content='集群管理

1. 简介

HA集群启动之后，可以使用`lgraph_peer`工具进行集群管理，可以执行删除节点，转移leader和生成snapshot等功能。' metadata={'Header 1': '集群管理', 'Header 2': '1. 简介'}","page_content='TuGraph Management

简介

TuGraph Management 是一款为TuGraph开发的算法任务管理工具。采用了sofastack与brpc作为通信框架，并使用sqlite进行持久化存储。  
主要功能：  
- 算法任务状态持久化存储  
- 算法任务结果持久化存储  
- 延时触发与定时触发算法任务支持' metadata={'Header 1': 'TuGraph Management', 'Header 2': '简介'}","page_content='部署高可用模式

3.启动初始备份组

安装好TuGraph之后，可以使用`lgraph_server`命令在不同的机器上启动高可用集群。本节主要讲解高可用集群的启动方式，启动之后的集群状态管理参见[lgraph_peer工具](../6.utility-tools/5.ha-cluster-management.md)' metadata={'Header 1': '部署高可用模式', 'Header 2': '3.启动初始备份组'}","page_content='集群管理

2. 删除节点

对于TuGraph HA集群中长期离线或者产生网络分区的节点，可以使用`lgraph_peer`的`remove_peer`命令删除节点。命令示例如下所示：
```shell
$ lgraph_peer --command remove_peer --peer {peer_id} --conf {group_conf}
```  
其中：  
- `--command remove_peer` 指定要执行的操作为remove_peer，即删除节点。
- `--peer {peer_id}` 指定要删除节点的rpc网络地址，如 `127.0.0.1:9092`。
- `--conf {group_conf}` 指定HA集群的成员配置（可连通主节点即可），如 `127.0.0.1:9092,127.0.0.1:9093,127.0.0.1:9094` 。' metadata={'Header 1': '集群管理', 'Header 2': '2. 删除节点'}","page_content='部署高可用模式

1.原理

TuGraph 通过多机热备份来提供高可用（HA）模式。在高可用模式下，对数据库的写操作会被同步到所有服务器（非witness）上，这样即使有部分服务器宕机也不会影响服务的可用性。  
高可用模式启动时，多个 TuGraph 服务器组成一个备份组，即高可用集群。每个备份组由三个或更多 TuGraph 服务器组成，其中某台服务器会作为`leader`，而其他复制组服务器则作为`follower`。写入请求由`leader`
提供服务，该`leader`将每个请求复制同步到`follower`，并在请求同步到服务器后才能响应客户端。这样，如果任何服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`
服务器发生故障，其他服务器将自动选择出新的`leader`。  
TuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。' metadata={'Header 1': '部署高可用模式', 'Header 2': '1.原理'}",空,空,空,空,空
如何通过POST方法将Token的有效期修改为无限期？,"page_content='RESTful API Legacy

3.登录

3.3.修改Token有效期

- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| Authorization | 令牌 | 字符串 |
| refresh_time | 有效时间（默认设置为0） | Int64 |
| expire_time | 有效时间（默认设置为0） | Int64 |  
- **RESPONSE**:  如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/update_token_time
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.3.修改Token有效期'}","page_content='RESTful API Legacy

3.登录

3.3.修改Token有效期

修改Token有效期，需要传输jwt，refresh_time和expire_time三个参数，其中jwt用于校验用户身份，refresh_time和expire_time等于0时，有效期为无期限，超过refresh_time时，需要调用refresh接口获取新的Token;超过expire_time时，需要重新登录。  
- **URI**: `/update_token_time`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| Authorization | 令牌 | 字符串 |
| refresh_time | 有效时间（默认设置为0） | Int64 |
| expire_time | 有效时间（默认设置为0） | Int64 |  
- **RESPONSE**:  如果成功，返回代码 200。  
**Example request.**  
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.3.修改Token有效期'}","page_content='RESTful API Legacy

3.登录

3.3.修改Token有效期

| expire_time | 有效时间（默认设置为0） | Int64 |  
- **RESPONSE**:  如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/update_token_time
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{
""Authorization"" : ""Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU"",
""refresh_time"":0,
""expire_time"":0
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.3.修改Token有效期'}","page_content='Token使用说明

2. Token有效期

2.4. Token有效期修改

为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。  
* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。
具体可查询[REST接口文档](../7.client-tools/9.restful-api-legacy.md)。  
* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。可参考[服务运行文档](../5.installation&running/7.tugraph-running.md)。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.4. Token有效期修改'}",空,空,空,空,空,空
TuGraph图数据库是由哪两个机构联合研发的？,"page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='TuGraph由LDBC认定全球领先

基本介绍

TuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。  
**随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品**。  
开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。  
图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。  
蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。' metadata={'Header 1': 'TuGraph由LDBC认定全球领先', 'Header 2': '基本介绍'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='云部署

1.简介

TuGraph（tugraph.antgroup.com）是蚂蚁集团研发的高性能图数据库（Graph Database）。TuGraph在计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。本文向您介绍如何开通计算巢上的TuGraph社区版服务，以及部署流程和使用说明。' metadata={'Header 1': '云部署', 'Header 2': '1.简介'}",空,空,空,空,空
TuGraph图学习模块依赖于什么系统？,"page_content='环境分类

2.依赖系统库

针对三种环境，除去TuGraph的运行包，所需要的系统库如下：
* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。
* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。
* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='环境准备

2.软件环境

2.1. 操作系统

TuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。  
其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。' metadata={'Header 1': '环境准备', 'Header 2': '2.软件环境', 'Header 3': '2.1. 操作系统'}","page_content='使用 TuGraph 图学习模块进行点分类

2. 前置条件

TuGraph图学习模块需要TuGraph-db 3.5.1及以上版本。  
TuGraph部署推荐采用Docker镜像tugraph-compile 1.2.4及以上版本:  
tugraph / tugraph-compile-ubuntu18.04:latest  
tugraph / tugraph-compile-centos7:latest  
tugraph / tugraph-compile-centos8:latest  
以上镜像均可在DockerHub上获取。
具体操作请参考[快速上手](../3.quick-start/1.preparation.md)。' metadata={'Header 1': '使用 TuGraph 图学习模块进行点分类', 'Header 2': '2. 前置条件'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='Learn Tutorial

1.TuGraph 图学习模块简介

图学习是一种机器学习方法，其核心思想是利用图结构中的拓扑信息，通过顶点之间的联系及规律来进行数据分析和建模。不同于传统机器学习方法，图学习利用的数据形式为图结构，其中顶点表示数据中的实体，而边则表示实体之间的关系。通过对这些顶点和边进行特征提取和模式挖掘，可以揭示出数据中深层次的关联和规律，从而用于各种实际应用中。  
这个模块是一个基于图数据库的图学习模块，主要提供了四种采样算子：Neighbor Sampling、Edge Sampling、Random Walk Sampling 和 Negative Sampling。这些算子可以用于对图中的顶点和边进行采样，从而生成训练数据。采样过程是在并行计算环境下完成的，具有高效性和可扩展性。  
在采样后，我们可以使用得到的训练数据来训练一个模型。该模型可以用于各种图学习任务，比如预测、分类等。通过训练，模型可以学习到图中的顶点和边之间的关系，从而能够对新的顶点和边进行预测和分类。在实际应用中，这个模块可以被用来处理各种大规模的图数据，比如社交网络、推荐系统、生物信息学等。' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '1.TuGraph 图学习模块简介'}",空,空,空,空,空
在构造FieldSpec时需要哪些参数？,空,空,空,空,空,空,空,空,空,空
TuGraph DB的并发性能优化最初面临的主要问题是什么？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

当 TuGraph 遇见 Antlr4

ISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4 作为一种强大的解析器生成器，成为了蚂蚁图数据库 TuGraph 生成 GQL 解释器的理想选择。Antlr4 能够帮助团队更快、更准确地构建图数据库的查询语言，从而提高产品性能和用户体验。  
然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target 的并发性能不足以支持所需的超高并发 GQL 请求。经过调研并与 Antlr 开源社区讨论，我们发现\*\*并发性能这个问题普遍存在，并且在过去 5 年中持续困扰着 C++生态的开发者。\*\*我们决定解决这个问题。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '当 TuGraph 遇见 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为 DFA、ATN 等结构），拼接出了数据竞争的完整链路。  
（4）破解数据竞争问题  
数据竞争问题是多线程程序中常见而又复杂的问题，可以考虑通过破解多种竞争条件来解决。就本文问题来说，也存在多种破解方案选择，如何制定最优的解决方案是一项极具挑战的工作，主要难点有两个：  
（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

在调研讨论的过程中我们发现，多位开发者在论坛提出其耗时甚至多于 Java target 数倍之多。因此，我们决定从问题和开源代码出发，来定位、解决问题。  
这是一个典型的并发程序优化问题，根据以往的程序优化经验，我们分步推进该问题的解决：  
（1）识别问题  
通过对程序运行时的性能数据进行收集和分析，我们找到了程序运行瓶颈所在，通过调用分析，初步将问题定位为数据竞争导致的并发问题。  
（2）深入阅读 Antlr4 开源代码  
接下来，我们对 Antlr4 的源代码进行仔细的阅读和理解，掌握其内部的结构和核心逻辑，找出了核心的数据结构和关键的调用链路。为我们破解性能难题和分析修改的正确性做好了准备。  
（3）梳理数据竞争链路  
根据上述分析，我们判断问题的症结极大概率是数据竞争造成的。形成数据竞争至少有两个条件：一是线程之间共享内存数据，二是至少存在两个线程去读写某个共享内存。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。  
关于程序正确性的保证，我们通过双重验证来保证。首先在设计之初我们已经从源代码角度，推断出共享数据仍然是安全的，其次我们也设计了实验对此进行了验证，验证结果与我们的分析一致' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

（2）深入阅读 Antlr4 开源代码  
接下来，我们对 Antlr4 的源代码进行仔细的阅读和理解，掌握其内部的结构和核心逻辑，找出了核心的数据结构和关键的调用链路。为我们破解性能难题和分析修改的正确性做好了准备。  
（3）梳理数据竞争链路  
根据上述分析，我们判断问题的症结极大概率是数据竞争造成的。形成数据竞争至少有两个条件：一是线程之间共享内存数据，二是至少存在两个线程去读写某个共享内存。  
进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为 DFA、ATN 等结构），拼接出了数据竞争的完整链路。  
（4）破解数据竞争问题  
数据竞争问题是多线程程序中常见而又复杂的问题，可以考虑通过破解多种竞争条件来解决。就本文问题来说，也存在多种破解方案选择，如何制定最优的解决方案是一项极具挑战的工作，主要难点有两个：  
（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}",空,空,空,空,空
在C++客户端中实例化单节点client对象需要哪些参数？,"page_content='C++客户端

2.使用示例

2.1.实例化client对象

引入依赖并实例化  
#### 2.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
``` C++
RpcClient client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```  
#### 2.1.2.实例化HA集群直接连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化
``` C++' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

@param password: login password
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 2.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化。
```java
std::vector<std::string> urls = {""189.33.97.23:9091"", ""189.33.97.24:9091"", ""189.33.97.25:9091""};
TuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, ""admin"", ""73@TuGraph"");
```
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 2.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化。
```java' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

```
```
RpcClient(std::vector<std::string>& urls, std::string user, std::string password)
@param urls: tugraph host list
@param user: login user name
@param password: login password
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```  
#### 2.1.2.实例化HA集群直接连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化
``` C++
RpcClient client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}",空,空,空,空,空
TuGraph-DB查询引擎目前支持使用哪种查询语言？未来计划支持哪种查询语言？,"page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='ISO GQL

1.GQL简介

Graph Query Language(GQL, 图查询语言)是一种国际标准语言，用于属性图查询，该语言建立在SQL的基础上，并整合了现有的[openCypher、PGQL、GSQL和G-CORE](https://gql.today/comparing-cypher-pgql-and-g-core/)语言的成熟思想。目前该标准仍然处于草稿阶段。  
TuGraph基于[ISO GQL (ISO/IEC 39075) Antlr4 语法文件](https://github.com/TuGraph-family/gql-grammar)实现了GQL，并做了一些扩展与改造。目前并未完全支持所有的GQL语法，我们会在未来逐步完善。' metadata={'Header 1': 'ISO GQL', 'Header 2': '1.GQL简介'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持RESTful API

除了支持Cypher查询语言，TuGraph还提供了RESTful API接口。这使得我可以通过编程方式与图数据库进行交互，更好地将TuGraph集成到我的应用程序中。API设计合理，易于使用，为我提供了灵活性和自由度。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持RESTful API'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='功能概览

4.核心功能

4.1.查询语言

TuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。
- __支持Procedure嵌入__  
- __可插拔优化框架__ 各类优化功能  
- __可扩展安全性检查框架__ 对于cypher进行' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.1.查询语言'}",空,空,空,空,空
DeleteProcedure函数接受哪些类型的参数，以及它们的名称是什么？,"page_content='Java客户端

2.使用示例

2.10.删除存储过程

@param procedureName: procedure name
@param graph: the graph to query.
@return: the result of procedure execution
public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Java客户端

2.使用示例

2.10.删除存储过程

```java
String result = client.deleteProcedure(""CPP"", ""sortstr"", ""default"");
log.info(""loadProcedure : "" + result);
```
```
@param procedureType: the procedure type, currently supported CPP and PY
@param procedureName: procedure name
@param graph: the graph to query.
@return: the result of procedure execution
public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Python客户端

3.RPC Client

| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)                                                                                            | bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& graph)' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='RPC API

5.存储过程

5.3.删除存储过程

删除存储过程的请求包含以下参数：
- name: 必要参数，存储过程名称  
以C++为例，用户删除存储过程的方式如下所示：
```C++
LGraphRequest req;
req.set_is_write_op(true);
lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();
pluginRequest->set_graph(graph);
pluginRequest->set_type(procedure_type == ""CPP"" ? lgraph::PluginRequest::CPP
: lgraph::PluginRequest::PYTHON);
lgraph::DelPluginRequest* dpRequest = pluginRequest->mutable_del_plugin_request();
dpRequest->set_name(procedure_name);
cntl->Reset();' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.3.删除存储过程'}","page_content='C++客户端

2.使用示例

2.10.删除存储过程

```C++
std::string str;
bool ret = client.DeleteProcedure(str, ""CPP"", ""test_plugin1"");
```
```
bool DeleteProcedure(std::string& result, const std::string& procedure_type,
const std::string& procedure_name, const std::string& graph = ""default"");
@param [out] result              The result.
@param [in]  procedure_type      the procedure type, currently supported CPP and PY.
@param [in]  procedure_name      procedure name.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}",空,空,空,空,空
在FrontierTraversal中，如果要并行执行遍历，必须选择哪种事务模式？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

bool parallel = false
);
```  
该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。  
FrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。
两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。
选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。  
```c
void SetFrontier(size_t root_vid);' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

```c
template <typename VertexData>
ParallelVector<VertexData> ExtractVertexData(
GraphDB & db,
Transaction & txn,
ParallelVector<size_t> & frontier,
std::function<void(VertexIterator &, VertexData &)> extract,
bool parallel = false
);
```  
该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。  
FrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}",空,空,空,空,空,空,空,空
RpcSingleClient 的构造函数需要哪些参数？,"page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ std::shared_ptr<lgraph::RpcClient::RpcSingleClient>
    RpcClient::GetClient(lgraph::GraphQueryType type, const std::string &cypher,
                         const std::string &graph) {
    return GetClient(IsReadQuery(type, cypher, graph));
}

std::shared_ptr<lgraph::RpcClient::RpcSingleClient> RpcClient::GetClient(bool isReadQuery) {
    if (isReadQuery) {
        LoadBalanceClientPool();
        if (client_pool.empty())
            throw RpcException(""all instance is down, refuse req!"");
        return *client_pool.rbegin();
    } else {
        if (leader_client == nullptr)
            throw RpcException(""master instance is down, refuse req!"");
        return leader_client;
    }
}

std::shared_ptr<lgraph::RpcClient::RpcSingleClient> RpcClient::GetClientByNode(
    const std::string &url) {
    for (auto &c : client_pool) {
        if (c->GetUrl() == url)
            return c;
    }
    throw RpcException(""do not exit "" + url +"" client"");
}

void RpcClient::RefreshConnection() {
    try {
        RefreshClientPool();
        RefreshUserDefinedProcedure();
        RefreshBuiltInProcedure();
    } catch (std::exception &e) {
        LOG_ERROR() << ""[RpcClient] RpcClient Connection Exception, ""
                                   ""please connect again!"";
    }
}

void RpcClient::LoadBalanceClientPool() {
    if (!client_pool.empty()) {
        client_pool.push_back(client_pool.front());
        client_pool.pop_front();
    }
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ RpcClient::RpcSingleClient::~RpcSingleClient() {
    try {
        Logout();
    } catch (const RpcConnectionException& e) {
        LOG_DEBUG() << ""[RpcSingleClient] RpcSingleClient Connection Exception"";
    }
}

RpcClient::RpcClient(const std::string &url, const std::string &user,
                         const std::string &password)
    : user(user),
      password(password),
      base_client(std::make_shared<RpcSingleClient>(url, user, password)) {
    std::string result;
    bool ret = base_client->CallCypher(result, ""CALL dbms.ha.clusterInfo()"");
    if (ret) {
        client_type = DIRECT_HA_CONNECTION;
        cypher_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""merge ""};
        gql_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""insert "", ""drop ""};
        RefreshConnection();
    } else {
        client_type = SINGLE_CONNECTION;
    }
}

RpcClient::RpcClient(std::vector<std::string> &urls, std::string user,
                         std::string password)
    : user(std::move(user)),
      password(std::move(password)),
      urls(urls) {
    client_type = INDIRECT_HA_CONNECTION;
    cypher_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""merge ""};
    gql_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""insert "", ""drop ""};
    RefreshConnection();
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ void RpcClient::Logout() {
    auto logoutFun = [](const std::shared_ptr<RpcSingleClient>& c) {
        try {
            if (c) c->Logout();
        } catch (std::exception &e) {
            LOG_ERROR() << e.what();
        }
    };
    if (client_type != INDIRECT_HA_CONNECTION) {
        logoutFun(base_client);
    }
    for (auto &c : client_pool) {
        logoutFun(c);
    }
}

void RpcClient::RefreshUserDefinedProcedure() {
    std::string result;
    GetClient(true)->
        CallCypher(result, ""CALL db.plugin.listUserPlugins()"", ""default"", true, 10);
    user_defined_procedures = nlohmann::json::parse(result.c_str());
}

void RpcClient::RefreshBuiltInProcedure() {
    std::string result;
    GetClient(true)->CallCypher(result, ""CALL dbms.procedures()"", ""default"", true, 10);
    built_in_procedures = nlohmann::json::parse(result.c_str());
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='RPC API

3.登录

登录请求信息包含以下参数：
- user: 必要参数，用户名
- pass: 必要参数，密码
以C++为例，用户使用构建好的服务存根发送登录请求：
```C++
auto* req = request.mutable_acl_request();
auto* auth = req->mutable_auth_request()->mutable_login();
auth->set_user(user);
auth->set_password(pass);
// send data
cntl->Reset();
cntl->request_attachment().append(FLAGS_attachment);
req->set_client_version(server_version);
req->set_token(token);
LGraphRPCService_Stub stub(channel.get());
LGraphResponse res;' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ bool RpcClient::RpcSingleClient::CallProcedure(std::string& result,
                                               const std::string& procedure_type,
                                               const std::string& procedure_name,
                                               const std::string& param,
                                               double procedure_time_out, bool in_process,
                                               const std::string& graph, bool json_format)' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}",空,空,空,空,空
TuGraph中的expire_time默认设置是什么？,"page_content='Token使用说明

2. Token有效期

2.4. Token有效期修改

为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。  
* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。
具体可查询[REST接口文档](../7.client-tools/9.restful-api-legacy.md)。  
* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。可参考[服务运行文档](../5.installation&running/7.tugraph-running.md)。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.4. Token有效期修改'}",空,空,空,空,空,空,空,空,空
TuGraph的图学习模块中包括哪四种采样算子？,"page_content='Learn Tutorial

1.TuGraph 图学习模块简介

图学习是一种机器学习方法，其核心思想是利用图结构中的拓扑信息，通过顶点之间的联系及规律来进行数据分析和建模。不同于传统机器学习方法，图学习利用的数据形式为图结构，其中顶点表示数据中的实体，而边则表示实体之间的关系。通过对这些顶点和边进行特征提取和模式挖掘，可以揭示出数据中深层次的关联和规律，从而用于各种实际应用中。  
这个模块是一个基于图数据库的图学习模块，主要提供了四种采样算子：Neighbor Sampling、Edge Sampling、Random Walk Sampling 和 Negative Sampling。这些算子可以用于对图中的顶点和边进行采样，从而生成训练数据。采样过程是在并行计算环境下完成的，具有高效性和可扩展性。  
在采样后，我们可以使用得到的训练数据来训练一个模型。该模型可以用于各种图学习任务，比如预测、分类等。通过训练，模型可以学习到图中的顶点和边之间的关系，从而能够对新的顶点和边进行预测和分类。在实际应用中，这个模块可以被用来处理各种大规模的图数据，比如社交网络、推荐系统、生物信息学等。' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '1.TuGraph 图学习模块简介'}","page_content='Training

2. Mini-Batch训练

Mini-Batch训练需要使用TuGraph 图学习模块的采样算子，目前支持Neighbor Sampling、Edge Sampling、Random Walk Sampling和Negative Sampling。
TuGraph 图学习模块的采样算子进行采样后的结果以List的形式返回。
下面以Neighbor Sampling为例，介绍如何将采样后的结果，进行格式转换，送入到训练框架中进行训练。
用户需要提供一个Sample类：
```python
class TuGraphSample(object):
def __init__(self, args=None):
super(TuGraphSample, self).__init__()
self.args = args' metadata={'Header 1': 'Training', 'Header 2': '2. Mini-Batch训练'}","page_content='Sampling API

3. 图采样算子介绍

图采样算子在cython层实现，用于对输入的图进行采样处理，生成的NodeInfo用于保存feature属性、label属性等点信息，EdgeInfo用于保存边信息，这些元数据信息可以被用于特征抽取、网络嵌入等任务中。目前TuGraph图学习模块支持GetDB、NeighborSampling、EdgeSampling、RandomWalkSampling、NegativeSampling五种采样算子。' metadata={'Header 1': 'Sampling API', 'Header 2': '3. 图采样算子介绍'}","page_content='Learn Tutorial

6. 采样算子及编译

TuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '6. 采样算子及编译'}","page_content='使用 TuGraph 图学习模块进行点分类

5. 编译采样算子

采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：
在tugraph-db/build文件夹下执行
`make -j2`  
或在tugraph-db/learn/procedures文件夹下执行
`python3 setup.py build_ext -i`  
```python
from lgraph_db_python import *  # 导入tugraph-db的python接口模块
import importlib  # 导入importlib模块
getdb = importlib.import_module(""getdb"")  #获取getdb算子
getdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子
```  
如代码所示，得到算子so文件后，import 导入使用。' metadata={'Header 1': '使用 TuGraph 图学习模块进行点分类', 'Header 2': '5. 编译采样算子'}",空,空,空,空,空
在执行UpsertEdge操作时，如果根据提供的参数在现有边中找到匹配项，那么返回值通常会是更新后的边信息。如果没有找到匹配项，那么将会创建一条新的边，并返回这条新边的信息。请确认具体的TuGraph版本文档以获取更详细的信息。,"page_content='src/lgraph_api/c.cpp/ bool lgraph_api_transaction_upsert_edge_with_field_data_and_id(
    lgraph_api_transaction_t* txn, int64_t src, int64_t dst, size_t label_id,
    const size_t* field_ids, size_t field_ids_size,
    const lgraph_api_field_data_t* const* field_values, size_t field_values_size, char** errptr) {
    try {
        std::vector<size_t> id_vec(field_ids, field_ids + field_ids_size);
        return txn->repr.UpsertEdge(
            src, dst, label_id, id_vec,
            lgraph_api_field_data_array_to_field_data_vec(field_values, field_values_size));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

size_t lgraph_api_transaction_list_vertex_indexes(lgraph_api_transaction_t* txn,
                                                  lgraph_api_index_spec_t*** indexes,
                                                  char** errptr) {
    size_t n = 0;
    try {
        auto vec = txn->repr.ListVertexIndexes();
        n = vec.size();
        *indexes = new lgraph_api_index_spec_t*[n];
        for (size_t i = 0; i < vec.size(); i++) {
            (*indexes)[i] = new lgraph_api_index_spec_t{vec[i]};
        }
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
    return n;
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ bool lgraph_api_transaction_upsert_edge_with_value_strings(
    lgraph_api_transaction_t* txn, int64_t src, int64_t dst, const char* label,
    const char** field_names, size_t field_names_size, const char** field_value_strings,
    size_t field_value_strings_size, char** errptr) {
    try {
        std::vector<std::string> name_vec(field_names, field_names + field_names_size);
        std::vector<std::string> value_vec(field_value_strings,
                                           field_value_strings + field_value_strings_size);
        return txn->repr.UpsertEdge(src, dst, label, name_vec, value_vec);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_transaction_upsert_edge_with_field_data(
    lgraph_api_transaction_t* txn, int64_t src, int64_t dst, const char* label,
    const char* const* field_names, size_t field_names_size,
    const lgraph_api_field_data_t* const* field_values, size_t field_values_size, char** errptr) {
    try {
        std::vector<std::string> name_vec(field_names, field_names + field_names_size);
        return txn->repr.UpsertEdge(
            src, dst, label, name_vec,
            lgraph_api_field_data_array_to_field_data_vec(field_values, field_values_size));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}",空,空,空,空,空,空,空,空
ANTLR4支持生成哪些目标语言的解析器？,"page_content='src/cypher/grammar/generate.sh/ #!/bin/bash
set -o errexit

# This script is used to generate source files from the test grammars in the same folder. The generated files are placed
# into a subfolder ""generated"" which the demo project uses to compile a demo binary.

# There are 2 ways of running the ANTLR generator here.

# 1) Running from jar. Use the given jar (or replace it by another one you built or downloaded) for generation.
# Build jar:
export SCRIPT_DIR=$( cd -- ""$( dirname -- ""${BASH_SOURCE[0]}"" )"" &> /dev/null && pwd )
export PROJECT_SOURCE_DIR=${SCRIPT_DIR}/../../../
cd ${PROJECT_SOURCE_DIR}/deps/antlr4
mvn clean
MAVEN_OPTS=""-Xmx1G"" mvn -DskipTests package
LOCATION=${PROJECT_SOURCE_DIR}/deps/antlr4/tool/target/antlr4-4.13.0-complete.jar
GENERATED_DIR=${PROJECT_SOURCE_DIR}/src/cypher/parser/generated
if [ -d ""$GENERATED_DIR"" ]; then
    echo ""directory '$GENERATED_DIR' already exists!"" && exit 1
fi
# Generate
java -jar $LOCATION -Dlanguage=Cpp -no-listener -visitor -o $GENERATED_DIR -package parser \
    ${PROJECT_SOURCE_DIR}/src/cypher/grammar/Lcypher.g4
rm $GENERATED_DIR/LcypherBaseVisitor.*

#java -jar $LOCATION -Dlanguage=Cpp -listener -visitor -o $GENERATED_DIR -package antlrcpptest Lcypher.g4
#java -jar $LOCATION -Dlanguage=Cpp -listener -visitor -o generated/ -package antlrcpptest -XdbgST TLexer.g4 TParser.g4
#java -jar $LOCATION -Dlanguage=Java -listener -visitor -o generated/ -package antlrcpptest TLexer.g4 TParser.g4

# 2) Running from class path. This requires that you have both antlr3 and antlr4 compiled. In this scenario no installation
#    is needed. You just compile the java class files (using ""mvn compile"" in both the antlr4 and the antlr3 root folders).
#    The script then runs the generation using these class files, by specifying them on the classpath.
#    Also the string template jar is needed. Adjust CLASSPATH if you have stored the jar in a different folder as this script assumes.
#    Furthermore is assumed that the antlr3 folder is located side-by-side with the antlr4 folder. ' metadata={'file_name': 'generate.sh', 'file_path': 'src/cypher/grammar/generate.sh', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/grammar/generate.sh'}",空,空,空,空,空,空,空,空,空
如果对DateTime对象添加超出其范围的微秒数会发生什么？,空,空,空,空,空,空,空,空,空,空
VertexLockGuard是什么？,"page_content='OlapBase API

7. 图类OlapBase

7.3 锁机制

TuGraph实现了一对锁机制，来控制程序对于点数据的访存权限。分别是：  
- `void AcquireVertexLock(size_t vid)`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存
- `void ReleaseVertexLock(size_t vid)`：对点vid解锁，所有线程均可访存该锁对应的点数据
- `VertexLockGuard GuardVertexLock(size_t vid)`：在对vid操作时，对点vid加锁，退出作用域时时自动释放锁' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.3 锁机制'}",空,空,空,空,空,空,空,空,空
在value pack时，null array的具体含义是什么？,空,空,空,空,空,空,空,空,空,空
"如何在TuGraph中支持边属性匹配？为什么在以下Cypher查询中无法过滤边属性：`MATCH (n:chunk {id: '21604c19-0d30-11ef-b83b-0242ac110005'})-[r:kw {name:""生活补贴""}]-(m) RETURN n, r, m`？","page_content='TuGraph图模型说明

2. 图项目、点、边、属性命名规则和建议

2.2 使用限制

|**描述**|**最大个数**|
|-------- |--------- |
|用户数、角色数|65536|
|图项目的个数|4096|
|每个图项目的点和边类型数量之和|4096|
|每个点或边类型的属性数量|1024|  
注：
1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；  
示例： ```match (`match`:match) return `match`.id limit 1```  
2、大小写敏感性：TuGraph大小写敏感；  
3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；  
4、属性名字保留关键字：SRC_ID / DST_ID / SKIP' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '2. 图项目、点、边、属性命名规则和建议', 'Header 3': '2.2 使用限制'}","page_content='TuGraph console client

`lgraph_cli`使用

TuGraph> match(n) return n limit 1;
+-------------------------------------------------------------------------------------------------------------------------------------+
| n                                                                                                                                   |
+-------------------------------------------------------------------------------------------------------------------------------------+' metadata={'Header 1': 'TuGraph console client', 'Header 2': '`lgraph_cli`使用'}","page_content='src/cypher/procedure/procedure.cpp/ if (direction == parser::LinkDirection::RIGHT_TO_LEFT ||
            direction == parser::LinkDirection::DIR_NOT_SPECIFIED) {
            for (auto& edge_filter : edge_filters) {
                size_t count = 0;
                auto edge_lid = txn.GetLabelId(false, edge_filter.label);
                for (auto eit = vit.GetInEdgeIterator(
                         lgraph::EdgeUid(0, vid, edge_lid, 0, 0), true);
                     eit.IsValid(); eit.Next()) {
                    if (eit.GetLabelId() != edge_lid) break;
                    count += 1;
                    if (per_node_limit.has_value() && count > per_node_limit.value()) {
                        break;
                    }
                    if (!_Filter(txn, eit, edge_filter.property_filter)) continue;
                    neighbors.push_back(eit.GetSrc());
                }
            }
        }
    }
    r' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}","page_content='src/cypher/procedure/procedure.cpp/ late <typename EIT>
static bool _Filter(lgraph::Transaction &txn, const EIT &eit,
                    const EDGE_PROPERTY_FILTER_T &edge_filter) {
    for (auto &kv1 : edge_filter) {
        auto field = txn.GetEdgeField(eit.GetUid(), kv1.first);
        for (auto &kv2 : kv1.second) {
            if ((kv2.first == ""smaller_than"" && field >= kv2.second) ||
                (kv2.first == ""greater_than"" && field <= kv2.second)) {
                return false;
            }
        }
    }
    return true;
}

struct EdgeFilter {
    std::string label;
    EDGE_PROPERTY_FILTER_T property_filter;
};

stat' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}",空,空,空,空,空,空
TuGraph是如何通过语句来定义点类型和边类型的？,"page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。
- 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。
- 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

TuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。  
Label 操作对应的 URI 格式为  
```
http://{host}:{port}/db/{graph_name}/label/{type}/{label_name}
```  
其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | Label 名 | 字符串 |' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='Heterogeneous Graph

2. 异质图创建

在TuGraph中，一个异构图由一系列边关系构成。每个关系由一个字符串三元组定义 (源节点类型, 边类型, 目标节点类型) 。异质图的创建方式与同质图类似，只是在创建图时需要指定字符串三元组定义。如下所示。  
```python
olapondb = PyOlapOnDB('Empty', db, txn, [(""node"", ""edge"", ""node"")])
```
其中，第四个参数为异质图的边关系定义，可以通过该参数，指定筛选的异质图点边类型。如果不指定该参数，则默认将全部点边类型的数据进行构图训练。' metadata={'Header 1': 'Heterogeneous Graph', 'Header 2': '2. 异质图创建'}","page_content='TuGraph图模型说明

2. 图项目、点、边、属性命名规则和建议

2.1 命名规则

图项目、点、边和属性是识别符。该节描述了在TuGraph中识别符的允许的语法。
下面的表描述了每类识别符的最大长度和允许的字符。  
|**识别符** |**长度** |**允许的字符**|
|---------  |---------  |---------  |
|用户、角色、图项目|1-64字符|允许中文、字母、数字、下划线，且首字符不为数字|
|点类型、边类型、属性|1~256字符|允许中文、字母、数字、下划线，且首字符不为数字|' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '2. 图项目、点、边、属性命名规则和建议', 'Header 3': '2.1 命名规则'}",空,空,空,空,空
如果不设置log_dir，是否意味着将不会保存任何日志文件？,"page_content='日志信息

2.服务器日志

2.1.服务器日志配置项

服务器日志的输出位置可以通过`log_dir`配置指定。服务器日志详细程度可通过`verbose`配置项指定。  
`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文件最大大小为256MB。  
`verbose`配置项控制日志的详细程度，从粗到细分为`0, 1, 2`三个等级，默认等级为`1`。等级为`2`时，日志记录最详细，服务器将打印`DEBUG`及以上等级的全部日志信息；等级为`1`时，服务器将仅打印`INFO`等级及以上的主要事件的日志；等级为`0`时，服务器将仅打印`ERROR`等级及以上的错误日志。' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.1.服务器日志配置项'}","page_content='日志信息

2.服务器日志

2.3.存储过程日志

用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)  
#### 2.3.1.cpp存储过程
请使用2.2中提供的log宏输出调试信息，避免使用cout或者printf等输出方式。具体使用方式可参考如下示例代码（详见`procedures/demo/log_demo.cpp`）  
```
#include <stdlib.h>
#include ""lgraph/lgraph.h""
#include ""tools/lgraph_log.h""  // add log dependency
using namespace lgraph_api;' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.3.存储过程日志'}",空,空,空,空,空,空,空,空
在实际应用中，调用算法 `algo.shortestPath` 的例子可以是：如何在城市公共交通系统中计算从一个地点到另一个地点的最短路径？,"page_content='QA汇总

Cypher QA

查询最短路径

Q：如何查询最短路径，shortestPath 函数如何使用？
A：使用示例如下（示例图谱：MovieDemo）  
```
MATCH (n1 {name:'Corin Redgrave'}),(n2 {name:'Liam Neeson'})
CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost
RETURN nodeIds,relationshipIds,cost
```  
详尽使用方案请参考官网文档https://www.tugraph.org/doc?version=V3.3.0&id=10000000000658658。' metadata={'Header 1': 'QA汇总', 'Header 2': 'Cypher QA', 'Header 3': '查询最短路径'}","page_content='内置算法

基础算法包

单源最短路径

单源最短路径实现了Single Source Shortest Path算法，根据给定的源点，计算从该源点出发到其他任意点的最短路径长度。算法内容请参考 [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem ""shortest path wiki"")。' metadata={'Header 1': '内置算法', 'Header 2': '基础算法包', 'Header 3': '单源最短路径'}","page_content='内置算法

扩展算法包

多源最短路径

多源最短路径程序实现了Multiple-source Shortest Paths算法，根据给定的多个源点，从这些源点出发，计算到达任意点的最短路径值。其中，多个源点到某一点的最短路径值为分别从每个源点出发到达该点的最短路径的最小值。算法内容请参考 [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem ""shortest path wiki"")。' metadata={'Header 1': '内置算法', 'Header 2': '扩展算法包', 'Header 3': '多源最短路径'}","page_content='Cypher API

5.附录2. 内置procedures列表

* algo.shortestPath(startNode, endNode, config)

| config    | MAP        | the filter of shortest paths, the formate as {maxHops:3, relationshipQuery:'HAS_CHILD'} |  
**Output:**  
If successful, it will returns one group result of the shortest path.  
**Example input:**  
```
MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})
CALL algo.shortestPath(n1,n2) YIELD nodeCount,totalCost RETURN nodeCount,totalCost
```  
**Example output:**  
| nodeCount | totalCost |
| --------- | --------- |
| 2     | 1     |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.shortestPath(startNode, endNode, config)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* algo.shortestPath(startNode, endNode, config)

| --------- | -------------- | ------------------------------------------------------------ |
| startNode | Node       | the source node of paths                     |
| endNode   | Node       | the destination node paths                   |
| config    | MAP        | the filter of shortest paths, the formate as {maxHops:3, relationshipQuery:'HAS_CHILD'} |  
**Output:**  
If successful, it will returns one group result of the shortest path.  
**Example input:**  
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.shortestPath(startNode, endNode, config)'}",空,空,空,空,空
方法 GetLabel() 返回什么类型的结果？,"page_content='src/cypher/arithmetic/arithmetic_expression.cpp/ cypher::FieldData BuiltinFunction::Label(RTContext *ctx, const Record &record,
                                         const std::vector<ArithExprNode> &args) {
    if (args.size() != 2) CYPHER_ARGUMENT_ERROR();
    auto operand = args[1];
    auto r = operand.Evaluate(ctx, record);
    lgraph::FieldData res;
    if (r.IsNode()) {
        if (!r.node->IsValidAfterMaterialize(ctx)) CYPHER_INTL_ERR();
        res = lgraph::FieldData(r.node->ItRef()->GetLabel());
    } else if (r.IsRelationship() && VALIDATE_EIT(r)) {
        res = lgraph::FieldData(r.relationship->ItRef()->GetLabel());
    } else {
        throw lgraph::CypherException(""Invalid argument of "" + std::string(__func__));
    }
    return cypher::FieldData(res);
}

cypher::FieldData BuiltinFunction::Type(RTContext *ctx, const Record &record,
                                        const std::vector<ArithExprNode> &args) {
    if (args.size() != 2) CYPHER_ARGUMENT_ERROR();
    auto operand = args[1];
    auto r = operand.Evaluate(ctx, record);
    CHECK_RELP(r);
    if (!VALIDATE_EIT(r)) return cypher::FieldData();
    return cypher::FieldData(lgraph::FieldData(r.relationship->ItRef()->GetLabel()));
}' metadata={'file_name': 'arithmetic_expression.cpp', 'file_path': 'src/cypher/arithmetic/arithmetic_expression.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/arithmetic_expression.cpp'}",空,空,空,空,空,空,空,空,空
Rust存储过程目前支持哪个版本的TuGraph？,"page_content='Rust 存储过程

1. 介绍

Rust 存储过程目前仅支持v1版本，TuGraph能够支持一切编译成动态库的语言作为插件。Rust语言作为系统编程语言的新起之秀，在安全性上、可靠性以及人体工程学上相较于C++具有较大优势。  
我们提供了TuGraph的[Rust binding]库来支持在Rust中调用lgrahp api，同时提供[tugraph-plugin-util] 工具库来帮助大家更加简洁地编写Rust插件代码。  
[Rust binding]: https://crates.io/crates/tugraph
[tugraph-plugin-util]: https://crates.io/crates/tugraph-plugin-util' metadata={'Header 1': 'Rust 存储过程', 'Header 2': '1. 介绍'}","page_content='Procedure API

2.存储过程的版本支持

目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph query language，APOC）。  
|                        | Procedure v1                       | Procedure v2               |
| ---------------------- | ---------------------------------- | -------------------------- |
| 适用场景                 | 极致性能，或者复杂的多事务管理情形       | 一般情况，与Cypher高度联动 |
| 事务                    | 函数内部创建，可自由控制多事务          | 外部传入函数，单一事务     |' metadata={'Header 1': 'Procedure API', 'Header 2': '2.存储过程的版本支持'}","page_content='Procedure API

2.存储过程的版本支持

| Cypher Embeded Call    | 不支持                              | 支持                  |
| 语言                    | C++/Python/Rust                    | C++                  |
| 调用模式                 | 直接传字符串，一般为JSON               | 通过Cypher语句中的变量  |  
在TuGraph中，存储过程v1和v2单独管理，支持增删查，但仍不建议重名。' metadata={'Header 1': 'Procedure API', 'Header 2': '2.存储过程的版本支持'}","page_content='Procedure API

3.存储过程语言支持

在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。  
注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。' metadata={'Header 1': 'Procedure API', 'Header 2': '3.存储过程语言支持'}","page_content='功能概览

4.核心功能

4.2.存储过程

当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个
处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。  
从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。  
TuGraph 支持 POG (Procedres on Graph Query Languages) 编程和 POG 库，其中“Graph Query Languages”包含 Cypher 以及
制定中的 ISO GQL 等图查询语言。POG 库提供在查询语言中对用户定义的存储过程的访问，打破了查询语言和存储过程之间的界限，扩展了查询
语言的使用范围。  
> 这个文档描述了 [新的 Procedure 编程范式以及 POG](../9.olap&procedure/1.procedure/1.procedure.md)。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.2.存储过程'}",空,空,空,空,空
TuGraph使用什么测试框架进行单元测试？,"page_content='单元测试

1.简介

TuGraph单元测试采用gtest框架，可以选择一次跑全部test或者制定某些test。' metadata={'Header 1': '单元测试', 'Header 2': '1.简介'}","page_content='集成测试

1.TuGraph集成测试的意义

在单元测试与功能测试中，有部分用例直接开启galaxy或statemachine来进行测试，这并不是一个完整的流程。在完整的cs架构中，用户请求是通过客户端发往服务端，网络通信是必不可少的，为了避免单元测试不完整带来的bug，针对这种情况，使用集成测试框架进行全链路的完整测试。' metadata={'Header 1': '集成测试', 'Header 2': '1.TuGraph集成测试的意义'}","page_content='集成测试

2.TuGraph集成测试框架

TuGraph采用pytest框架作为自己的集成测试框架，pytest框架作为目前使用最广泛的cs端集成测试框架，以其灵活简单，容易上手，并且支持参数化的使用方式而著称，TuGraph基于pytest提供的功能，抽象出了不同的工具，通过参数来控制各个工具的处理逻辑，以方便大家进行高效的测试代码开发。  
更多pytest信息请参考官网: [https://docs.pytest.org/en/7.2.x/getting-started.html](https://docs.pytest.org/en/7.2.x/getting-started.html)' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架'}","page_content='src/client/python/TuGraphClient/unit_tests.py/ class AsyncTuGraphClientTest(unittest.TestCase):' metadata={'file_name': 'unit_tests.py', 'file_path': 'src/client/python/TuGraphClient/unit_tests.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/TuGraphClient/unit_tests.py'}","page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

def test_server(self, server):
pass
```  
#### 2.2.2.client  
##### 2.2.2.1.启动参数
采用python字典传入
+ host是TuGraph Server的ip和端口
+ user是TuGraph Server的用户名
+ password是TuGraph Server 中user对应的密码  
```python
CLIENTOPT = {""host"":""127.0.0.1:9092"", ""user"":""admin"", ""password"":""73@TuGraph""}
```  
##### 2.2.2.2.启动命令
通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动客户端，函数执行结束后会结束客户端  
```python
@pytest.mark.parametrize(""server"", [SERVEROPT], indirect=True)' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}",空,空,空,空,空
创建 Label 的请求是否需要指定该 Label 是用于点（vertex）还是边（relationship）？,"page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | Label 名 | 字符串 |
| fields | 数据列定义 | 列表 |
| is_vertex | 是否是点 Label | 布尔值 |
| primary | 点的主键属性 | 字符串 |
| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

| name | Label 名 | 字符串 |
| fields | 数据列定义 | 列表 |
| is_vertex | 是否是点 Label | 布尔值 |
| primary | 点的主键属性 | 字符串 |
| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。  
`edge_constraints` 在 `is_vertex` 为 `false` 的时候设置，这个字段只有边有。这个字段限制了该边的起点和终点只能是哪些点的组合，比如：`[[""vertex_label1"",""vertex_label2""],[""vertex_label3"",""vertex_label4""]]`，限制了该边只能是从 `vertex_label1` 到 `vertex_label2` 和 从 `vertex_label3` 到 `vertex_label4`。如果不想有任何限制，不设置该字段即可。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

TuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。  
Label 操作对应的 URI 格式为  
```
http://{host}:{port}/db/{graph_name}/label/{type}/{label_name}
```  
其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | Label 名 | 字符串 |' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='src/restful/server/rest_server.cpp/ std::string label;
    std::vector<std::string> properties;
    bool is_vertex;
    std::string src_label, dst_label;
    GET_REQUIRED_JSON_FIELD(body, ""label"", label);
    GET_REQUIRED_JSON_FIELD(body, ""properties"", properties);
    GET_REQUIRED_JSON_FIELD(body, ""is_vertex"", is_vertex);
    if (!is_vertex) {
        GET_REQUIRED_JSON_FIELD(body, ""src_label"", src_label);
        GET_REQUIRED_JSON_FIELD(body, ""dst_label"", dst_label);
    }
    if (properties.empty()) {
        return RespondBadRequest(request, FMA_FMT(""properties is empty""));
    }
    if (label.empty()) {
        return RespondBadRequest(request, FMA_FMT(""label is empty""));
    }

    AccessControlledDB db = galaxy_->OpenGraph(user, _TS(paths[1]));
    auto txn = db.CreateReadTxn();
    auto schema = txn.GetSchema(label, is_vertex);
    if (!schema) {
        return RespondBadRequest(
            request, FMA_FMT(""No such {} label: {}"", is_vertex ? ""vertex"" : ""edge"", label));
    }
    auto label_id = schema->GetLabelId();
    size_t NOT_FOUND = size_t(-1);
    size_t src_id_index = NOT_FOUND, dst_id_index = NOT_FOUND;
    size_t edge_prop_size = 0;' metadata={'file_name': 'rest_server.cpp', 'file_path': 'src/restful/server/rest_server.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/restful/server/rest_server.cpp'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

Create a vertex or edge label.  
**Parameters:**  
| parameter  | parameter type | description           |
| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |
| label_name | string     | name of the label     |
| extra      | string     | for edge, it means constraints; for vertex, it means primary property |
| field_spec | list       | specification of a field  |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}",空,空,空,空,空
在 TuGraph 中使用的两种主要图分析操作是什么？,"page_content='HTAP

2.设计

在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。  
- 事务操作，即图事务引擎测的操作，为局部图的增删查改操作，典型的应用为 K 跳访问 K-Hop。
- 简单分析操作，是图分析引擎中较为简单的部分，通常也是局部的图分析操作，比如两点间最短路算法 SPSP、Jaccard 算法。
- 复杂分析操作，是图分析引擎中较为复杂的部分，通常涉及全图的多轮数据迭代操作，比如网页排序算法 PageRank、社区发现算法 Louvain。  
如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。  
- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。
- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。' metadata={'Header 1': 'HTAP', 'Header 2': '2.设计'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

TuGraph 的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。 在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='OlapBase API

7. 图类OlapBase

7.4 批处理操作

TuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程。分别是：  
```c++
/*
函数名称:ReducedSum ProcessVertexInRange(std::function<ReducedSum(size_t)> work, size_t lower, size_t upper,
ReducedSum zero = 0,std::function<ReducedSum(ReducedSum, ReducedSum)> reduce =reduce_plus<ReducedSum>)

函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；
第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。
具体实现请参考include/lgraph/olap_base.h中具体代码

使用示例:统计数组parent数组中有出边的点个数
*/' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.4 批处理操作'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。  
TuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法。涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

4. 演示

环路检测 Demo 提供了两种方式来进行交互：  
* 方式一 在输入框中输入点边信息
* 方式二 使用内置数据进行演示  
> 两种方式本质都是调用 Tugraph Analytics 进行实时计算，不过方式二省略了手动输入过程。  
这里我们使用内置数据进行快速演示，点击【选项】，选择`添加点`，画布中出现了 7 个点信息；接着选择`添加边`。我们可以在上方对话框中看到添加记录。  
<img width=""332"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/7ca76607-41a1-4afe-9427-cf7599de6889"">  
同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '4. 演示'}",空,空,空,空,空
如何在代码中为TuGraph-DB增加日志输出埋点？,"page_content='日志信息

2.服务器日志

2.3.存储过程日志

extern ""C"" bool Process(GraphDB& db, const std::string& request, std::string& response) {
response = ""TuGraph log demo"";
LogExample();
return true;
}
```
将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。  
#### 2.3.1.python存储过程
请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.3.存储过程日志'}",空,空,空,空,空,空,空,空,空
在删除边的全文索引时，如果边标签或字段不存在，会抛出什么异常？,"page_content='src/lucene/src/main/java/Lucene.java/ public void deleteEdge(long srcId, long destId, int labelId, int edgeId) throws IOException {
        BooleanQuery.Builder builder = new BooleanQuery.Builder();
        builder.add(LongPoint.newExactQuery(""srcId"", srcId), BooleanClause.Occur.MUST);
        builder.add(LongPoint.newExactQuery(""destId"", destId), BooleanClause.Occur.MUST);
        builder.add(IntPoint.newExactQuery(""labelId"", labelId), BooleanClause.Occur.MUST);
        builder.add(IntPoint.newExactQuery(""edgeId"", edgeId), BooleanClause.Occur.MUST);
        writer.deleteDocuments(builder.build());
    }

    public void commit() throws IOException {
        writer.commit();
    }' metadata={'file_name': 'Lucene.java', 'file_path': 'src/lucene/src/main/java/Lucene.java', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lucene/src/main/java/Lucene.java'}",空,空,空,空,空,空,空,空,空
Grafana主要用于什么？,空,空,空,空,空,空,空,空,空,空
DeleteProcedure 函数是用来执行什么操作的？,"page_content='Java客户端

2.使用示例

2.10.删除存储过程

@param procedureName: procedure name
@param graph: the graph to query.
@return: the result of procedure execution
public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Python客户端

3.RPC Client

| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)                                                                                            | bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name, const std::string& graph)' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='Python客户端

3.RPC Client

3.10.删除存储过程

```python
ret, res = client.deleteProcedure(""CPP"", ""sortstr"", ""default"")
```
```
deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.10.删除存储过程'}","page_content='Java客户端

2.使用示例

2.10.删除存储过程

```java
String result = client.deleteProcedure(""CPP"", ""sortstr"", ""default"");
log.info(""loadProcedure : "" + result);
```
```
@param procedureType: the procedure type, currently supported CPP and PY
@param procedureName: procedure name
@param graph: the graph to query.
@return: the result of procedure execution
public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}",空,空,空,空,空,空
PairUniqueIndex 的钥匙生成形式是什么？,"page_content='src/core/lightning_graph.cpp/ case IndexType::PairUniqueIndex:
                    {
                        for (size_t i = 1; i < key_euids.size(); i++) {
                            if (key_euids[i].key == key_euids[i - 1].key &&
                                key_euids[i].euid.src == key_euids[i - 1].euid.src &&
                                key_euids[i].euid.dst == key_euids[i - 1].euid.dst)
                                THROW_CODE(InputError,
                                    ""Duplicate edge index keys-vid [{}] found for vid {} ""
                                    ""dst{} eid {}, and {} {} {}."",
                                    key_euids[i].key, key_euids[i].euid.src, key_euids[i].euid.dst,
                                    key_euids[i].euid.eid, key_euids[i - 1].euid.src,
                                    key_euids[i - 1].euid.dst, key_euids[i - 1].euid.eid);
                        }
                        for (auto& kv : key_euids)
                            edge_index->_AppendIndexEntry(txn.GetTxn(), GetKeyConstRef(kv.key),
                                                          (EdgeUid)kv.euid);
                        break;
                    }' metadata={'file_name': 'lightning_graph.cpp', 'file_path': 'src/core/lightning_graph.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/lightning_graph.cpp'}","page_content='src/core/lightning_graph.cpp/ case IndexType::PairUniqueIndex:
            {
                for (size_t i = 1; i < key_euids.size(); i++) {
                    if (key_euids[i].key == key_euids[i - 1].key &&
                        key_euids[i].euid.src == key_euids[i - 1].euid.src &&
                        key_euids[i].euid.dst == key_euids[i - 1].euid.dst)
                        THROW_CODE(InputError,
                            ""Duplicate edge index keys-vid [{}] found for vid {} ""
                            ""dst{} eid {}, and {} {} {}."",
                            key_euids[i].key, key_euids[i].euid.src, key_euids[i].euid.dst,
                            key_euids[i].euid.eid, key_euids[i - 1].euid.src,
                            key_euids[i - 1].euid.dst, key_euids[i - 1].euid.eid);
                }
                LOG_DEBUG() << ""add pair_unique index"";
                for (size_t i = 0; i < key_euids.size(); i++) {
                    if (i != 0 && i % batch_commit_size == 0) {
                        txn.Commit();
                        LOG_DEBUG() << ""committed "" << i << "" keys"";
                        txn = CreateWriteTxn();
                    }
                    auto& kv = key_euids[i];
                    index->_AppendIndexEntry(txn.GetTxn(), GetKeyConstRef(kv.key),
                                             (EdgeUid)kv.euid);
                }
                break;
            }' metadata={'file_name': 'lightning_graph.cpp', 'file_path': 'src/core/lightning_graph.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/lightning_graph.cpp'}","page_content='src/core/vertex_index.cpp/ Value VertexIndexIterator::GetKey() const {
    switch (type_) {
    case IndexType::GlobalUniqueIndex:
        {
            return _detail::ReturnKeyEvenIfLong(it_->GetKey());
        }
    case IndexType::NonuniqueIndex:
        {
            Value key_vid = it_->GetKey();
            return _detail::ReturnKeyEvenIfLong(
                Value(key_vid.Data(), key_vid.Size() - _detail::VID_SIZE));
        }
    case IndexType::PairUniqueIndex:
        {
            THROW_CODE(InputError, ""vertex index do not support pair-unique attributes"");
        }
    }
    return Value();
}

FieldType VertexIndexIterator::KeyType() const { return index_->KeyType(); }' metadata={'file_name': 'vertex_index.cpp', 'file_path': 'src/core/vertex_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/vertex_index.cpp'}","page_content='src/core/edge_index.cpp/ std::unique_ptr<KvIterator> InitEdgeIndexIterator(KvTransaction& txn, KvTable& table,
                                                  const Value& key, VertexId vid, VertexId vid2,
                                                  LabelId lid, TemporalId tid, EdgeId eid,
                                                  IndexType type) {
    switch (type) {
    case IndexType::GlobalUniqueIndex:
        return table.GetClosestIterator(txn, key);
    case IndexType::PairUniqueIndex:
        return table.GetClosestIterator(txn, _detail::PatchPairUniqueIndexKey(key, vid, vid2));
    case IndexType::NonuniqueIndex:
        return table.GetClosestIterator(
            txn, _detail::PatchNonuniqueIndexKey(key, vid, vid2, lid, tid, eid));
    }
    return std::unique_ptr<KvIterator>();
}

Value InitKeyEndValue(const Value& key, IndexType type) {
    switch (type) {
    case IndexType::GlobalUniqueIndex:
        return Value::MakeCopy(key);
    case IndexType::PairUniqueIndex:
        return _detail::PatchPairUniqueIndexKey(key, -1, -1);
    case IndexType::NonuniqueIndex:
        return _detail::PatchNonuniqueIndexKey(key, -1, -1, -1, -1, -1);
    }
    return Value();
}

inline Value ReturnKeyEvenIfLong(Value&& v) { return std::move(v); }

}' metadata={'file_name': 'edge_index.cpp', 'file_path': 'src/core/edge_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/edge_index.cpp'}","page_content='src/core/edge_index.cpp/ {

/**
 * Patch the key with the specified vid.
 *
 * \param           key     The key.
 * \param           src_vid     The src_vid.
 * \param           src_vid     The dst_vid.
 * \param           lid         The label id.
 * \param           tid         The temporal id.
 * \param           eid     The eid.
 * \return  The patched key.
 */
static Value PatchNonuniqueIndexKey(const Value& key, VertexId src_vid, VertexId end_vid,
                                    LabelId lid, TemporalId tid, EdgeId eid) {
    Value key_euid(key.Size() + EUID_SIZE);
    memcpy(key_euid.Data(), key.Data(), key.Size());
    WriteVid(key_euid.Data() + key.Size(), src_vid);
    WriteVid(key_euid.Data() + key.Size() + VID_SIZE, end_vid);
    WriteLabelId(key_euid.Data() + key.Size() + LID_BEGIN, lid);
    WriteTemporalId(key_euid.Data() + key.Size() + TID_BEGIN, tid);
    WriteEid(key_euid.Data() + key.Size() + EID_BEGIN, eid);
    return key_euid;
}

static Value PatchPairUniqueIndexKey(const Value& key, VertexId src_vid, VertexId end_vid) {
    Value key_euid(key.Size() + VID_SIZE * 2);
    memcpy(key_euid.Data(), key.Data(), key.Size());
    WriteVid(key_euid.Data() + key.Size(), src_vid);
    WriteVid(key_euid.Data() + key.Size() + VID_SIZE, end_vid);
    return key_euid;
}' metadata={'file_name': 'edge_index.cpp', 'file_path': 'src/core/edge_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/edge_index.cpp'}",空,空,空,空,空
类FieldData用于表示哪些类型的数据？,空,空,空,空,空,空,空,空,空,空
在线全量导入TuGraph时，如果发生数据包错误，默认行为是什么？,"page_content='数据导入

5.在线增量导入

-h, --help          Print this help message. Default=0.
```  
文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据发送到正在运行的 TuGraph 实例中，该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。  
如果用户和密码有效，并且指定的图存在，导入工具将将数据发送到服务器，服务器随后解析数据并将其写入指定的图。数据将以大约 16MB 大小的包发送，在最近的换行符处中断。每个包都是以原子方式导入的，这意味着如果成功导入包，则成功导入所有数据，否则，任何数据都不会进入数据库。如果指定了`--continue_on_error true`，则忽略数据完整性错误，并忽略违规行。否则，导入将在第一个错误包处停止，并打印出已导入的包数。在这种情况下，用户可以修改数据以消除错误，然后使用`--skip_packages N`重做导入以跳过已导入的包。' metadata={'Header 1': '数据导入', 'Header 2': '5.在线增量导入'}","page_content='RESTful API Legacy

6.Deprecated

6.10.在线增量导入

| continue_on_error | 出错后是否继续导入（可选，默认为`false`
） | 布尔值 |
| delimiter | 分隔符（可选，默认为`“,”`
） | 字符串 |  
description 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。  
分隔符可以是单字符，也可以是字符串，但不能包含`\r`或者`\n`。  
data 可以是如下形式之一：  
- 字符串如 `""1,2\n3,4\n""`
- ASCII 码组成的数组如 `[49,44,50,10,51,44,52,10]`
- 形如上述数组的字典如 `{""0"":49,""1"":44,""2"":50,""3"":10,""4"":51,""5"":44,""6"":52,""7"":10}`  
- **RESPONSE**:  
系统**不会**自动执行新建 label、添加索引等操作。在此操作之前需要保证涉及的 label 已经存在并具有适当的索引。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.10.在线增量导入'}","page_content='RESTful API Legacy

6.Deprecated

6.10.在线增量导入

#### 6.10.1.指定文件内容导入  
- **URI**: `/db/{graph_name}/import/text`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 文件内容描述 | 字符串 |
| data | 要导入的文件内容（建议最大在 16MB 左右，最长不超过 17MB） | 字符串 / 数组 / 对象 |
| continue_on_error | 出错后是否继续导入（可选，默认为`false`
） | 布尔值 |
| delimiter | 分隔符（可选，默认为`“,”`
） | 字符串 |  
description 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。  
分隔符可以是单字符，也可以是字符串，但不能包含`\r`或者`\n`。  
data 可以是如下形式之一：  
- 字符串如 `""1,2\n3,4\n""`' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.10.在线增量导入'}","page_content='数据导入

4.离线全量导入

- **-i, --continue_on_error** `true/false`: 在碰到错误时跳过错误并继续，默认为 false，碰到错误立即退出。
- **-d, --dir** `{diretory}`: 数据库目录，导入工具会将数据写到这个目录。默认为`./db`。
- **--delimiter** `{delimiter}`: 数据文件分隔符。只在数据源是 CSV 格式时使用，默认为`"",""`。
- **-u, --username** `{user}`: 数据库用户名。需要是管理员用户才能执行离线导入。
- **-p, --password** `{password}`: 指定的数据库用户的密码
- **--overwrite** `true/false`: 是否覆盖数据。设为 true 时，如果数据目录已经存在，则覆盖数据。默认为`false`。
- **-g, --graph** `{graph_name}`: 指定需要导入的图种类。
- **-h, --help**: 输出帮助信息。' metadata={'Header 1': '数据导入', 'Header 2': '4.离线全量导入'}","page_content='数据导入

6.在线全量导入

在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：
1. 和离线导入类型相同的原数据文件（csv等）
2. TuGraph的底层存储文件，即data.mdb文件，该文件可以由离线导入生成，也可以是其他TuGraph db的文件。
这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，
只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，
而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入'}",空,空,空,空,空
ORDER BY在GQL中有什么作用？,"page_content='ISO GQL

2.Clauses

2.6.ORDER BY

`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。  
#### 对结果排序  
```
MATCH (n:Person WHERE n.birthyear < 1970)
RETURN n.birthyear AS q
ORDER BY q ASC
LIMIT 5
```  
返回结果
```JSON
[{""q"":1873},{""q"":1908},{""q"":1910},{""q"":1930},{""q"":1932}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.6.ORDER BY'}","page_content='Example

Order By

```sql
SELECT * from user order by age;

SELECT age, count(id) as cnt FROM user GROUP BY age Having count(id) > 10 Order by cnt;
```' metadata={'Header 1': 'Example', 'Header 2': 'Order By'}",空,空,空,空,空,空,空,空
TuGraph-DB是否提供HTTP接口？如果提供，相关的接口代码可以在哪里找到？,"page_content='RESTful API Legacy

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。  
**注意：除""登陆""、""查询""和""存储过程""外，其余接口自 **2023年4月30日** 起将不再提供支持，统一使用Cypher接口提供服务。**' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '1.简介'}","page_content='RESTful API

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。' metadata={'Header 1': 'RESTful API', 'Header 2': '1.简介'}","page_content='RESTful API Legacy

3.登录

TuGraph 提供基于 JWT 的用户认证方式，可以使用 HTTP 或 HTTPS 协议进行传输。系统默认使用 HTTP 协议，如果需要使用 HTTPS，需要在 lgraph.json 配置文件中将 ssl_auth 设为 1。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持RESTful API

除了支持Cypher查询语言，TuGraph还提供了RESTful API接口。这使得我可以通过编程方式与图数据库进行交互，更好地将TuGraph集成到我的应用程序中。API设计合理，易于使用，为我提供了灵活性和自由度。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持RESTful API'}","page_content='RESTful API

2.请求与响应格式

TuGraph HTTP Server 接收json格式的请求，经过鉴权后开始提取请求中的字段，根据定义好的接口逻辑处理请求，并返回json格式的响应。' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式'}",空,空,空,空,空
请问lgraph_peer工具是否只有在通过编译方式部署后才能使用？,空,空,空,空,空,空,空,空,空,空
当前图数据库应用程序使用的CPU比率是多少？,"page_content='RESTful API Legacy

6.Deprecated

6.3.服务器状态

| self | 图数据库应用程序 CPU 使用率 | 整型 |
| server | 服务器 CPU 使用率 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/cpu
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""self"": 25,
""server"": 35,
""unit"": ""%""
}
```  
#### 6.3.4.服务器硬盘状态  
- **URI**: `/info/disk`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| read | 服务器硬盘读速率 | 整型 |' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.3.服务器状态'}","page_content='RESTful API Legacy

6.Deprecated

6.3.服务器状态

""unit"": ""B""
},
""db_config"": {
""db_async"": false,
""disable_auth"": false,
""enable_ha"": false,
...
},
""up_time"": 3235
}
```  
#### 6.3.3.服务器 CPU 状态  
- **URI**: `/info/cpu`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| self | 图数据库应用程序 CPU 使用率 | 整型 |
| server | 服务器 CPU 使用率 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/cpu
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.3.服务器状态'}",空,空,空,空,空,空,空,空
