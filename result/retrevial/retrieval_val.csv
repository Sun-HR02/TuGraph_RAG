Q,K1,K2,K3
在 RPC 和 HA 服务中，verbose 参数的设置有几个级别？,"page_content='数据库运行

4.服务配置

4.1.配置参数

| verbose                      | 整型                    | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细。默认值为 1。' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据导入

4.离线全量导入

- **--verbose** `0/1/2`: 日志等级，等级越高输出信息越详细。默认为 1。
- **-i, --continue_on_error** `true/false`: 在碰到错误时跳过错误并继续，默认为 false，碰到错误立即退出。' metadata={'Header 1': '数据导入', 'Header 2': '4.离线全量导入'}","page_content='数据导入

6.在线全量导入

6.1 从原数据导入

-v, --verbose       Verbose level to use, higher means more verbose.
Default=1.' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入', 'Header 3': '6.1 从原数据导入'}"
在磁盘IO监控的配置中，当哪一个值大于10000时会触发危急颜色模式？,"page_content='运维监控

2.部署方案

2.4.第四步

""op"": ""gt"",
""value"": 10000,
""visible"": true
}
],
""title"": ""磁盘IO"",
""type"": ""timeseries""
}
],
""refresh"": """",
""schemaVersion"": 36,' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='运维监控

2.部署方案

2.4.第四步

""handler"": 1,
""message"": ""【生产图数据库Grafana】\n  磁盘IO超过10MB/S"",
""name"": ""磁盘IO alert"",
""noDataState"": ""no_data"",
""notifications"": []' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='运维监控

2.部署方案

2.4.第四步

""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}"
`FieldData` 类中的函数 `IsReal()` 是用来查询数据是否属于实数类型的数据吗？,page_content='boolean IS NOT FALSE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回true。',page_content='boolean IS TRUE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回false。',"page_content='Cypher API

3.Functions

3.2.Predicate functions

- exists()
judge it whether a vertex or edge has the field .
**Scope:** whole instance.
**Example input:**  
```
MATCH (n)' metadata={'Header 1': 'Cypher API', 'Header 2': '3.Functions', 'Header 3': '3.2.Predicate functions'}"
成功修改一个用户的描述时，应返回什么状态码？,"page_content='RESTful API Legacy

6.Deprecated

6.1.用户管理

- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/user1/description' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.1.用户管理'}","page_content='RESTful API Legacy

6.Deprecated

6.1.用户管理

| user | 用户名 | 字符串 |
| password | 密码 | 字符串 |
| description | 用户描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.1.用户管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

| description | 新描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}"
边关联的两个点的字段是否一定是点的主键？,"page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='业务开发指南

导入数据

批量upsert边数据

注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。  
推荐使用driver里面的参数化特性，避免自己构造语句。
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据'}","page_content='图相关DDL

Create Graph

**Syntax**
一个图至少包含一对点边，点表必须包含一个id字段作为主键，边表必须包含srcId和targetId作为主键，边表还可以有一个时间戳字段标识时间。  
```
CREATE GRAPH <graph name>
(' metadata={'Header 1': '图相关DDL', 'Header 2': 'Create Graph'}"
OutEdgeIterator 类的 Delete 方法执行什么操作？,"page_content='业务开发指南

边类型操作

删除边类型

>该操作会同步删除所有该类型的边，数据量大的时候，有时间消耗。  
如下例子，删除边类型`edge1`以及该类型的所有边数据。
```
CALL db.deleteLabel('edge', 'edge1')
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '删除边类型'}","page_content='业务开发指南

边类型操作

边类型删除字段

>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。  
如下操作，对于边类型`edge1`，一次删除了两个字段: `field1` 和 `field2`。
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '边类型删除字段'}","page_content='RESTful API Legacy

6.Deprecated

6.8.边操作

},
""label"": ""MARRIED""
}
```  
#### 6.8.7.删除边  
- **URI**: `/db/{graph_name}/relationship/{euid}`
- **METHOD**: DELETE' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.8.边操作'}"
如何调整TuGraph-DB的日志等级？,"page_content='TuGraph-db

2. 快速上手

一个简单的方法是使用docker进行设置，可以在DockerHub)中找到, 名称为`tugraph/tugraph-runtime-[os]:[tugraph version]`,' metadata={'Header 1': 'TuGraph-db', 'Header 2': '2. 快速上手'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

三、TuGraph-DB高可用集群部署与应用

3\. Client连接应用

leader 再同步到 follower，可以看到是有日志同步的。' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '三、TuGraph-DB高可用集群部署与应用', 'Header 3': '3\\. Client连接应用'}","page_content='数据库运行

3.服务操作

3.4.新旧前端切换

`docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.4.新旧前端切换'}"
在机器性能指标中，“memory”指的是什么？,"page_content='性能优先

3.存储数据结构

意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='性能优先

3.存储数据结构

在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='TuGraph与ARM架构

内容：

**测试介绍：**

率较上一次官方纪录提升了31%。在300GB数据集上，TuGraph测试了超过内存容量的数据吞吐量，虽然较100GB的性能有所下降，但考虑内存和硬盘的读写性能鸿沟，该结果也在预期之内。**除了性能测试，TuGraph在****系统事务性、可恢复性、正确性、' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**测试介绍：**'}"
如果不选择清空画布数据按钮，导入的数据会如何处理？,"page_content='可视化操作手册

2.操作指南

2.4.图项目

- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

- 覆盖当前画布中的模型：选中该选项，导入时会先清空已有图模型再导入模型文件中的图模型；不选择，会导入模型文件中新增的点类型和边类型，但不会修改已有的点类型和边类型。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}"
如何通过邮件向TuGraph团队提出关于其产品的建议？,"page_content='什么是TuGraph

4. TuGraph企业版

如需商业支持，请联系我们：  
- 电话：400-903-0809
- 邮件：tugraph@service.alipay.com
- 官网：https://tugraph.antgroup.com' metadata={'Header 1': '什么是TuGraph', 'Header 2': '4. TuGraph企业版'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='如何贡献

4. 贡献代码流程

4.1. 提交issue

不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:' metadata={'Header 1': '如何贡献', 'Header 2': '4. 贡献代码流程', 'Header 3': '4.1. 提交issue'}"
边索引是否支持加速查询？,"page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}","page_content='QA汇总

Cypher QA

长边条件查询

```  
A：目前还不支持不定长边的过滤查询。目前的代替方案只能是分开写。上面的示例，就需要从 1 跳到 3 跳都写一遍。' metadata={'Header 1': 'QA汇总', 'Header 2': 'Cypher QA', 'Header 3': '长边条件查询'}"
TuGraph Monitor的主要功能是什么？,"page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='可视化操作手册（旧版）

作用

TuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '作用'}","page_content='功能概览

4.核心功能

4.5 数据预热

TuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.5 数据预热'}"
TuGraph HA 集群的管理工具是什么？,"page_content='集群管理

1. 简介

HA集群启动之后，可以使用`lgraph_peer`工具进行集群管理，可以执行删除节点，转移leader和生成snapshot等功能。' metadata={'Header 1': '集群管理', 'Header 2': '1. 简介'}","page_content='TuGraph Management

简介

TuGraph Management 是一款为TuGraph开发的算法任务管理工具。采用了sofastack与brpc作为通信框架，并使用sqlite进行持久化存储。  
主要功能：  
- 算法任务状态持久化存储  
- 算法任务结果持久化存储' metadata={'Header 1': 'TuGraph Management', 'Header 2': '简介'}","page_content='部署高可用模式

3.启动初始备份组

安装好TuGraph之后，可以使用`lgraph_server`命令在不同的机器上启动高可用集群。本节主要讲解高可用集群的启动方式，启动之后的集群状态管理参见[lgraph_peer工具](../6.utility-tools/5.ha-cluster-m' metadata={'Header 1': '部署高可用模式', 'Header 2': '3.启动初始备份组'}"
如何通过POST方法将Token的有效期修改为无限期？,"page_content='RESTful API Legacy

3.登录

3.3.修改Token有效期

- **URI**: `/update_token_time`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.3.修改Token有效期'}","page_content='Token使用说明

2. Token有效期

2.4. Token有效期修改

* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。可参考[服务运行文档](../5.installation&running/7.tugraph-running.md)。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.4. Token有效期修改'}","page_content='RESTful API Legacy

3.登录

3.3.修改Token有效期

- **RESPONSE**:  如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/update_token_time' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.3.修改Token有效期'}"
TuGraph图数据库是由哪两个机构联合研发的？,"page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='地理空间数据类型使用示例

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群。近年来，地理空间功能在图数据库中的应用价值显著，它不仅增强了数据的表达能力，还促进了跨领域数据的融合分析，尤其' metadata={'Header 1': '地理空间数据类型使用示例', 'Header 2': '1. 简介'}"
TuGraph图学习模块依赖于哪些系统？,"page_content='环境分类

2.依赖系统库

* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='环境分类

2.依赖系统库

* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='环境准备

2.软件环境

2.1. 操作系统

TuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。  
其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。' metadata={'Header 1': '环境准备', 'Header 2': '2.软件环境', 'Header 3': '2.1. 操作系统'}"
构造FieldSpec时需要哪些参数？,"page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

Create a vertex or edge label.  
**Parameters:**  
| parameter  | parameter type | description           |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createEdgeLabel( label_name, field_spec...)

Create an edge label.  
**Parameters:**  
| parameter  | parameter type | description          |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createEdgeLabel( label_name, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}"
TuGraph DB的并发性能优化最初面临的主要问题是什么？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

当 TuGraph 遇见 Antlr4

然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target 的并发性能不足以支持所需的超高并发 GQL 请求。经过调研并与 Antlr 开源社区讨论，我们发现\*\*并发性能这个问题普遍存在，并且在过去 5' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '当 TuGraph 遇见 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为 DFA、ATN 等结构），拼接出了数据竞争的完整链路。  
（4）破解数据竞争问题' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}"
在C++客户端中，实例化单节点client对象需要哪些参数？,"page_content='C++客户端

2.使用示例

2.1.实例化client对象

@param user: login user name
@param password: login password
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}"
TuGraph-DB查询引擎目前支持使用哪种查询语言？未来是否有计划支持其他查询语言？,"page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持RESTful API

除了支持Cypher查询语言，TuGraph还提供了RESTful API接口。这使得我可以通过编程方式与图数据库进行交互，更好地将TuGraph集成到我的应用程序中。API设计合理，易于使用，为我提供了灵活性和自由度。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持RESTful API'}","page_content='TuGraph-db

1. 简介

- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}"
DeleteProcedure 函数接受什么类型的参数，并请给它们命名？,"page_content='Python客户端

3.RPC Client

| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='Python客户端

3.RPC Client

| bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name,' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='RPC API

5.存储过程

5.3.删除存储过程

删除存储过程的请求包含以下参数：
- name: 必要参数，存储过程名称  
以C++为例，用户删除存储过程的方式如下所示：
```C++
LGraphRequest req;
req.set_is_write_op(true);' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.3.删除存储过程'}"
在使用FrontierTraversal进行并行执行遍历时，应选择哪种事务模式？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

FrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

);
```  
该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}"
RpcSingleClient 的构造函数需要哪些参数？,"page_content='RPC API

3.登录

登录请求信息包含以下参数：
- user: 必要参数，用户名
- pass: 必要参数，密码
以C++为例，用户使用构建好的服务存根发送登录请求：
```C++
auto* req = request.mutable_acl_request();' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='Python客户端

3.RPC Client

param, double procedure_time_out, bool in_process, const std::string& graph, bool json_format, const std::string& url)' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='RPC API

2.请求

2.2.请求类型

- client_version: 可选参数，HA模式下可通过对比`client_version`和`server_version`防止响应过时的请求
- token: 必要参数，客户端登陆之后获得token，每次请求传入token以校验用户身份' metadata={'Header 1': 'RPC API', 'Header 2': '2.请求', 'Header 3': '2.2.请求类型'}"
TuGraph中的expire_time默认设置是什么？,"page_content='QA汇总

Jwt Token QA

上限报错

1. 登出不使用的Token。
2. 重新启动TuGraph服务，会清空所有Token。
3. Token有效期默认为24小时，24小时后会自动失效并删除' metadata={'Header 1': 'QA汇总', 'Header 2': 'Jwt Token QA', 'Header 3': '上限报错'}","page_content='TuGraph-DataX

4.导出TuGraph

4.2.参数说明

* 必选：是 <br />
* 默认值：无 <br />  
* **username**
* 描述：TuGraph的用户名 <br />
* 必选：是 <br />
* 默认值：无 <br />  
* **password**' metadata={'Header 1': 'TuGraph-DataX', 'Header 2': '4.导出TuGraph', 'Header 3': '4.2.参数说明'}","page_content='Token使用说明

2. Token有效期

2.4. Token有效期修改

为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。  
* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.4. Token有效期修改'}"
TuGraph图学习模块中包括哪四种采样算子？,"page_content='Learn Tutorial

1.TuGraph 图学习模块简介

这个模块是一个基于图数据库的图学习模块，主要提供了四种采样算子：Neighbor Sampling、Edge Sampling、Random Walk Sampling 和 Negative' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '1.TuGraph 图学习模块简介'}","page_content='Training

2. Mini-Batch训练

Mini-Batch训练需要使用TuGraph 图学习模块的采样算子，目前支持Neighbor Sampling、Edge Sampling、Random Walk Sampling和Negative Sampling。' metadata={'Header 1': 'Training', 'Header 2': '2. Mini-Batch训练'}","page_content='Learn Tutorial

6. 采样算子及编译

TuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '6. 采样算子及编译'}"
在执行UpsertEdge操作时，如果提供的参数对应的边在现有边中存在，则返回值通常是更新后的边的信息。如果该边不存在，则将创建新的边，并返回新创建的边的信息。这意味着返回值将根据边的存在性而异。,"page_content='业务开发指南

导入数据

批量upsert边数据

CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'},' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据'}","page_content='业务开发指南

导入数据

批量upsert边数据-根据边的属性确定唯一

CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'},' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据-根据边的属性确定唯一'}","page_content='业务开发指南

导入数据

批量upsert边数据-根据边的属性确定唯一

```
CALL db.addEdgeIndex('edge1', 'score', false, true)
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据-根据边的属性确定唯一'}"
ANTLR4支持生成哪些目标语言的解析器？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

关于 Antlr4

Antlr4 是一款备受欢迎的开源解析器生成器，能够根据语法规则快速生成自定义解析器。其支持 LL(\*)解析，拥有更强大的错误处理能力和更快的解析速度。不仅如此，Antlr4 还支持 Java、Python、C++、JavaScript、Go 等 10' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '关于 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

关于 Antlr4

等 10 种目标语言，广泛应用于多种开发语言生态中。简单易用的 API 和文档使得开发人员能够快速上手。无论是编程语言、数据格式、编译器还是解释器等领域，Antlr4 都发挥着重要作用。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '关于 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

当 TuGraph 遇见 Antlr4

ISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4 作为一种强大的解析器生成器，成为了蚂蚁图数据库 TuGraph 生成 GQL 解释器的理想选择。Antlr4' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '当 TuGraph 遇见 Antlr4'}"
如果对DateTime对象添加超出其范围的微秒数，会发生什么情况？,"page_content='C++客户端

2.使用示例

2.2.调用cypher

format.
@param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.2.调用cypher'}","page_content='C++客户端

2.使用示例

2.4.调用GQL

format.
@param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.4.调用GQL'}","page_content='数据库运行

4.服务配置

4.1.配置参数

第一次打快照的时间，格式为""HH:MM:SS""，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为""""，表示在0-ha_snapshot_interval_s内的任一时刻随机' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}"
VertexLockGuard是什么？,"page_content='OlapBase API

7. 图类OlapBase

7.3 锁机制

- `VertexLockGuard GuardVertexLock(size_t vid)`：在对vid操作时，对点vid加锁，退出作用域时时自动释放锁' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.3 锁机制'}","page_content='OlapOnDisk API

2. 算法举例

2.4 bfs算法流程

if (parent[dst] == (size_t)-1) {
auto lock = graph.GuardVertexLock(dst);
if (parent[dst] == (size_t)-1) {
parent[dst] = vi;' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '2. 算法举例', 'Header 3': '2.4 bfs算法流程'}","page_content='OlapBase API

7. 图类OlapBase

7.3 锁机制

- `void ReleaseVertexLock(size_t vid)`：对点vid解锁，所有线程均可访存该锁对应的点数据' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.3 锁机制'}"
在使用value pack时，null array的具体含义是什么？,"page_content='QA汇总

数据导入QA

null array含义

Q：value pack时的null array的具体含义是？
A：标记这个schema的field是否为空，如果一个schema的field为空，并且插入的数据里对应的列是空的，在packed的时候就不占内存' metadata={'Header 1': 'QA汇总', 'Header 2': '数据导入QA', 'Header 3': 'null array含义'}","page_content='value1 <= value2 | 如果value1小于或等于value2，则返回true。
value IS NULL | 如果value为null，则返回true。'",page_content='value IS NOT NULL | 如果value不为null，则返回true。'
"TuGraph支持边属性匹配吗？为什么在使用类似于MATCH (n:chunk {id: '21604c19-0d30-11ef-b83b-0242ac110005'})-[r:kw {name:""生活补贴""}]-(m) RETURN n, r, m的Cypher查询时，无法过滤边属性？","page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}"
TuGraph是如何通过语句来定义点类型和边类型的？,"page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}"
如果不设置log_dir，是否意味着日志文件将不会被保存？,"page_content='日志信息

2.服务器日志

2.1.服务器日志配置项

`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.1.服务器日志配置项'}","page_content='日志信息

2.服务器日志

2.3.存储过程日志

用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)  
#### 2.3.1.cpp存储过程' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.3.存储过程日志'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| log_dir                      | 字符串                   | 日志文件所在的目录。默认目录为 /var/log/lgraph/。' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}"
在实际应用中，调用算法 `algo.shortestPath` 的例子是什么？,"page_content='Cypher API

5.附录2. 内置procedures列表

* algo.shortestPath(startNode, endNode, config)

CALL algo.shortestPath(n1,n2) YIELD nodeCount,totalCost RETURN nodeCount,totalCost
```  
**Example output:**' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.shortestPath(startNode, endNode, config)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* algo.shortestPath(startNode, endNode, config)

**Output:**  
If successful, it will returns one group result of the shortest path.  
**Example input:**  
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.shortestPath(startNode, endNode, config)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* algo.allShortestPaths(startNode, endNode, config))

CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost
```  
**Example output:**  
| nodeIds | cost |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.allShortestPaths(startNode, endNode, config))'}"
方法 GetLabel() 返回的结果是什么类型？,"page_content='ISO GQL

2.Clauses

2.3.RETURN

```  
#### 结果唯一性  
```
MATCH (n)
RETURN DISTINCT label(n) AS label
```  
返回结果  
```JSON' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.3.RETURN'}","page_content='ISO GQL

2.Clauses

2.3.RETURN

返回结果  
```JSON
[{""label"":""Person""},{""label"":""City""},{""label"":""Film""}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.3.RETURN'}","page_content='Cypher API

3.Functions

3.1.Whole List Of Functions

|                        | labels()         | 返回结果有且只有一个label |' metadata={'Header 1': 'Cypher API', 'Header 2': '3.Functions', 'Header 3': '3.1.Whole List Of Functions'}"
Rust 存储过程目前支持哪个版本的 TuGraph？,"page_content='Rust 存储过程

1. 介绍

Rust 存储过程目前仅支持v1版本，TuGraph能够支持一切编译成动态库的语言作为插件。Rust语言作为系统编程语言的新起之秀，在安全性上、可靠性以及人体工程学上相较于C++具有较大优势。' metadata={'Header 1': 'Rust 存储过程', 'Header 2': '1. 介绍'}","page_content='Procedure API

2.存储过程的版本支持

目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph' metadata={'Header 1': 'Procedure API', 'Header 2': '2.存储过程的版本支持'}","page_content='功能概览

4.核心功能

4.2.存储过程

从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.2.存储过程'}"
TuGraph单元测试使用的是什么测试框架？,"page_content='单元测试

1.简介

TuGraph单元测试采用gtest框架，可以选择一次跑全部test或者制定某些test。' metadata={'Header 1': '单元测试', 'Header 2': '1.简介'}","page_content='集成测试

2.TuGraph集成测试框架

TuGraph采用pytest框架作为自己的集成测试框架，pytest框架作为目前使用最广泛的cs端集成测试框架，以其灵活简单，容易上手，并且支持参数化的使用方式而著称，TuGraph基于pytest提供的功能，抽象出了不同的工具，通过参数来控制各个工具的' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架'}","page_content='集成测试

2.TuGraph集成测试框架

的工具，通过参数来控制各个工具的处理逻辑，以方便大家进行高效的测试代码开发。' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架'}"
创建 Label 的请求是否需要明确指定该 Label 是用于点（vertex）还是边（relationship）？,"page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

```  
其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='Bolt客户端

使用示例

//创建点模型
session.run(""CALL db.createVertexLabel('person', 'id' , 'id' ,INT32, false, 'name' ,STRING, false)"");
//创建边模型' metadata={'Header 1': 'Bolt客户端', 'Header 2': '使用示例'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}"
TuGraph 中使用的两种主要图分析操作是什么？,"page_content='HTAP

2.设计

在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。' metadata={'Header 1': 'HTAP', 'Header 2': '2.设计'}","page_content='HTAP

1.简介

TuGraph 的设计中，简单的 OLAP 操作和 OLTP 操作共用一份数据，而复杂的 OLAP 操作则单独导出快照处理。' metadata={'Header 1': 'HTAP', 'Header 2': '1.简介'}","page_content='OlapBase API

7. 图类OlapBase

7.4 批处理操作

TuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程。分别是：  
```c++
/*' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.4 批处理操作'}"
如何在代码中为TuGraph-DB增加日志输出埋点？,"page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
**方式二**  
```shell' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='业务开发指南

导出数据

本地导出整个图的所有数据

```
JSON 格式
```
lgraph_export -d your_db_path -e export_data -g default -f json -u admin -p 73@TuGraph
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导出数据', 'Header 3': '本地导出整个图的所有数据'}"
在删除TuGraph中边的全文索引时，如果边的标签或字段不存在，会抛出什么异常？,"page_content='Cypher API

4.附录1. 语法扩充及不同

- TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label' metadata={'Header 1': 'Cypher API', 'Header 2': '4.附录1. 语法扩充及不同'}","page_content='Cypher API

3.Functions

3.6.Mathematical functions

- TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label' metadata={'Header 1': 'Cypher API', 'Header 2': '3.Functions', 'Header 3': '3.6.Mathematical functions'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}"
Grafana主要用于什么？,"page_content='运维监控

1.设计思路

1.4.Grafana

Grafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网:' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路', 'Header 3': '1.4.Grafana'}","page_content='运维监控

1.设计思路

Monitor获取封装好的请求数据，按照获取的时间保存在自己的时序数据库中。Grafana可以根据用户的配置，从Prometheus处获取某个时间段内的统计数据，并在web界面上绘制浅显易懂的图形来展示最终结果。整个请求链路中，都采用了主动获取，即PUL' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路'}","page_content='功能概览

6.生态工具

6.3.运维监控

TuGraph 使用 Prometheus 加 Grafana 的监控框架，采用松耦合的方式。Prometheus 从 TuGraph 的监控接口获取监控信息，存储在本地时序数据库中，然后通过 Grafana 在网页端交互展示。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.3.运维监控'}"
DeleteProcedure 函数是用来执行什么操作的？,"page_content='Python客户端

3.RPC Client

| bool DeleteProcedure(std::string& result, const std::string& procedure_type, const std::string& procedure_name,' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='Java客户端

2.使用示例

2.10.删除存储过程

public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Python客户端

3.RPC Client

| deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}"
PairUniqueIndex 的钥匙生成形式是什么？,"page_content='数据导入

3.配置文件

3.1.配置文件格式

pair_unique索引是指两点间唯一的索引，这种类型的索引只能创建于边的schema中，这种索引在用户指定的key后面加上了源点和目标点的vid，每个vid是5bytes长度。因此最大key的长度是470bytes，超过无法建立索引。' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

pair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，
相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。  
###### 1.3.1.2.2 pair_unique索引' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}"
类FieldData用于表示哪些类型的数据？,"page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的表示

空间数据类型可以用不同的坐标系来表示，EPSG<sup>[1]</sup>是一个标准化的地理空间参考系统标识符集合， 用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。通常使用EPSG编码表示数据的坐标系。行业内一般采用' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的表示'}","page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的表示

位置。这包括各种类型的地图创建、空间数据分析和管理等。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的表示'}","page_content='Traversal API

2. 接口说明

2.1. Snapshot

C++ OLAP API 中的 Snapshot 模版类用于表示抽取出来的静态子图，其中 EdgeData 用来表示该子图上每条边所用权值的数据类型（如果边不需要权值，使用 Empty 作为 EdgeData 即可）。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.1. Snapshot'}"
在线全量导入TuGraph时，如果发生数据包错误，默认行为是什么？,"page_content='数据导入

6.在线全量导入

在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：
1. 和离线导入类型相同的原数据文件（csv等）' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入'}","page_content='数据导入

6.在线全量导入

这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入'}","page_content='数据导入

6.在线全量导入

只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，
而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入'}"
ORDER BY在GQL中有什么作用？,"page_content='ISO GQL

2.Clauses

2.6.ORDER BY

`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。  
#### 对结果排序  
```
MATCH (n:Person WHERE n.birthyear < 1970)
RETURN n.birthyear AS q' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.6.ORDER BY'}","page_content='ISO GQL

2.Clauses

2.6.ORDER BY

ORDER BY q ASC
LIMIT 5
```  
返回结果
```JSON
[{""q"":1873},{""q"":1908},{""q"":1910},{""q"":1930},{""q"":1932}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.6.ORDER BY'}","page_content='Example

Order By

```sql
SELECT * from user order by age;' metadata={'Header 1': 'Example', 'Header 2': 'Order By'}"
TuGraph-DB是否提供HTTP接口？如果有，对应的接口代码可以在哪里找到？,"page_content='RESTful API

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。' metadata={'Header 1': 'RESTful API', 'Header 2': '1.简介'}","page_content='RESTful API Legacy

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '1.简介'}","page_content='RESTful API Legacy

3.登录

TuGraph 提供基于 JWT 的用户认证方式，可以使用 HTTP 或 HTTPS 协议进行传输。系统默认使用 HTTP 协议，如果需要使用 HTTPS，需要在 lgraph.json 配置文件中将 ssl_auth 设为 1。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录'}"
请问lgraph_peer工具是否只能通过编译方式进行部署？,"page_content='Python Olap API

5. lgraph_db API

import *`的方式导入，由Cython编译py文件后才能运行。' metadata={'Header 1': 'Python Olap API', 'Header 2': '5. lgraph_db API'}","page_content='Procedure API

5.Procedure v2接口

5.1.编写存储过程

用户可以通过使用 lgraph API 来编写 C++ 存储过程。一个简单的 C++ 存储过程举例如下：  
```c++
// peek_some_node_salt.cpp
#include <cstdlib>' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.1.编写存储过程'}","page_content='部署高可用模式

3.启动初始备份组

安装好TuGraph之后，可以使用`lgraph_server`命令在不同的机器上启动高可用集群。本节主要讲解高可用集群的启动方式，启动之后的集群状态管理参见[lgraph_peer工具](../6.utility-tools/5.ha-cluster-m' metadata={'Header 1': '部署高可用模式', 'Header 2': '3.启动初始备份组'}"
当前图数据库应用程序的CPU使用率是多少？,"page_content='运维监控

2.部署方案

2.4.第四步

""handler"": 1,
""message"": ""【生产图数据库Grafana】\nCPU使用率超过90%"",
""name"": ""CPU使用率 alert"",
""noDataState"": ""no_data"",
""notifications"": [
{' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='性能优先

1.简介

TuGraph目前是世界上最快的图数据库，在图数据库标准评测LDBC SNB Interactive位居榜首（2023.3）。TuGraph的设计基于性能优先，致力于打造高性能的单机图数据库。该文档是TuGraph基于性能优先在存储层的核心设计。' metadata={'Header 1': '性能优先', 'Header 2': '1.简介'}","page_content='功能概览

6.生态工具

6.3.运维监控

提供的监控的状态包括图数据库的状态和服务器的状态，前者包括读写负载、点边数量等数据库端的状态，后者包括内存、CPU、硬盘等服务器的实时状态。如果某些监控状态超过了预期的阈值，就需要主动告警，通常需要对接其他运维管控系统，比如群消息、邮件告警等。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.3.运维监控'}"
