Q,K1,K2,K3
RPC 及 HA 服务中，verbose 参数的设置有几个级别？,"page_content='RPC API

2.请求

2.2.请求类型

TuGraph支持10种RPC请求，其中每种请求的功能如下表所示：  
| 请求              | 功能         |
|-----------------|------------|
| GraphApiRequest | 点边索引操作请求   |
| CypherRequest   | cypher请求   |
| PluginRequest   | 存储过程请求     |
| HARequest       | 高可用模式请求    |
| ImportRequest   | 数据导入请求     |
| GraphRequest    | 子图操作请求     |
| AclRequest      | 权限管理请求     |
| ConfigRequest   | 配置管理请求     |
| RestoreRequest  | 备份请求       |
| SchemaRequest   | schema管理请求 |  
用户发送请求时，需要传入以下参数：
- client_version: 可选参数，HA模式下可通过对比`client_version`和`server_version`防止响应过时的请求
- token: 必要参数，客户端登陆之后获得token，每次请求传入token以校验用户身份
- is_write_op: 可选参数，标志请求是否是写请求
- user: 可选参数，HA模式下主从之间同步请求时设置user，不需验证token  
服务处理完RPC请求之后发回响应，响应消息中除了包含每个请求的单独响应信息之外，还包含以下参数：
- error_code: 必要参数，标志请求处理状态
- redirect: 可选参数，HA模式下向follower发送写请求时处理失败，设置redirect为请求转发地址，即leader地址
- error: 可选参数，请求错误信息
- server_version: 可选参数，HA模式的请求响应中设置`server_version`以避免client读取数据时发生反向时间旅行问题  
:warning:  **除CypherRequest、PluginRequest、HARequest和AclRequest外，其余RPC接口将逐步废弃，其功能统一至CypherRequest接口。**' metadata={'Header 1': 'RPC API', 'Header 2': '2.请求', 'Header 3': '2.2.请求类型'}","page_content='RPC API

5.存储过程

5.2.调用存储过程

调用存储过程的请求包含以下参数：
- name: 必要参数，存储过程名称
- param: 必要参数，存储过程参数
- result_in_json_format: 可选参数，调用结果是否以JSON格式返回
- in_process: 可选参数，未来支持
- timeout: 可选参数，调用存储过程的超时时间  
以C++为例，用户调用存储过程的方式如下所示：
```C++
LGraphRequest req;
lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();
pluginRequest->set_graph(graph);
pluginRequest->set_type(procedure_type == ""CPP"" ? lgraph::PluginRequest::CPP
: lgraph::PluginRequest::PYTHON);
lgraph::CallPluginRequest *cpRequest = pluginRequest->mutable_call_plugin_request();
cpRequest->set_name(procedure_name);
cpRequest->set_in_process(in_process);
cpRequest->set_param(param);
cpRequest->set_timeout(procedure_time_out);
cpRequest->set_result_in_json_format(json_format);
LGraphResponse res;
cntl->Reset();
cntl->request_attachment().append(FLAGS_attachment);
req.set_client_version(server_version);
req.set_token(token);
LGraphRPCService_Stub stub(channel.get());
stub.HandleRequest(cntl.get(), &req, &res, nullptr);
if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
server_version = std::max(server_version, res.server_version());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
if (json_format) {
result = res.mutable_plugin_response()->mutable_call_plugin_response()->json_result();
} else {
result = res.mutable_plugin_response()->mutable_call_plugin_response()->reply();
}
```
调用存储过程的响应为以下两个参数之一：
- reply: ByteString格式的存储过程调用结果
- json_result: JSON格式的存储过程调用结果' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.2.调用存储过程'}","page_content='Procedure API

2.存储过程的版本支持

目前TuGraph支持两个版本的存储过程，适用于不同的场景，v3.5版本只支持v1，可通过REST或RPC接口直接调用；从v3.5版本开始支持v2，能够在图查询语言（比如Cypher）中嵌入调用，我们称之为POG（Procedure On Graph query language，APOC）。  
|                        | Procedure v1                       | Procedure v2               |
| ---------------------- | ---------------------------------- | -------------------------- |
| 适用场景                 | 极致性能，或者复杂的多事务管理情形       | 一般情况，与Cypher高度联动 |
| 事务                    | 函数内部创建，可自由控制多事务          | 外部传入函数，单一事务     |
| 签名（参数定义）          | 无                                 | 有                    |
| 输入输出参数类型          | 不需要指定                           | 需要指定参数类型        |
| Cypher Standalone Call | 支持                                | 支持                  |
| Cypher Embeded Call    | 不支持                              | 支持                  |
| 语言                    | C++/Python/Rust                    | C++                  |
| 调用模式                 | 直接传字符串，一般为JSON               | 通过Cypher语句中的变量  |  
在TuGraph中，存储过程v1和v2单独管理，支持增删查，但仍不建议重名。' metadata={'Header 1': 'Procedure API', 'Header 2': '2.存储过程的版本支持'}"
在磁盘IO监控的配置中，当哪个值大于10000时会触发危急颜色模式？,"page_content='运维监控

2.部署方案

2.4.第四步

+ 下载符合您机器架构以及系统版本的Grafana安装包，下载地址: [https://grafana.com/grafana/download](https://grafana.com/grafana/download)  
+ 安装Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)  
+ 启动Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)  
+ 配置Grafana，首先在数据源设置中配置Prometheus的IP地址，配置完成后可以通过测试连接功能，验证是否成功连接数据源。然后，导入如下模版，并在页面中根据实际情况，修改正确的接口IP和端口。最后可以根据实际情况设置刷新时间和监控时间范围  
```json
{
""annotations"": {
""list"": [
{
""builtIn"": 1,
""datasource"": {
""type"": ""grafana""
},
""enable"": true,
""hide"": true,
""iconColor"": ""rgba(0, 211, 255, 1)"",
""name"": ""Annotations & Alerts"",
""target"": {
""limit"": 100,
""matchAny"": false,
""tags"": [],
""type"": ""dashboard""
},
""type"": ""dashboard""
}
]
},
""editable"": true,
""fiscalYearStartMonth"": 0,
""graphTooltip"": 0,
""id"": 2,
""links"": [],
""liveNow"": false,
""panels"": [
{
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
}
},
""mappings"": [],
""unit"": ""kbytes""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""D {instance=\""localhost:7010\"", job=\""TuGraph\"", resouces_type=\""memory\"", type=\""available\""}""
},
""properties"": [
{
""id"": ""displayName"",
""value"": ""others""
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""D {__name__=\""resources_report\"", instance=\""localhost:7010\"", job=\""TuGraph\"", resouces_type=\""memory\"", type=\""available\""}""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-green"",
""mode"": ""fixed""
}
},
{
""id"": ""displayName"",
""value"": ""others""
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""others""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-blue"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""graph_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-orange"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 16,
""w"": 6,
""x"": 0,
""y"": 0
},
""id"": 14,
""options"": {
""displayLabels"": [
""name"",
""value""
],
""legend"": {
""displayMode"": ""table"",
""placement"": ""bottom"",
""values"": [
""percent"",
""value""
]
},
""pieType"": ""pie"",
""reduceOptions"": {
""calcs"": [
""lastNotNull""
],
""fields"": """",
""values"": false
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""memory\"",type=\""self\""}"",
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""memory\"",type=\""available\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""B""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""memory\"",type=\""total\""}"",
""hide"": true,
""legendFormat"": ""{ {label_name} }"",
""range"": true,
""refId"": ""C""
},
{
""datasource"": {
""type"": ""__expr__""
},
""expression"": ""$C -$A - $B"",
""hide"": false,
""refId"": ""D"",
""type"": ""math""
}
],
""title"": ""内存"",
""type"": ""piechart""
},
{
""alert"": {
""alertRuleTags"": {},
""conditions"": [
{
""evaluator"": {
""params"": [
1000
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\n  QPS超过1000"",
""name"": ""请求统计 alert"",
""noDataState"": ""no_data"",
""notifications"": []
},
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""axisLabel"": """",
""axisPlacement"": ""auto"",
""barAlignment"": 0,
""drawStyle"": ""line"",
""fillOpacity"": 7,
""gradientMode"": ""none"",
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
},
""lineInterpolation"": ""smooth"",
""lineWidth"": 1,
""pointSize"": 5,
""scaleDistribution"": {
""type"": ""linear""
},
""showPoints"": ""auto"",
""spanNulls"": false,
""stacking"": {
""group"": ""A"",
""mode"": ""none""
},
""thresholdsStyle"": {
""mode"": ""off""
}
},
""mappings"": [],
""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},
""unit"": "" ""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""write""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-blue"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 16,
""w"": 12,
""x"": 6,
""y"": 0
},
""id"": 4,
""options"": {
""legend"": {
""calcs"": [
""min"",
""max"",
""mean"",
""last""
],
""displayMode"": ""table"",
""placement"": ""bottom""
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""request\"",type=~\""total|write\""}"",
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 1000,
""visible"": true
}
],
""title"": ""请求统计"",
""type"": ""timeseries""
},
{
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
}
},
""mappings"": [],
""unit"": ""decbits""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""graph_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-red"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""available""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-orange"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""D""
},
""properties"": [
{
""id"": ""displayName"",
""value"": ""other""
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""other""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-purple"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 16,
""w"": 6,
""x"": 18,
""y"": 0
},
""id"": 12,
""options"": {
""displayLabels"": [
""name"",
""value""
],
""legend"": {
""displayMode"": ""table"",
""placement"": ""bottom"",
""sortBy"": ""Value"",
""sortDesc"": true,
""values"": [
""value"",
""percent""
]
},
""pieType"": ""pie"",
""reduceOptions"": {
""calcs"": [
""lastNotNull""
],
""fields"": """",
""values"": false
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""exemplar"": false,
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk\"",type=\""available\""}"",
""format"": ""time_series"",
""instant"": false,
""interval"": """",
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk\"",type=\""self\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""B""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk\"",type=\""total\""}"",
""hide"": true,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""C""
},
{
""datasource"": {
""type"": ""__expr__""
},
""expression"": ""$C - $A - $B"",
""hide"": false,
""refId"": ""D"",
""type"": ""math""
}
],
""title"": ""磁盘"",
""transformations"": [
{
""id"": ""configFromData"",
""options"": {
""applyTo"": {
""id"": ""byFrameRefID""
},
""configRefId"": ""config"",
""mappings"": []
}
}
],
""type"": ""piechart""
},
{
""alert"": {
""alertRuleTags"": {},
""conditions"": [
{
""evaluator"": {
""params"": [
90
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\nCPU使用率超过90%"",
""name"": ""CPU使用率 alert"",
""noDataState"": ""no_data"",
""notifications"": [
{
}
]
},
""datasource"": {
""type"": ""prometheus""
},
""description"": """",
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""axisLabel"": """",
""axisPlacement"": ""auto"",
""barAlignment"": 0,
""drawStyle"": ""line"",
""fillOpacity"": 4,
""gradientMode"": ""none"",
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
},
""lineInterpolation"": ""linear"",
""lineWidth"": 1,
""pointSize"": 5,
""scaleDistribution"": {
""type"": ""linear""
},
""showPoints"": ""auto"",
""spanNulls"": false,
""stacking"": {
""group"": ""A"",
""mode"": ""none""
},
""thresholdsStyle"": {
""mode"": ""off""
}
},
""mappings"": [],
""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},
""unit"": ""percent""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""graph_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-orange"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""total_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-purple"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""self""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-green"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""total""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-purple"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 14,
""w"": 12,
""x"": 0,
""y"": 16
},
""id"": 6,
""options"": {
""legend"": {
""calcs"": [
""min"",
""max"",
""mean"",
""last""
],
""displayMode"": ""table"",
""placement"": ""bottom""
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""cpu\"",type=~\""total|self\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 90,
""visible"": true
}
],
""title"": ""CPU使用率"",
""type"": ""timeseries""
},
{
""alert"": {
""alertRuleTags"": {},
""conditions"": [
{
""evaluator"": {
""params"": [
10000
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\n  磁盘IO超过10MB/S"",
""name"": ""磁盘IO alert"",
""noDataState"": ""no_data"",
""notifications"": []
},
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""axisLabel"": """",
""axisPlacement"": ""auto"",
""barAlignment"": 0,
""drawStyle"": ""line"",
""fillOpacity"": 7,
""gradientMode"": ""none"",
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
},
""lineInterpolation"": ""smooth"",
""lineWidth"": 1,
""pointSize"": 5,
""scaleDistribution"": {
""type"": ""linear""
},
""showPoints"": ""auto"",
""spanNulls"": false,
""stacking"": {
""group"": ""A"",
""mode"": ""none""
},
""thresholdsStyle"": {
""mode"": ""off""
}
},
""mappings"": [],
""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},
""unit"": ""bps""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""read""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""super-light-green"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""write""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""super-light-red"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 14,
""w"": 12,
""x"": 12,
""y"": 16
},
""id"": 2,
""options"": {
""legend"": {
""calcs"": [
""min"",
""max"",
""mean"",
""last""
],
""displayMode"": ""table"",
""placement"": ""bottom""
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""builder"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk_rate\"",type=~\""read|write\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 10000,
""visible"": true
}
],
""title"": ""磁盘IO"",
""type"": ""timeseries""
}
],
""refresh"": """",
""schemaVersion"": 36,
""style"": ""dark"",
""tags"": [],
""templating"": {
""list"": []
},
""time"": {
""from"": ""now-24h"",
""to"": ""now""
},
""timepicker"": {
""hidden"": false,
""refresh_intervals"": [
""10s""
]
},
""timezone"": """",
""title"": ""TuGraph监控页面"",
""version"": 20,
""weekStart"": """"
}
```  
验证效果，刷新浏览器页面。如果正确显示饼图和折线图，则配置完成。' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='数据库运行

4.服务配置

4.1.配置参数

具体参数及其类型描述如下：  
| **参数名**                      | **<nobr>参数类型</nobr>** | **参数说明**                                                                                                                                                                          |
|------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| directory                    | 字符串                   | 数据文件所在目录。如果目录不存在 ，则自动创建。默认目录为 /var/lib/lgraph/data。                                                                                                                               |
| durable                      | 布尔值                   | 是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但是在机器断电等极端情况下可能丢失数据。默认值为 `true`。                                                                                                                  |
| host                         | 字符串                   | REST 服务器监听时使用的地址，一般为服务器的 IP 地址。默认地址为 0.0.0.0。注：在HA模式下，host需要设置为对应服务器的IP地址，不能设置为0.0.0.0。                                                                                           |
| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |
| enable_rpc                   | 布尔值                   | 是否使用 RPC 服务。默认值为 false。                                                                                                                                                           |
| rpc_port                     | 整型                    | RPC 及 HA 服务所用端口。默认端口为 9090。                                                                                                                                                       |
| bolt_port                    | 整型                    | Bolt 客户端端口。默认端口为 7687。                                                                                                                                                            |
| enable_ha                    | 布尔值                   | 是否启动高可用模式。默认值为 false。                                                                                                                                                             |
| ha_log_dir                   | 字符串                   | HA 日志所在目录，需要启动 HA 模式。默认值为空。                                                                                                                                                       |
| verbose                      | 整型                    | 日志输出信息的详细程度。可设为 0，1，2，值越大则输出信息越详细。默认值为 1。                                                                                                                                         |
| log_dir                      | 字符串                   | 日志文件所在的目录。默认目录为 /var/log/lgraph/。                                                                                                                                                 |
| ssl_auth                     | 布尔值                   | 是否使用 SSL 安全认证。当开启时，REST 服务器只开启 HTTPS 服务。默认值为 false。                                                                                                                               |
| web                          | 字符串                   | Web 文件（包括可视化组件）的存储位置，默认设置在 /usr/local/share/lgraph/browser-resource 目录下。而对于之前的老版本，该目录则位于 /usr/local/share/lgraph/resource 。                                                       |
| server_cert                  | 字符串                   | 在 SSL 认证开启时，服务器所使用的 certificate 文件路径。默认路径为 /usr/local/etc/lgraph/server-cert.pem。                                                                                                 |
| server_key                   | 字符串                   | 在 SSL 认证开启时，服务器所使用的公钥文件。默认目录为 /usr/local/etc/lgraph/server-key.pem。                                                                                                               |
| enable_audit_log             | 布尔值                   | 是否启用审计日志，默认值为 false。                                                                                                                                                              |
| audit_log_expire             | 整型                    | 启用审计日志时，日志的有效时间（小时），超时自动清理，值为 0 时表示不清理。默认值为 0。                                                                                                                                    |
| audit_log_dir                | 字符串                   | 启用审计日志时，日志文件的存放目录。默认目录为 $directory/_audit_log_。                                                                                                                                   |
| load_plugins                 | 布尔值                   | 启动服务时导入所有存储过程。默认值为 true。                                                                                                                                                          |
| optimistic_txn               | 布尔值                   | 为 Cypher 开启乐观多线程写入事务。默认为 false。                                                                                                                                                   |
| disable_auth                 | 布尔值                   | 关闭 REST 验证。默认为 false。                                                                                                                                                             |
| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |
| ha_heartbeat_interval_ms     | 整型                    | 心跳间隔（以毫秒为单位）。 默认值为 1000。                                                                                                                                                          |
| ha_node_offline_ms           | 整型                    | 心跳超时且节点下线间隔（以毫秒为单位）。默认为 60000。                                                                                                                                                    |
| ha_node_remove_ms            | 整型                    | 节点被视为完全死亡并从列表中删除的间隔（以毫秒为单位）。默认值为 120000。                                                                                                                                          |
| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为""HH:MM:SS""，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为""""，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |
| enable_ip_check              | 布尔值                   | 允许 IP 白名单，默认值为 false。                                                                                                                                                             |
| idle_seconds                 | 整型                    | 子进程可以处于空闲状态的最大秒数。 默认值为 600。                                                                                                                                                       |
| enable_backup_log            | 布尔值                   | 是否启用备份日志记录。 默认值为 false。                                                                                                                                                           |
| backup_log_dir               | 字符串                   | 存储备份文件的目录。 默认值为空。                                                                                                                                                                 |
| snapshot_dir                 | 字符串                   | 存储快照文件的目录。 默认值为空。                                                                                                                                                                 |
| thread_limit                 | 整型                    | 同时使用的最大线程数。 默认值为 0，即不做限制，以 license 为准。                                                                                                                                            |
| unlimited_token              | 布尔值                   | 是否将链接token设置为无期限。 默认值为 false，有效期为24小时。                                                                                                                                            |
| reset_admin_password         | 布尔值                   | 是否重置管理者密码。 默认值为 false。 为 true 时，密码重置为`73@TuGraph`。                                                                                                                                |
| enable_fulltext_index        | 布尔值                   | 是否启用全文索引功能，默认值为 false。                                                                                                                                                            |
| fulltext_analyzer            | 字符串                   | 全文索引分词器类型。可设为`StandardAnalyzer`或者`SmartChineseAnalyzer`。默认是`StandardAnalyzer`                                                                                                     |
| fulltext_commit_interval     | 整形                    | 全文索引数据提交周期,针对写操作，单位秒。默认是 0，立即提交。                                                                                                                                                  |
| fulltext_refresh_interval    | 整形                    | 全文索引数据刷新周期，针对读操作，单位秒。默认是 0，立即可以读到最新写入的数据。                                                                                                                                         |
| ha_conf                      | 字符串                   | 根据 host1:port1,host2:port2,host3:port3 初始化HA集群，默认值为空。                                                                                                                             |
| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |
| ha_bootstrap_role            | 整形                    | 是否使用bootstrap方式启动，以及使用该方式启动的服务器角色，0代表不使用bootstrap方式启动，1代表使用bootstrap方式启动且本节点为leader，2代表使用bootstrap方式启动且本节点为follower，只有这3种选项。 默认值为 0。                                              |
| help                         | 布尔值                   | 打印此帮助消息。 默认值为 false。                                                                                                                                                              |
| browser.credential_timeout                         | 整形                    | 浏览器缓存的用户名和密码过期时间。                                                                                                                                                                 |
| browser.retain_connection_credentials                         | 布尔值                   | 浏览器是否缓存用户名和密码。                                                                                                                                                              |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='RESTful API Legacy

6.Deprecated

6.3.服务器状态

#### 6.3.1.修改服务器配置  
修改服务器配置，配置修改后立即生效，并将影响所有服务器。这些配置的优先级高于配置文件以及命令行参数。  
- **URI**: `/config`
- **METHOD**: PUT
- **REQUEST**:  
请求为一个字典，使用 `{""opt1"":v1}` 可以将名为`opt1`的配置修改为`v1`。  
| 配置名               | 说明                   | 值类型 |
| -------------------- | ---------------------- | ------ |
| OPT_DB_ASYNC         | 是否启用异步模式       | 布尔值 |
| OPT_TXN_OPTIMISTIC   | 是否默认使用乐观事务锁 | 布尔值 |
| OPT_AUDIT_LOG_ENABLE | 是否启用审计日志       | 布尔值 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• PUT http://localhost:7070/config
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""OPT_DB_ASYNC"": true,
""OPT_AUDIT_LOG_ENABLE"": false
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.3.2.当前服务器状态  
- **URI**: `/info`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| lgraph_version | 服务器版本号 | 字符串 |
| git_branch | 服务器代码分支 | 字符串 |
| git_commit | 服务器代码版本 | 字符串 |
| web_commit | 前端码版本 | 字符串 |
| cpp_id | CPP 编译器 ID | 字符串 |
| cpp_version | CPP 编译器版本 | 字符串 |
| python_version | PYTHON 版本 | 字符串 |
| node | 点 uri | 字符串 |
| relationship | 边 uri | 字符串 |
| cpu | cpu 信息 | 字典，格式参见[服务器 CPU 状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E7%8A%B6%E6%80%81) |
| disk | 硬盘 IO 信息 | 字典，格式参见[服务器硬盘状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E7%9B%98%E7%8A%B6%E6%80%81) |
| memory | 内存信息 | 字典，格式参见[服务器内存状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81) |
| db_space | 图数据库占用空间 | 字典，格式参见[图数据库占用空间](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4) |
| db_config | 图数据库配置信息 | 字典，格式参见[图数据库配置信息](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF) |
| up_time | 数据库在线时长（秒） | 整型 |  
**Example request.**  
```
• GET http://localhost:7070/info
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""lgraph_version"": ""1.2.0"",
""git_branch"": ""master"",
""git_commit"": ""9e2977d"",
""web_commit"": ""1e2823d"",
""cpu_id"": ""GUN"",
""cpu_version"": ""4.8.5"",
""python_version"": ""3.2"",
""node"": ""/node"",
""relationship"": ""/relationship"",
""cpu"": {
""self"": 25,
""server"": 35,
""unit"": ""%""
},
""disk"": {
""read"": 2000,
""write"": 2000,
""unit"": ""B/s""
},
""memory"": {
""self"": 25016,
""server_avail"": 46865636,
""server_total"": 65860552,
""unit"": ""KB""
},
""db_space"": {
""space"": 57344,
""unit"": ""B""
},
""db_config"": {
""db_async"": false,
""disable_auth"": false,
""enable_ha"": false,
...
},
""up_time"": 3235
}
```  
#### 6.3.3.服务器 CPU 状态  
- **URI**: `/info/cpu`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| self | 图数据库应用程序 CPU 使用率 | 整型 |
| server | 服务器 CPU 使用率 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/cpu
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""self"": 25,
""server"": 35,
""unit"": ""%""
}
```  
#### 6.3.4.服务器硬盘状态  
- **URI**: `/info/disk`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| read | 服务器硬盘读速率 | 整型 |
| write | 服务器硬盘写速率 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/disk
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""read"": 2000,
""write"": 2000,
""unit"": ""B/s""
}
```  
#### 6.3.5.服务器内存状态  
- **URI**: `/info/memory`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| self | 图数据库应用程序内存使用量 | 整型 |
| server_avail | 服务器可用内存 | 整型 |
| server_total | 服务器总内存 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/memory
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""self"": 25016,
""server_avail"": 46865636,
""server_total"": 65860552,
""unit"": ""KB""
}
```  
#### 6.3.6.图数据库占用空间  
- **URI**: `/info/db_space`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| space | 图数据库占用空间 | 整型 |
| disk_avail | 图数据库可用空间 | 整型 |
| disk_total | 服务器硬盘总空间 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/db_space
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""disk_avail""::360074579968,
""disk_total""::984373800960,
""space"": 57344,
""unit"": ""B""
}
```  
#### 6.3.7.图数据库配置信息  
- **URI**: `/info/db_config`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| db_async | 图数据库工作模式（同步或异步） | 布尔值 |
| disable_auth | 是否禁用身份验证 | 布尔值 |
| enable_ha | 是否启用高可用模式 | 布尔值 |
| enable_rpc | 是否启用 RPC 服务器 | 布尔值 |
| bind_host | REST 服务器的主机 | 字符串 |
| enable_audit_log | 是否启用日志审计 | 布尔值 |
| port | REST 服务器的端口 | 整型 |
| rpc_port | RPC 服务器的端口 | 整型 |
| optimistic_txn | 是否默认使用乐观事务锁 | 布尔值 |
| thread_limit | 图数据库应用程序的可用线程数 | 整型 |
| enable_ssl | 是否使用 SSL 进行身份验证 | 布尔值 |
| verbose | 输出的详细程度 | 整型 |  
**Example request.**  
```
• GET http://localhost:7070/info/db_config
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""db_async"":false,
""disable_auth"":false,
""enable_ha"":false,
""enable_rpc"":false,
""bind_host"":""127.0.0.1"",
""enable_audit_log"":false,
""port"":7070,
""optimistic_txn"":false,
""rpc_port"":9091,
""thread_limit"":0,
""enable_ssl"":false,
""verbose"":2
}
```  
#### 6.3.8.高可用服务器列表  
_(仅在高可用模式下有效)_  
- **URI**: `/info/peers`
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回一个服务器信息列表，其中每个服务器信息格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| rpc_address | 服务器 RPC 地址 | 字符串 |
| rest_address | 服务器 REST 地址 | 字符串 |
| state | 服务器状态 | 字符串 |  
其中服务器状态可为 `MASTER`,`SLAVE`,`OFFLINE`。  
**Example request.**  
```
• GET http://localhost:7070/info/peers
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
[
{
""rest_address"":""192.168.1.22:17071"",
""rpc_address"":""192.168.1.22:19091"",
""state"":""MASTER""
},
{
""rest_address"":""192.168.1.22:17072"",
""rpc_address"":""192.168.1.22:19092"",
""state"":""SLAVE""
}
]
}
```  
#### 6.3.9.当前 Leader 信息  
_(仅在高可用模式下有效)_  
- **URI**: `/info/leader`
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前 leader 服务器信息，格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| rpc_address | 服务器 RPC 地址 | 字符串 |
| rest_address | 服务器 REST 地址 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/leader
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""rest_address"":""192.168.1.22:17071"",
""rpc_address"":""192.168.1.22:19091""
}
```  
#### 6.3.10.服务器统计信息  
- **URI**: `/info/statistics`
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前服务器统计信息，格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| requests/second | 每秒处理的请求数量 | 浮点型 |
| writes/second | 每秒处理的写请求数量 | 浮点型 |
| running_tasks | 正在执行的请求数量 | 整型 |
| failure_rate | 请求失败率 | 浮点型 |  
**Example request.**  
```
• GET http://localhost:7070/info/statistics
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""failure_rate"": 2.3,
""requests/second"": 122.3,
""running_tasks"": 10,
""writes/second"": 12.4
}
```  
#### 6.3.11.审计日志信息  
- **URI**: `/info/log/?begin_time={begin_time}&end_time={end_time}&user={user}&num_log={num_log}&descending_order={descending_order}`
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| begin_time | 查询日志的起始时间(必填，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |
| end_time | 查询日志的结束时间(默认为当前时间，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |
| user | 查询日志的操作者(管理员可查询所有用户的日志，普通用户只能查询本人日志) | 字符串 |
| num_log | 查询日志的数量(默认为 100) | 整型 |
| descending_order | 查询结果是否降序输出(默认为 true) | 布尔值 |  
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回审计日志列表，其中每个元素是一条操作日志，其格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| index | 该操作的索引值 | 整型 |
| begin_time | 该操作的开始时间 | 字符串 |
| end_time | 该操作的结束时间 | 字符串 |
| user | 该操作的发起者 | 字符串 |
| graph | 该操作的图 | 字符串 |
| type | 该操作的类型 | 字符串 |
| read_write | 该操作为读操作或者写操作 | 字符串 |
| success | 该操作是否成功 | 布尔值 |
| content | 该操作的简要内容 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/log/?begin_time=2020-02-17%2015:00:00&end_time=2020-02-20%2012:00:00&user=admin&num_log=100&descending_order=false
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
[
{
""begin_time"": ""2020-02-17 15:27:15"",
""content"": ""post /login    Successful"",
""end_time"": ""2020-02-17 15:27:15"",
""graph"": """",
""index"": 1,
""read_write"": ""read"",
""success"": true,
""type"": ""Security"",
""user"":""admin""
},
{
""begin_time"": ""2020-02-17 15:27:15"",
""content"": ""Load plugin : `echo`    Successful"",
""end_time"": ""2020-02-17 15:27:15"",
""graph"": ""default"",
""index"": 2,
""read_write"": ""write"",
""success"": true,
""type"": ""Plugin"",
""user"": ""admin""
},
...
]
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.3.服务器状态'}"
`FieldData` 类中的函数 `IsReal()` 是用来查询什么类型的数据？,"page_content='Geaflow支持以下逻辑运算：  
操作|描述
----------------------|------
boolean1 OR boolean2 | 如果boolean1为true或boolean2为true，则返回true。
boolean1 AND boolean2 | 仅在boolean1为true和boolean2为true时才返回true。
NOT boolean | 返回给定布尔变量的NOT操作的结果。
boolean IS FALSE | 如果布尔变量为false，则返回true。如果布尔变量是UNKNOWN，则返回false。
boolean IS NOT FALSE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回true。
boolean IS TRUE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回false。
boolean IS NOT TRUE | 如果布尔变量为false，则返回true。如果布尔变量是UNKNOWN，则返回true。
value1 = value2 | 如果value1等于value2，则返回true。
value1 <> value2 | 如果value1不等于value2，则返回true。
value1 > value2 | 如果value1大于value2，则返回true。
value1 >= value2 | 如果value1大于或等于value2，则返回true。
value1 < value2 | 如果value1小于value2，则返回true。
value1 <= value2 | 如果value1小于或等于value2，则返回true。
value IS NULL | 如果value为null，则返回true。
value IS NOT NULL | 如果value不为null，则返回true。
value1 IS DISTINCT FROM value2 | 如果value1与value2不同，则返回true。如果value1和value2都为null，则它们被视为相等。
value1 IS NOT DISTINCT FROM value2 | 如果value1等于value2，则返回true。如果value1和value2都为null，则它们被视为相等。
value1 BETWEEN value2 AND value3 | 如果value1大于或等于value2且小于value3，则返回true。
value1 NOT BETWEEN value2 AND value3 | 如果value1小于value2或大于或等于value3，则返回true。
string1 LIKE string2 [ ESCAPE string3 ] | 对字符串string1进行模糊匹配，如果匹配到模式string2则返回true，如果不匹配则返回false。
string1 NOT LIKE string2 [ ESCAPE string3 ] | 对字符串string1进行模糊匹配，如果匹配到模式string2则返回false，如果不匹配则返回true。
value IN (value [, value]* ) | 如果value等于列表中的任何一个值，则返回true。
value NOT IN (value [, value]* ) | 如果value不等于列表中的任何一个值，则返回true。'","page_content='业务开发指南

实时查看当前点边数据量

如下例子返回所有的点边类型，以及每种类型当前的数据量是多少。  
读的是统计数据，轻操作。
```
CALL dbms.meta.countDetail()
```' metadata={'Header 1': '业务开发指南', 'Header 2': '实时查看当前点边数据量'}","page_content='地理空间数据类型使用示例

4. 函数介绍

| 函数名  | 描述 | 输入参数                         | 返回值类型 |
| --- | --- |------------------------------| --- |
| Distance() | 计算两个空间数据间的距离(要求坐标系相同) | Spatial data1, Spatial data2 | double |
| Disjoint()  |  判断两个空间数据是否相交（开发中） | Spatial data1, Spatial data2 | bool |
| WithinBBox() | 判断某个空间数据是否在给定的长方形区域内（开发中） | Spatial data, Point1         | bool |' metadata={'Header 1': '地理空间数据类型使用示例', 'Header 2': '4. 函数介绍'}"
如果成功修改一个用户的描述，应返回什么状态码？  ,"page_content='RESTful API Legacy

6.Deprecated

6.1.用户管理

系统默认创建一个管理员，管理员用户名为 _admin_，密码为 _73@TuGraph_。为了安全起见，请用户在第一次启动服务器后更改密码。  
#### 6.1.1.添加用户  
添加一个新的用户，并为其设置初始密码。只有管理员有权限进行此操作。其中用户名只能由字母，数字以及下划线构成，密码则可以包含任意字符。用户名和密码长度不能超过 64 字节。添加用户时还可以为用户增加一个描述，用户描述可以包含任意字符，最长不超过 512 字节。  
新用户默认拥有同名的角色，不具备任何图的权限。  
- **URI**: `/user`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| user | 用户名 | 字符串 |
| password | 密码 | 字符串 |
| description | 用户描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
{
""user"": ""USER1"",
""password"": ""AN_INITIAL_PASSWORD"",
""description"": ""This is a user""
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.2.列出所有用户  
列出数据库的所有用户。只有管理员拥有该操作权限。  
- **URI**: `/user/`
- **METHOD**: GET
- **RESPONSE**: 所有用户及其信息。  
**Example request.**  
```
• GET http://localhost:7070/user
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
Output:
{
""admin"": {
""disabled"": false,
""description"": ""Builtin admin user"",
""roles"": [""admin""]
},
""guest1"": {
""disabled"": true,
""description"": """",
""roles"": [""guest1"", ""some_other_role""]
}
}
```  
#### 6.1.3.获取用户信息  
列出给定用户的信息。  
- **URI**: `/user/{user_name}`
- **METHOD**: GET
- **RESPONSE**: 用户信息。  
**Example request.**  
```
• GET http://localhost:7070/user/guest1
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
Output:
{
""disabled"": true,
""description"": ""A guest user""
""roles"": [""guest1"", ""some_other_role""]
}
```  
#### 6.1.4.列出用户权限  
列出给定用户有权限访问的所有图及相应权限。  
- **URI**: `/user/{user_name}/graph`
- **METHOD**: GET
- **RESPONSE**: 用户信息。  
**Example request.**  
```
• GET http://localhost:7070/user/guest1/graph
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
Output:
{
""graph1"" : ""FULL"",
""graph2"" : ""READ""
}
```  
#### 6.1.5.更改用户密码  
用户可以更改自己的密码，更改密码时需要同时提供原密码。管理员可以更改所有用户的密码。管理员更改其它用户密码时，可以不提供当前密码。  
- **URI**: `/user/{user_name}/password`
- **METHOD**: PUT
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| current_password | 当前密码 | 字符串 |
| new_password | 新密码 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/user1/password
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
{
""current_password"": ""THE_CURRENT_PASSWORD""
""new_password"": ""A_NEW_PASSWORD""
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.6.修改用户描述  
用户可以修改自己的描述。管理员可以修改任意用户的描述。  
- **URI**: `/user/{user_name}/description`
- **METHOD**: PUT
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 用户描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/user1/description
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
{
""description"": ""New description for this user.""
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.7.删除用户  
删除用户及其所有相关权限，只有管理员拥有该操作权限。  
- **URI**: `/user/{user_name}`
- **METHOD**: DELETE
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• DELETE http://localhost:7070/user/guest1
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.8.禁用用户  
用户可以被禁用。被禁用的用户将不能登陆，但是其资料仍然保存。被禁用的用户可以被重新启用。  
- **URI**: `/user/{user_name}/disable`
- **METHOD**: POST
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/guest1/disable
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.9.启用用户  
启用一个被禁用的用户。  
- **URI**: `/user/{user_name}/enable`
- **METHOD**: POST
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/guest1/enable
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
```  
#### 6.1.10.设置用户角色  
为指定用户设置角色。只有管理员可以执行此操作。  
用户角色列表必须是“全量列表”，即该列表需要包含该用户需要的所有角色。唯一的例外是用户的同名角色，即使列表中不含该角色，它也会被加到用户角色中。  
- **URI**: `/user/{user_name}/role`
- **METHOD**: POST
- **REQUEST**: 角色列表
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/user/guest1
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
[""role1"", ""role2""]
```  
**Example response.**  
```
• 200: OK
```  
此时用户`guest1`拥有角色`guest1`, `role1`和`role2`。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.1.用户管理'}","page_content='TuGraph-Restful-Server

5.返回值

通用返回格式  
|  body参数  | 参数说明  |  参数类型  |  是否必填  |
|:--------:|:-----:|:------:| :-----: |
| errorCode |  状态码  |  字符串  |  是  |
| errorMessage | 错误信息  |  字符串  |  是  |
| data | 返回的数据 |  字符串  |  是  |  
TuGraph 返回的 HTTP 状态码包含以下四种：  
- 200 OK: 操作成功
- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误
- 401 Unauthorized: 未通过鉴权认证，例如用户名密码错误，token超过有效期等
- 500 Internal Server Error: 服务器端错误
当操作成功时，返回的 data 中包含操作的返回值。
当发生输入错误或者服务器错误时，返回的 errorMessage 中包含错误提示。' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '5.返回值'}","page_content='RESTful API Legacy

3.登录

3.2.身份刷新

Token失效后，前端发起刷新token接口，后端验证token合法性。初次登录后，1小时内有效，需刷新使用。即使刷新，24小时后也会强制退出，需要重新登陆。
验证通过，生成新的token；验证失败返回状态码401。  
- **URI**: `/refresh`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| Authorization | 令牌 | 字符串 |
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| jwt | 令牌 | 字符串 |  
**Example request.**  
```
• POST http://localhost:7070/refresh
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{
""Authorization"": ""Bearer eyJhbGciOiJIUz32NiIsInR5cCI6IkpXVDJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byj3fYVAH4D88dfTD_zYQ_uAvdizTMek""
}
```  
**Example response.**  
```
• 200: OK
Output:
{
""jwt"": ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek""
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.2.身份刷新'}"
边关联的两个点的字段，一定是点的主键吗？,"page_content='业务开发指南

导入数据

批量upsert边数据

如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。  
第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。  
第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。  
注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。  
推荐使用driver里面的参数化特性，避免自己构造语句。
```
CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据'}","page_content='图相关DDL

Create Graph

**Syntax**
一个图至少包含一对点边，点表必须包含一个id字段作为主键，边表必须包含srcId和targetId作为主键，边表还可以有一个时间戳字段标识时间。  
```
CREATE GRAPH <graph name>
(
<graph vertex>
[ { , <graph vertex> } ... ]
, <graph edge>
[ { , <graph edge> } ... ]
) WITH （
storeType = <graph store type>
[ { , <config key> = <config value> } ... ]
);

<graph vertex>  ::=
VERTEX <vertex name>
(
<column name> <data type> ID
[ {, <column name> <data type> } ... ]
)

<graph edge>  ::=
Edge <edge name>
(
<column name> <data type> SOURCE ID
, <column name> <data type> DESTINATION ID
[ , <column name> <data type> TIMESTAMP ]
[ {, <column name> <data type> } ... ]
)

```  
**Example**
```sql
CREATE GRAPH dy_modern (
Vertex person (
id bigint ID,
name varchar,
age int
),
Vertex software (
id bigint ID,
name varchar,
lang varchar
),
Edge knows (
srcId bigint SOURCE ID,
targetId bigint DESTINATION ID,
weight double
),
Edge created (
srcId bigint SOURCE ID,
targetId bigint DESTINATION ID,
weight double
)
) WITH (
storeType = 'rocksdb',
shardCount = 2
);
```
这个例子创建了一张包含2个点2个边的图，存储类型为rocksdb, 分片数2个。' metadata={'Header 1': '图相关DDL', 'Header 2': 'Create Graph'}","page_content='业务开发指南

导入数据

批量upsert边数据-根据边的属性确定唯一

上面描述的upsert逻辑是两点之间同类型的边只能有一条，如果要求两点之间同类型的边可以有多条，并且根据边上的某个属性来确定唯一，需要在原来的基础上多加一个字段，如下：
```
CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}], 'score')
```
在最后多了一个字段`score`, 逻辑变成：如果两点之间不存在一条`edge1`类型的边，并且`score`值等于某个值，就插入；否则就更新改边的属性。
边上的`score`字段需要提前加上一个特殊的`pair unique`索引，如下：
```
CALL db.addEdgeIndex('edge1', 'score', false, true)
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据-根据边的属性确定唯一'}"
OutEdgeIterator 类的 Delete 方法执行什么操作？,"page_content='业务开发指南

边类型操作

边类型删除字段

>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。  
如下操作，对于边类型`edge1`，一次删除了两个字段: `field1` 和 `field2`。
```
CALL db.alterLabelDelFields('edge', 'edge1', ['field1', 'field2'])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '边类型删除字段'}","page_content='业务开发指南

边类型操作

删除边类型

>该操作会同步删除所有该类型的边，数据量大的时候，有时间消耗。  
如下例子，删除边类型`edge1`以及该类型的所有边数据。
```
CALL db.deleteLabel('edge', 'edge1')
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '删除边类型'}","page_content='C++客户端

2.使用示例

2.10.删除存储过程

```C++
std::string str;
bool ret = client.DeleteProcedure(str, ""CPP"", ""test_plugin1"");
```
```
bool DeleteProcedure(std::string& result, const std::string& procedure_type,
const std::string& procedure_name, const std::string& graph = ""default"");
@param [out] result              The result.
@param [in]  procedure_type      the procedure type, currently supported CPP and PY.
@param [in]  procedure_name      procedure name.
@param [in]  graph               (Optional) the graph to query.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}"
TuGraph-DB的日志等级如何调整？,"page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

二、TuGraph-DB高可用架构与规划

4.Server架构设计—快照

前文中提到，加入 follower 时，需要同步日志。但是一个集群经过长期的服务，日志一定是非常多的，如果每加入一个 follower，都从一年之前、两年之前的日志开始同步，同步过来除了 Append，还需要应用到 Server 里面，是非常耗时的。所以需要定期对节点打快照，对数据库状态做一个保存。再去加入 follower 时，直接传输快照就可以了。  
Tugraph-DB 不管是安装快照还是打快照，都是非常快速的。因为 Tugraph-DB 底层支持 MVCC 多版本，生成快照的时候并不会去阻塞读写请求。  
增加节点  
• 新节点加入集群时，Leader发现要同步的日志不存在，则向Follower发送安装快照请求  
安装快照  
• TuGraph-DB支持MVCC，生成快照不会阻塞读写请求' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '二、TuGraph-DB高可用架构与规划', 'Header 3': '4.Server架构设计—快照'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

二、TuGraph-DB高可用架构与规划

2.Server架构设计—请求同步

集群建立好之后，可以向其发送读写请求。发送读请求非常简单，client 发送一个读请求给 TuGraph server，server 接到读请求之后，去进行处理。图中给出的一个 cypher 语句，是查询图中边的 label 的数量。在 server 端，会对 cypher 语句进行解析，辨别它是一个只读的请求，一旦确定就会直接发送给 TuGraph-DB，由 TuGraph-DB 进行响应。  
写请求会涉及到 DB 数据的变化。Client 发送给 server 之后，server 会通过一些自有的逻辑去判断，如果是一个写请求，那么它会传给内部的一个 raft node，这个 raft node 可以看作是一个 client。因为是三个节点，每个节点持有其它节点的一个 client，每个节点既是 server，也是 client。当收到这个请求之后，只有 leader 节点会处理写请求。它并不会直接应用到 TuGraph-DB 上面，而是先调用客户端把日志去发送给其它节点，当超过半数的节点响应之后，才会应用到 TuGraph-DB 内部，保证写请求日志的一致性。  
在高可用集群使用过程中，有很多不可预知的情况，比如正好在应用日志的时候，集群突然挂了或者突然重启了。即使这种情况发生的概率非常低，但在大规模应用中仍然有可能发生。因此，写请求必须是幂等的，请求的 log index 必须是一致的，当它应用到 DB 里时，不能产生重复的提交。所以我们在 DB 内部持有 log 的 index，当 client 由于超时重发或节点的状态发生变化而重复提交时，都不会对 DB 状态产生污染。' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '二、TuGraph-DB高可用架构与规划', 'Header 3': '2.Server架构设计—请求同步'}","page_content='技术规划

2. 已完成功能

TuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。  
| 版本号   | 功能                               | 时间         |
|-------|----------------------------------|------------|
| 3.3.0 | 开源初版                             | 2022.9.1   |
| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |
| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |
| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |
| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |
| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}"
机器性能指标中的“memory”是什么？,"page_content='功能概览

3.计算层

计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。  
- __图事务引擎__，主要用来处理并发的图操作，包括单点查询、邻居查询、路径遍历。图事务引擎侧重并发操作的ACID事务，确保操作逻辑不会互相干扰，主要性能指标为 QPS，即每秒完成的查询数量。  
- __图分析引擎__，操作类型通常为全图迭代。部分简单的分析任务（比如SPSP）可以由图事务引擎完成，复杂的分析任务均由图分析引擎完成，单个任务通常需要数秒至数小时。因此单个图分析任务要并发利用所有的硬件资源，性能指标为任务完成的总时长。  
- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。  
三个引擎的操作逻辑不尽相同，独立配置资源池。事图事务引擎基于RPC操作设置了一个线程池，每接受客户端的一个操作，从线程中取一个线程来处理，并发执行的数量等于RPC线程池的容量，通常配置为服务器的核数。图分析引擎有一个分析线程池，每个图分析任务会并发执行，即用所有的线程来执行一个任务，来加速操作的性能。TuGraph图分析操作串行执行的特性会一定程度限制用户的使用体验，并发的图分析的需求可以通过高可用部署的方式，增加机器资源来处理，或者接入外部的任务调度器，将数据传到实时调度的容器来计算。图神经网络操作在图上的操作会复用图事务引擎或图分析引擎的资源，向量的操作会起单独的资源，在机器学习框架中可以使用GPU等单独的加速硬件。' metadata={'Header 1': '功能概览', 'Header 2': '3.计算层'}","page_content='性能优先

4.数据编码

对于属性图模型而言，除了图拓扑编码外，属性数据也会很大程度影响功能和性能，我们先讨论属性数据如何与拓扑数据共存的编码格式。从目前的调研来看，属性编码有两种方式，我们称之为基于指针索引将属性数据单独存储的离散编码，和将属性数据和拓扑数据打包在一起的紧凑编码。离散编码根据程度的不同，可以每个属性都单独存储，或者每条边的属性打包后各自存储，下面的讨论对两种情况都适用。  
点查询。属性编码主要针对边，不涉及点查询。  
单边查询。离散编码通过指针定位边，紧凑编码则需要二分查找定位边的位置，离散编码有略微的优势。  
边遍历。离散编码在边遍历过程需要不断地进行指针跳转进行随机数据访问，而紧凑编码提前把数据排列在一起，顺序访问的特性使得效率大大提升。 由规律三知对边的遍历操作很普遍，紧凑编码在边遍历的优势明显。  
单边更新。离散编码对边的更新仅需找到对应的指针位置，插入数据后修改前后指针指向。紧凑编码则需要对紧凑排列的数据进行重编码，对整个边值进行重新写入，开销显著大于离散编码的情形。  
批量边更新。批量更新可以在内存中预先构建点的所有边属性，一次性编码写入，离散编码和紧凑编码相当。但紧凑编码不需要存储指针变量，更少的存储空间效率也会更高。  
以上离散编码和紧凑编码在某一类的查询的性能问题，可以通过优化的来缓解。整体上说，由于图负载读写 20:1 的特性，读性能在整体性能中占比更高。以及规律三所揭示的对属性访问的特征，TuGraph 更倾向于采用紧凑编码来保证读性能。其主要弱势为单边更新时重编码的开销，可以用自适应映射的技术来解决。' metadata={'Header 1': '性能优先', 'Header 2': '4.数据编码'}","page_content='性能优先

3.存储数据结构

TuGraph底层采用B+树来支持实时的增删查改事务。  
在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。  
总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}"
如果不选择清空画布数据按钮，导入的数据会如何处理？,"page_content='业务开发指南

子图操作

清空子图

#### 删除所有的点边数据和图schema
```
CALL db.dropDB()
```
#### 只删除所有点边数据, 保留图schema
```
CALL db.dropAllVertex()
```' metadata={'Header 1': '业务开发指南', 'Header 2': '子图操作', 'Header 3': '清空子图'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

`图项目`提供可视化的图项目管理和图数据研发功能，它为用户提供了一系列便捷的图数据可视化操作，包括图项目的创建、修改、删除等管理操作，以及图数据的查询、点边统计等操作。此外，它也支持图模型的管理，使用户可以更加方便地进行图数据的管理和维护。  
#### 2.4.1.图项目管理  
在`图项目`界面，可以看到当前图数据库中的图项目。  
![图项目-首页](../../../images/browser/graphmanagement-homepage.png)  
##### 2.4.1.1.新建图项目  
在`图项目`界面，点击`新建图项目`按钮创建一个新的图项目。  
![图项目-新建图项目按钮](../../../images/browser/graphmanagement-creategraph.png)  
新建图项目需要通过`选择模板`和`填写配置`两个页面完成图项目的创建。  
- __选择模板__：产品提供空模板和demo模板两类模板。
- 空模板：全新的图项目，用户需要自己创建图模型和导入图数据，一般用于正式项目开发。
- demo模板：产品内置的demo数据，图项目创建成功后，系统会自动创建demo图模型并导入demo图数据，一般用于试用和学习。  
![图项目-选择模板](../../../images/browser/graphmanagement-selecttemplate.png)  
- __填写配置__：用户需要填写图项目基本信息，并点击`创建`按钮创建图项目。
- 图名称：新建图项目的名称，同时作为该图项目的唯一主键。支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。
- 图描述：新建图项目的描述，可用于详细说明该项目的背景和目标。
- 高级配置-最大存储空间：设置图项目最大可占用的存储空间，实际并不会提前占用物理存储空间，实际数据量达到最大存储空间阈值后不可再写入数据。  
![图项目-填写配置](../../../images/browser/graphmanagement-configure.png)  
创建成功后，可在`图项目`页面的图项目选项卡中查看。  
##### 2.4.1.2.编辑图项目  
在`图项目`界面，点击图项目选项卡中的`编辑`按钮（笔形图标），编辑对应图项目的基础信息。  
![图项目-编辑图项目按钮](../../../images/browser/graphmanagement-editgraph-button.png)  
编辑图项目功能可以修改`图描述`和`最大存储空间`。  
![图项目-编辑图项目](../../../images/browser/graphmanagement-editgraph.png)  
##### 2.4.1.3.删除图项目  
在`图项目`界面，点击图项目选项卡中的`删除`按钮（垃圾桶图标），删除对应的图项目。  
![图项目-删除图项目按钮](../../../images/browser/graphmanagement-deletegraph-button.png)  
_需要注意：图项目删除后无法恢复_。  
##### 2.4.1.4.点边统计  
在`图项目`界面，点击图项目选项卡中的`点边统计`按钮（刷新图标），统计对应图项目当前时间节点的点边数量。  
![图项目-点边统计按钮](../../../images/browser/graphmanagement-statistics-button.png)  
统计结果将展示在图项目选项卡上，已经统计过点边数据的图项目再次统计需要点击`刷新`按钮。  
![图项目-点边统计](../../../images/browser/graphmanagement-statistics.png)  
![图项目-刷新点边统计按钮](../../../images/browser/graphmanagement-statistics-refresh-button.png)  
##### 2.4.1.5.存储过程  
在`图项目`界面，点击图项目选项卡中的`存储过程`按钮（卡片最右侧图标），跳转到操作存储过程的图页面。  
![图项目-存储过程按钮](../../../images/browser/graphmanagement-procedure-button.png)  
在`存储过程`页面，可以新建存储过程，新建时需要填写""存储过程名称""、""存储过程类型""、""存储过程描述""，然后选择""版本""和""执行时是否修改数据库""  
![图项目-存储过程](../../../images/browser/graphmanagement-procedure.png)  
更多存储过程的相关操作可见 [存储过程](../9.olap&procedure/1.procedure/1.procedure.md)  
#### 2.4.2.图构建  
Browser的`图构建`功能主要用于图项目的模型定义和数据导入。在`图项目`页面中，点击图项目选项卡中的`图构建`按钮。  
![图构建-按钮](../../../images/browser/graphbuild-button.png)  
##### 2.4.2.1.模型定义  
Browser提供可视化的方式创建和维护图模型。  
- 也可用通过`cypher`工具和`lgraph_import`工具创建和维护图模型，详见[Cypher API](../8.query/1.cypher.md)和[数据导入](../6.utility-tools/1.data-import.md)文档。  
###### a.浏览图模型  
在`模型定义`界面可以查看详细的图模型设置，支持列表和画布方式查看图模型，支持列表展示点类型的属性和索引、边类型的属性和起点/终点类型。  
![图构建-浏览图模型](../../../images/browser/graphbuild.png)  
- 支持列表查看点类型和边类型。
- 支持点类型和边类型的个数展示，在点类型或边类型页签中展示对应的点或边数量。
- 支持点类型和边类型的名称关键字搜索，在`搜索框`输入关键字可展示对应的点或边。  
![图构建-浏览图模型-搜索](../../../images/browser/graphbuild-list-search.png)
- 支持点类型和边类型的名称复制，点击`复制`按钮可以复制点或边的名称至粘贴板。  
![图构建-浏览图模型-复制](../../../images/browser/graphbuild-list-copy.png)
- 支持点类型和边类型的删除，点击`删除`按钮可以删除对应的点或边。  
![图构建-浏览图模型-删除](../../../images/browser/graphbuild-list-delete.png)
- 支持画布方式查看点类型和边类型。
- 在列表或画布中点击相应的点类型或边类型，可以展示模型详情。
![图构建-浏览图模型-删除](../../../images/browser/graphbuild-select.png)  
###### b.添加点  
在`模型定义`界面点击`添加点`按钮，在右侧滑动窗口中添加点类型。  
![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex-button.png)  
用户需要输入点类型名称、属性和索引，点击`完成`按钮完成点类型的创建。
- 点类型名称：点的名称，也是该点的唯一标识。
- 属性：点的属性，需要一个属性作为主键。
- 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。
- 选填：该属性是否可以为空值。
- 删除：在创建点时可以任意删除属性。
- 索引：点的索引属性，需要先创建属性再设置该属性为索引，索引创建成功后无法修改。
- 属性：需要配置索引的属性。
- 唯一：设置该属性字段为唯一值。
- 主键：对应属性是否为主键，选择`是`后`唯一`选项必须为`是`。
- 删除：在创建点时可以任意删除索引。  
![图构建-添加点按钮](../../../images/browser/graphbuild-addvertex.png)  
- 编辑点：可以增加点的属性和修改已有属性的数据类型，新增或删除索引。需要对每个新增或修改的属性点击`保存`按钮才可以生效。
_注：主键字段的属性创建后无修改_  
![图构建-编辑点](../../../images/browser/graphbuild-editvertex.png)  
###### c.添加边  
在`模型定义`界面点击`添加边`按钮，在右侧滑动窗口中添加边类型。  
![图构建-添加边按钮](../../../images/browser/graphbuild-addedge-button.png)  
用户需要输入边类型名称、属性、选择起点类型和终点类型，点击`完成`按钮完成边类型的创建。
- 边类型名称：边的名称，也是该边的唯一标识。
- 属性：边的属性，边上可以没有属性。
- 数据类型：属性字段的数据类型，支持INT、STRING、DOUBLE、DATE、DATETIME、BLOB、BOOL等类型。
- 选填：该属性是否可以为空值。
- 删除：在创建边时可以任意删除属性。
- 选择起点类型和终点类型：设置边的起点点类型和终点点类型，支持多个起点类型和终点类型。
- 起点：选择起点的点类型。
- 终点：选择终点的点类型。
- 需要提前创建至少一个点类型才能设置边的起点类型和终点。
- 如果不选择则表示起点和终点可以为任意点类型，同时画布上不展示对应的边，需要在左侧列表查看边类型。  
![图构建-添加边](../../../images/browser/graphbuild-addedge.png)  
- 编辑边：可以增加边的属性和修改已有属性的数据类型。需要对每个新增或修改的属性点击`保存`按钮才可以生效。  
![图构建-编辑边](../../../images/browser/graphbuild-editedge.png)  
###### d.导入模型  
在`模型定义`界面点击`导入模型`按钮，可以上传模型文件快速创建模型。  
![图构建-导入模型按钮](../../../images/browser/graphbuild-importmodel-button.png)  
在`导入模型`界面点击`上传文件`按钮，上传模型文件成功后，点击确定可以导入图模型。  
- 覆盖当前画布中的模型：选中该选项，导入时会先清空已有图模型再导入模型文件中的图模型；不选择，会导入模型文件中新增的点类型和边类型，但不会修改已有的点类型和边类型。  
![图构建-导入模型](../../../images/browser/graphbuild-importmodel.png)  
###### e.导出模型  
在`模型定义`界面点击`导出模型`按钮，可以将当前图项目中的图模型导出成json文件。  
![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel-button.png)  
模型文件为json格式，不建议手动修改。  
![图构建-导出模型按钮](../../../images/browser/graphbuild-exportmodel.png)  
##### 2.4.2.2.数据导入  
完成`模型定义`之后，点击`数据导入`按钮进入数据导入页面。  
![图构建-数据导入](../../../images/browser/graphbuild-dataimport.png)  
###### a.数据准备  
在数据导入前需要提前准备数据，当前Browser支持CSV文件的上传，需要保证数据文件后缀为csv。
- 不强制要求包含表头。
- 支持文本限定符，文本限定符为双引号。  
![数据导入-csv](../../../images/browser/graphbuild-import-csv.png)  
###### b.上传文件  
在`数据导入`页面上传需要导入的数据文件，将数据导入到图项目中。  
![数据导入-上传文件](../../../images/browser/graphbuild-import.png)  
- 分隔符：数据文件的列分隔符。
- 文件上传：支持上传多个文件。
- 支持弹窗中选择多个上传文件。
- 支持将文件拖拽至页面中上传。
- 支持同时上传点文件和边文件。  
###### c.数据映射  
文件上传成功后，需要在`数据导入`页面设置`数据对应表`，将数据文件中的数据列和目标点/边、对应属性建立映射关系。  
- 数据对应表：展示已经上传的数据问题。
- 文件名称：上传的数据文件名称。
- 文件大小：上传的数据文件大小。
- 读取结果：数据文件上传结果，success为读取成功。
- 删除：在页面中删除，不会删除本地文件。
- 数据文件映射：每个已上传的数据文件都需要配置映射关系。
- 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。
- 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。
- 属性映射：下拉选择数据列对应的属性字段。
- 数据预览：系统会预读数据文件的前5行。  
![数据导入-数据映射](../../../images/browser/graphbuild-import-datamapping.png)  
文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。  
![数据导入-导入成功](../../../images/browser/graphbuild-import-success.png)  
#### 2.4.3.图查询  
在`图项目`界面点击图项目选项卡中的`图查询`按钮，可以查询和访问图项目中的图数据，产品提供`语句查询`、`路径查询`、`点查询`等多种模式查询图数据，支持切换图项目和查询结果展示。  
![图查询-按钮](../../../images/browser/query-button.png)  
##### 2.4.3.1.切换图项目  
`图查询`功能只能访问一个图项目数据，用户可以在`切换图项目`下拉框中选择并切换至其他图数据。  
![图查询-切换图项目](../../../images/browser/query-selectgraph.png)  
##### 2.4.3.2.语句查询  
Browser提供可视化方式开发和调试图查询语句，用户可以输入图查询语句、执行并返回结果，支持收藏语句和查看图模型。  
![图查询-语句查询](../../../images/browser/query-view.png)  
###### a.语句查询窗口  
用户在`语句查询窗口`输入图查询语句，点击`执行`按钮可以运行对应语句，并在`执行结果页签`展示结果。  
- 切换查询语言：提供不同图查询语言模式的切换。_当前只支持Cypher语法_  
![图查询-切换语言](../../../images/browser/query-selectgql.png)  
- 语句查询窗口：提供当前查询语言的语法提示。  
![图查询-语法提示](../../../images/browser/query-gqltips.png)  
- 执行：点击`执行`按钮，发送输入的查询语句至后台运行。  
![图查询-执行按钮](../../../images/browser/query-execute-button.png)  
- 收藏：点击`收藏`按钮，将当前语句查询窗口的内容保存成模板，以便下次使用。  
![图查询-收藏按钮](../../../images/browser/query-bookmark-button.png)  
- 下载：点击`下载`按钮，将当前语句查询窗口的内容保存成文本文件并下载至本地，以便下次使用。  
![图查询-下载按钮](../../../images/browser/query-download-button.png)  
详细Cypher使用指南请参考文档：[Cypher API](../8.query/1.cypher.md)  
###### b.收藏列表  
以列表方式展示已经收藏的查询语句，点击列表中的收藏模板可以使用其中的语句。支持关键字搜索、名称修改以及删除。  
![图查询-语句收藏](../../../images/browser/query-bookmark.png)  
###### c.查看图模型  
Browser提供当前图项目中的图模型查询，方便用户清晰点边类型模型，支持列表展示和画布图谱展示方式，支持隐藏查看图模型窗口。  
![图查询-图模型列表](../../../images/browser/query-schema-list.png)
![图查询-图模型图谱](../../../images/browser/query-schema-graph.png)  
##### 2.4.3.3.路径查询  
Browser提供`路径查询`模板，用户可以通过选择路径的方式，查找图项目中的图数据是否存在相应的路径。  
![路径查询](../../../images/browser/pathquery-result.png)  
- 路径：在路径选择下拉框内选择需要查找的路径。
- 选择路径：根据图模型的定义，系统会自动匹配出对应的一度关系路径；再次点击路径下拉框会，系统会根据路径终点的点类型自动匹配下一度关系路径。
![路径查询-选择路径](../../../images/browser/pathquery-select.png)
- 执行：点击`执行`按钮返回图项目中匹配的路径。
- 高级配置：设置扫描的路径数目，默认为100条路径。
![路径查询-高级配置](../../../images/browser/pathquery-configuration.png)  
_注：需要图模型中的边设置起点和终点，如果图项目中的边均未设置起点和终点，下拉选项无结果_  
##### 2.4.3.4.点查询  
Browser提供`点查询`模板，用户可以通过选择点属性进行查询，查找图项目中的点数据。  
![点查询](../../../images/browser/vertexquery.png)  
##### 2.4.3.5.执行结果页签  
Browser提供表格文本、点边视图等多种方式展示图查询结果，支持结果下载、插入数据、全屏展示。  
###### a.表格文本  
Browser提供以表格文本方式展示查询结果。  
![JSON视图](../../../images/browser/query-result-txt.png)  
###### b.点边视图  
Browser提供以画布方式展示查询结果。  
![点边视图](../../../images/browser/query-result-graph.png)  
###### c.插入数据  
Browser提供可视化方式在对应图项目中插入点或边数据。点击`插入数据`按钮，在`插入数据`页签选择点类型或边类型，输入属性值，点击确定完成数据插入。  
![插入数据-按钮](../../../images/browser/query-result-insert-button.png)  
![插入数据](../../../images/browser/query-result-insert.png)  
###### d.下载执行结果  
Browser提供图查询结果导出成文本文件功能。点击`下载执行结果`按钮，系统会自动将结果保存成文本文件并下载至本地。  
![下载执行结果-按钮](../../../images/browser/query-result-download.png)
![下载执行结果-按钮](../../../images/browser/query-result-downloadtxt.png)  
###### e.全屏展示  
Browser提供全屏方式展示图查询结果，点击`全屏显示`按钮全屏展示结果，点击`退出全屏`按钮退出全屏展示。  
![全屏展示-按钮](../../../images/browser/query-result-fullscreen-button.png)
![全屏展示](../../../images/browser/query-result-fullscreen.png)
![全屏展示-按钮](../../../images/browser/query-result-fullscreen-close.png)  
#### 2.4.4.图分析  
在`图项目`界面点击图项目选项卡中的`图分析`按钮，可以在画布中展示和分析图数据，产品提供`语句查询`和`配置查询`将图项目中的数据查询并加载至画布，支持画布数据的筛选、布局样式调整以及画布操作。  
![图分析-按钮](../../../images/browser/graphanalysis-button.png)  
如下图所示，图分析功能主要包括：  
1、操作栏：图分析主要操作功能，包括布局切换、查询过滤、布局、样式以及画布操作；
2、左边栏：查询、筛选、外观功能操作区域；
3、画布区域：展示图数据的区域，展示点和边数据，支持点扩展查询、收起节点、固定节点、删除节点、画布图数据统计、缩放、居中等功能；
4、右边栏：选中一个点数据或边数据后，会展示对应的属性信息；
5、布局切换：标签布局和卡片布局的切换。  
![图分析-操作区域](../../../images/browser/graphanalysis-operation-area.png)  
##### 2.4.4.1.语句查询  
在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。
- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)  
##### 2.4.4.2.配置查询  
在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-模板查询](../../../images/browser/graphanalysis-queryfilter-configurequery.png)  
##### 2.4.4.3.画布分析  
在`画布分析`功能中，用户可以对画布中的节点或边数据进行操作和分析，主要包括：选中节点进行扩展查询、收起/展开节点、固定节点，清空画布，套索，点/边检索，画布图例等。画布上的最基础操作是拖拽点数据，鼠标左键选住一个节点并移动鼠标，可以完成点数据位置的移动。  
###### a.扩展查询  
在`画布`区域右键点击一个节点数据，弹出操作悬窗，鼠标移至`扩展查询`处弹出二级悬窗，点击对应的扩展度数进行查询。
- 一度查询：双向扩展一度关系。
- 二度查询：双向扩展二度关系。
- 三度查询：双向扩展三度关系。  
![图分析-画布分析-扩展查询-按钮](../../../images/browser/graphanalysis-canvas-expand-before.png)  
![图分析-画布分析-扩展查询-查询后](../../../images/browser/graphanalysis-canvas-expand-after.png)  
###### b.收起/展开节点  
在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`收起节点`会隐藏所选节点的一度关系节点；再次右键已`收起节点`的点数据可以进行`展开节点`操作，展示已隐藏的一度关系节点。  
![图分析-画布分析-收起节点](../../../images/browser/graphanalysis-canvas-collapse.png)  
![图分析-画布分析-展开节点](../../../images/browser/graphanalysis-canvas-expand.png)  
###### c.删除节点  
在`画布`区域右键点击一个节点数据，弹出操作悬窗，点击`删除节点`会将所选节点移出画布。  
![图分析-画布分析-删除节点](../../../images/browser/graphanalysis-canvas-delete.png)  
###### d.清空画布  
在`操作栏`区域点击`清空画布`按钮，会清除所有画布中的数据。  
![图分析-画布分析-清空画布](../../../images/browser/graphanalysis-canvas-clear.png)  
###### e.点/边检索  
在`点/边检索`窗口选择点或边，并输入关键字，会模糊检索画布中的属性数据，检索后可定位至数据位置。  
![图分析-画布分析-检索](../../../images/browser/graphanalysis-canvas-retrieval.png)  
###### f.画布图例  
在`画布`区域的图例位置，会展示画布中的点类型，点击点类型可以选中对应的点数据，点击更多按钮可以展示统计情况，支持列表或图表方式展示点或边的数量。  
![图分析-画布分析-列表](../../../images/browser/graphanalysis-canvas-legend-list.png)
![图分析-画布分析-图表](../../../images/browser/graphanalysis-canvas-legend-chart.png)  
###### g.缩放/居中  
可以使用鼠标滚轮和缩放按钮进行缩放。
![图分析-画布分析-缩放](../../../images/browser/graphanalysis-canvas-zoom.png)
![图分析-画布分析-缩放](../../../images/browser/graphanalysis-canvas-center.png)  
##### 2.4.4.4.属性筛选  
在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`属性筛选`进行筛选过滤。用户可以选择要筛选的点或边类型，以及对应的属性值进行设置，检索到筛选组条件的数据后会在画布上高亮选中对应的点或边数据。
- 请选择点/边类型：选择需要检索的点类型或边类型。
- 属性条件：设置需要检索的属性条件，可以设置多组，取并集筛选结果。
- 添加筛选组：可以多组筛选条件，取并集筛选结果。
- 重置：可以清空筛选条件。  
![图分析-筛选-属性筛选](../../../images/browser/graphanalysis-queryfilter-attributefilter.png)  
##### 2.4.4.5.统计筛选  
在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。  
![图分析-筛选-统计筛选](../../../images/browser/graphanalysis-queryfilter-statisticalfilter.png)
![图分析-统计筛选-图表切换](../../../images/browser/graphanalysis-queryfilter-statisticalfilter-chartswitch.png)  
##### 2.4.4.6.点边布局  
在`操作栏`区域点击`布局`按钮，选择对应的布局方式会将画布中的数据进行重新排布，支持力导向布局、同心圆布局、圆形布局、辐射布局、Dagre布局以及网格布局，每种布局方式均有不同布局参数，调整参数后画布中的数据会进行重新排布。  
![图分析-布局样式-按钮](../../../images/browser/graphanalysis-style-layout-button.png)
![图分析-布局样式-布局参数](../../../images/browser/graphanalysis-style-layout-parameters.png)  
详细布局参数可参考[AntV-G6](https://g6.antv.antgroup.com/api/graph-layout/guide)。  
##### 2.4.4.7.外观样式  
在`操作栏`区域点击`外观`按钮，在`左边栏`点击`点样式`或`边样式`进行外观样式配置。
- 点样式
- 应用点类型：设置对应点类型的展示样式，支持同时配置多个点类型外观。
- 大小：对应点类型的展示大小。
- 颜色：对应点类型的展示颜色。
- 图标：对应点类型的图标样式。
- 显示文本：对应点类型显示的文本内容，默认为id。
- 高级配置：根据设置的条件标记对应的点数据。
- 边样式
- 应用边类型：设置对应边类型的展示样式。
- 颜色：对应点类型的展示颜色。
- 边宽：对应边类型的展示宽度。
- 显示文本：对应边类型显示的文本内容，默认不显示。
- 高级配置：根据设置的条件按颜色展示对应的边数据，支持同时配置多个边类型外观。  
![图分析-外观](../../../images/browser/graphanalysis-style-appearance.png)  
##### 2.4.4.8.视图切换  
图分析中支持2D图谱视图、列表视图以及JSON视图。
![图分析-视图-2D](../../../images/browser/graphanalysis-view-2D.png)
![图分析-视图-list](../../../images/browser/graphanalysis-view-list.png)
![图分析-视图-json](../../../images/browser/graphanalysis-view-json.png)  
##### 2.4.4.9.标签/卡片布局切换  
图分析支持标签布局和卡片布局。
![图分析-标签](../../../images/browser/graphanalysis-tag.png)
![图分析-卡片](../../../images/browser/graphanalysis-card.png)' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='数据导入

4.离线全量导入

离线模式只能在离线状态的服务器使用。离线导入会创建一张新图，因此更适合新安装的 TuGraph 服务器上的第一次数据导入。
要在离线模式下使用`lgraph_import`工具，可以指定`lgraph_import --online false`选项。要了解可用的命令行选项，请使用`lgraph_import --online false --help`：  
```shell
$ ./lgraph_import --online false -help
Available command line options:
--log               Log file to use, empty means stderr. Default="""".
-v, --verbose       Verbose level to use, higher means more verbose.
Default=1.
...
-h, --help          Print this help message. Default=0.
```  
命令行参数：  
- **-c, --config_file** `config_file`: 导入配置文件名，其格式要求见下述。
- **--log** `log_dir`: 日志目录。默认为空字符串，此时将日志信息输出到控制台。
- **--verbose** `0/1/2`: 日志等级，等级越高输出信息越详细。默认为 1。
- **-i, --continue_on_error** `true/false`: 在碰到错误时跳过错误并继续，默认为 false，碰到错误立即退出。
- **-d, --dir** `{diretory}`: 数据库目录，导入工具会将数据写到这个目录。默认为`./db`。
- **--delimiter** `{delimiter}`: 数据文件分隔符。只在数据源是 CSV 格式时使用，默认为`"",""`。
- **-u, --username** `{user}`: 数据库用户名。需要是管理员用户才能执行离线导入。
- **-p, --password** `{password}`: 指定的数据库用户的密码
- **--overwrite** `true/false`: 是否覆盖数据。设为 true 时，如果数据目录已经存在，则覆盖数据。默认为`false`。
- **-g, --graph** `{graph_name}`: 指定需要导入的图种类。
- **-h, --help**: 输出帮助信息。' metadata={'Header 1': '数据导入', 'Header 2': '4.离线全量导入'}"
如何通过邮件提出关于TuGraph产品的建议？,"page_content='如何贡献

4. 贡献代码流程

4.1. 提交issue

不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:  
- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。
- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。
- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。' metadata={'Header 1': '如何贡献', 'Header 2': '4. 贡献代码流程', 'Header 3': '4.1. 提交issue'}","page_content='什么是TuGraph

4. TuGraph企业版

企业版对商业化功能支持更加完善，包括分布式集群架构，覆盖探索、研发、服务、运维管理全生命周期的一站式图平台，在线、近线、离线的图计算引擎，支持流式、大数据类数据源，多地多中心的部署形态，以及专家支持服务等。企业版是商业化解决方案的理想选择。  
如需商业支持，请联系我们：  
- 电话：400-903-0809
- 邮件：tugraph@service.alipay.com
- 官网：https://tugraph.antgroup.com' metadata={'Header 1': '什么是TuGraph', 'Header 2': '4. TuGraph企业版'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}"
边索引支持查询加速么？,"page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}","page_content='业务开发指南

边类型操作

边类型添加索引

>该操作会同步构建索引数据，数据量大的时候，有时间消耗。  
如下例子，对于边类型`edge1`，给字段`field1`添加了一个非唯一索引。
```
CALL db.addEdgeIndex('edge1', 'field1', false, false)
```
如下例子，对于边类型`edge1`，给字段`field2`添加了一个唯一索引。
```
CALL db.addEdgeIndex('edge1', 'field2', true, false)
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '边类型添加索引'}","page_content='QA汇总

Cypher QA

长边条件查询

Q：是否支持不定长边的条件查询？
示例：  
```
MATCH p=(v)-[e:acted_in|:rate*1..3]-(v2) WHERE id(v) IN [3937] AND e.stars = 3 RETURN p LIMIT 100
```  
A：目前还不支持不定长边的过滤查询。目前的代替方案只能是分开写。上面的示例，就需要从 1 跳到 3 跳都写一遍。' metadata={'Header 1': 'QA汇总', 'Header 2': 'Cypher QA', 'Header 3': '长边条件查询'}"
TuGraph Monitor的主要功能是什么？,"page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph Management

简介

TuGraph Management 是一款为TuGraph开发的算法任务管理工具。采用了sofastack与brpc作为通信框架，并使用sqlite进行持久化存储。  
主要功能：  
- 算法任务状态持久化存储  
- 算法任务结果持久化存储  
- 延时触发与定时触发算法任务支持' metadata={'Header 1': 'TuGraph Management', 'Header 2': '简介'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}"
TuGraph HA 集群的管理工具是什么？,"page_content='TuGraph Management

简介

TuGraph Management 是一款为TuGraph开发的算法任务管理工具。采用了sofastack与brpc作为通信框架，并使用sqlite进行持久化存储。  
主要功能：  
- 算法任务状态持久化存储  
- 算法任务结果持久化存储  
- 延时触发与定时触发算法任务支持' metadata={'Header 1': 'TuGraph Management', 'Header 2': '简介'}","page_content='部署高可用模式

1.原理

TuGraph 通过多机热备份来提供高可用（HA）模式。在高可用模式下，对数据库的写操作会被同步到所有服务器（非witness）上，这样即使有部分服务器宕机也不会影响服务的可用性。  
高可用模式启动时，多个 TuGraph 服务器组成一个备份组，即高可用集群。每个备份组由三个或更多 TuGraph 服务器组成，其中某台服务器会作为`leader`，而其他复制组服务器则作为`follower`。写入请求由`leader`
提供服务，该`leader`将每个请求复制同步到`follower`，并在请求同步到服务器后才能响应客户端。这样，如果任何服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`
服务器发生故障，其他服务器将自动选择出新的`leader`。  
TuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。
而`witness`节点是一种只接收心跳和日志但不保存数据的节点。根据部署需求，`leader`节点和`follower`节点可以灵活的部署为`replica`节点或`witness`节点。
基于此，TuGraph高可用模式的部署方式有两种：一是普通部署模式，二是带witness的简约部署模式。  
对于普通部署模式，`leader`和所有`follower`均为`replica`类型的节点。写入请求由`leader`提供服务，该`leader`将每个请求复制同步到`follower`，
并在请求同步到超过半数的服务器后才能响应客户端。这样，如果少于半数的服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`
服务器发生故障，其他服务器将自动选举出新的`leader`，通过这种方式保证数据的一致性和服务的可用性。  
然而，在用户服务器资源不够或者发生网络分区时，不能建立正常的HA集群。此时，由于`witness`节点没有数据，对资源占用小，可以将`witness`节点和`replica`节点部署在一台机器上。
例如，当只有2台机器的情况下，可以在一台机器上部署`replica`节点，在另一台机器上部署`replica`节点和`witness`节点，不仅节省资源，而且不需要把日志应用到状态机上，
也不需要生成和安装快照，因此响应请求的速度很快，可以在集群崩溃或网络分区时协助快速选举出新的`leader`，这就是TuGraph HA集群的简约部署模式。
尽管`witness`节点有诸多好处，但是由于没有数据，集群实际上增加了一个不能成为`leader`的节点，因此可用性会略有降低。为提高集群的可用性，
可通过指定`ha_enable_witness_to_leader`参数为`true`，允许`witness`节点临时当主。`witness`节点在把新日志同步到其他节点之后，
会将leader角色主动切换到有最新日志的节点。  
v3.6及以上版本支持此功能。' metadata={'Header 1': '部署高可用模式', 'Header 2': '1.原理'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}"
如何通过POST方法修改Token的有效期为无限期？,"page_content='Token使用说明

2. Token有效期

2.4. Token有效期修改

为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。  
* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。
具体可查询[REST接口文档](../7.client-tools/9.restful-api-legacy.md)。  
* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。可参考[服务运行文档](../5.installation&running/7.tugraph-running.md)。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.4. Token有效期修改'}","page_content='RESTful API Legacy

3.登录

3.3.修改Token有效期

修改Token有效期，需要传输jwt，refresh_time和expire_time三个参数，其中jwt用于校验用户身份，refresh_time和expire_time等于0时，有效期为无期限，超过refresh_time时，需要调用refresh接口获取新的Token;超过expire_time时，需要重新登录。  
- **URI**: `/update_token_time`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| Authorization | 令牌 | 字符串 |
| refresh_time | 有效时间（默认设置为0） | Int64 |
| expire_time | 有效时间（默认设置为0） | Int64 |  
- **RESPONSE**:  如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/update_token_time
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{
""Authorization"" : ""Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmbWEuYWkiLCJwYXNzd29yZCI6IjczQFR1R3JhcGgiLCJ1c2VyIjoiYWRtaW4ifQ.o_yb5veSJkuy-ieBp4MqTk-tC1grcKotgVbgNJ0TyTU"",
""refresh_time"":0,
""expire_time"":0
}
```  
**Example response.**  
```
• 200: OK
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录', 'Header 3': '3.3.修改Token有效期'}","page_content='Token使用说明

2. Token有效期

2.3. Token有效期刷新机制

Token有效期存在刷新机制，默认关闭。如果打开后，Token的安全性会更高，实现上则存在两个时间戳。  
第一个时间戳`refresh_time`用于判定Token是否过期（默认24小时）：过期后可以调用刷新接口获取新的Token，可以设置为更短的时间，比如1小时。  
第二个时间戳`expire_time`为强制过期时间戳（默认24小时）：过期后必须重新登陆。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.3. Token有效期刷新机制'}"
TuGraph图数据库是由哪两个机构联合研发的？,"page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph由LDBC认定全球领先

基本介绍

TuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。  
**随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品**。  
开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。  
图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。  
蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。  
蚂蚁集团 2015 年开始自主研发分布式图数据库、流式图计算等图相关技术，2016 年发布自研分布式图数据库，并应用于支付宝。至今 TuGraph 已应用于蚂蚁内部 150 多个场景，包括在线支付的实时链路，以支付宝风险识别能力提升近 10 倍、风险审理分析效率提升 90%的成绩，验证了其高可靠性。  
LDBC（关联数据基准委员会）发布最新图数据库 SNB 测试结果，TuGraph 在功能完整性、吞吐率、响应速度等层面全球领先。  
目前，蚂蚁集团已形成了一套以图数据库为底座、同时包含流式图计算，离线图学习的大规模图计算系统。  
蚂蚁集团图数据库负责人洪春涛表示，图技术是未来大数据、人工智能和高性能计算产业发展的关键所在，它很有可能会成为下一代的数据底座。蚂蚁集团愿意通过开源持续输出核心技术优势，推动图数据库更广泛的应用生态，携手行业抢占技术高地，不断探索技术的可能性。' metadata={'Header 1': 'TuGraph由LDBC认定全球领先', 'Header 2': '基本介绍'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}"
TuGraph图学习模块依赖于什么系统？,"page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='Learn Tutorial

2. 运行流程

TuGraph 图学习模块将TuGraph中的图数据采样，采样后的顶点和边作为图学习的特征，进行学习训练。运行流程如下图所示：
![Alt text](../../../../images/learn_flow_chart_zh.png)' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '2. 运行流程'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

TuGraph 的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。 在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。  
TuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法。涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。  
<table><tbody><tr><td>算法类型</td><td>中文算法名</td><td>英文算法名</td><td>程序名</td></tr><tr><td rowspan=""5"">路径查询</td><td>广度优先搜索</td><td>Breadth-First Search</td><td>bfs</td></tr><tr><td>单源最短路径</td><td>Single-Source Shortest Path</td><td>sssp</td></tr><tr><td>全对最短路径</td><td>All-Pair Shortest Path</td><td>apsp</td></tr><tr><td>多源最短路径</td><td>Multiple-source Shortest Paths</td><td>mssp</td></tr><tr><td>两点间最短路径</td><td>Single-Pair Shortest Path</td><td>spsp</td></tr><tr><td rowspan=""9"">重要性分析</td><td>网页排序</td><td>Pagerank</td><td>pagerank</td></tr><tr><td>介数中心度</td><td>Betweenness Centrality</td><td>bc</td></tr><tr><td>置信度传播</td><td>Belief Propagation</td><td>bp</td></tr><tr><td>距离中心度</td><td>Closeness Centrality</td><td>clce</td></tr><tr><td>个性化网页排序</td><td>Personalized PageRank</td><td>ppr</td></tr><tr><td>带权重的网页排序</td><td>Weighted Pagerank Algorithm</td><td>wpagerank</td></tr><tr><td>信任指数排名</td><td>Trustrank</td><td>trustrank</td></tr><tr><td>sybil检测算法</td><td>Sybil Rank</td><td>sybilrank</td></tr><tr><td>超链接主题搜索</td><td>Hyperlink-Induced Topic Search</td><td>hits</td></tr><tr><td rowspan=""4"">关联性分析</td><td>平均集聚系数</td><td>Local Clustering Coefficient</td><td>lcc</td></tr><tr><td>共同邻居</td><td>Common Neighborhood</td><td>cn</td></tr><tr><td>度数关联度</td><td>Degree Correlation</td><td>dc</td></tr><tr><td>杰卡德系数</td><td>Jaccard Index</td><td>ji</td></tr><tr><td rowspan=""5"">图结构</td><td>直径估计</td><td>Dimension Estimation</td><td>de</td></tr><tr><td>K核算法</td><td>K-core</td><td>kcore</td></tr><tr><td>k阶团计数算法</td><td>Kcliques</td><td>kcliques</td></tr><tr><td>k阶桁架计数算法</td><td>Ktruss</td><td>ktruss</td></tr><tr><td>最大独立集算法</td><td>Maximal independent set</td><td>mis</td></tr><tr><td rowspan=""8"">社区发现</td><td>弱连通分量</td><td>Weakly Connected Components</td><td>wcc</td></tr><tr><td>标签传播</td><td>Label Propagation Algorithm</td><td>lpa</td></tr><tr><td>EgoNet算法</td><td>EgoNet</td><td>en</td></tr><tr><td>鲁汶社区发现</td><td>Louvain</td><td>louvain</td></tr><tr><td>强连通分量</td><td>Strongly Connected Components</td><td>scc</td></tr><tr><td>监听标签传播</td><td>Speaker-listener Label Propagation Algorithm</td><td>slpa</td></tr><tr><td>莱顿算法</td><td>Leiden</td><td>leiden</td></tr><tr><td>带权重的标签传播</td><td>Weighted Label Propagation Algorithm</td><td>wlpa</td></tr><tr><td rowspan=""3"">模式挖掘</td><td>三角计数</td><td>Triangle Counting</td><td>triangle</td></tr><tr><td>子图匹配算法</td><td>Subgraph Isomorphism</td><td>subgraph_isomorphism</td></tr><tr><td>模式匹配算法</td><td>Motif</td><td>motif</td></tr></tbody></table>' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}"
构造FieldSpec时需要哪些参数？,"page_content='Cypher API

5.附录2. 内置procedures列表

* db.createEdgeLabel( label_name, field_spec...)

Create an edge label.  
**Parameters:**  
| parameter  | parameter type | description          |
| ---------- | -------------- | ------------------------ |
| label_name | string     | name of the label    |
| edge_constraints | string | edge constraints |
| field_spec | list       | specification of a field |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields.  
`edge_constraints` is a json array string, This parameter limits the combination of starting and ending vertex of the edge, for example: `'[[""vertex_label1"",""vertex_label2""],[""vertex_label3"",""vertex_label4""]]'`, which limits the edge direction can only be from `vertex_label1` to `vertex_label2` or from `vertex_label3` to `vertex_label4`. If you don't want to have any constraints, give an empty array string, like this `'[]'`  
**Output:**  
If successful, it returns a success message.  
**Example input:**  
```
CALL db.createEdgeLabel('KNOWS', '[]', 'name', 'int32', true)
```  
**Example output:**  
```
Added type [KNOWS]
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createEdgeLabel( label_name, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createVertexLabel(label_name, primary_field, field_spec...)

Create a vertex label.  
**Scope:** whole instance.  
**Parameters:**  
| parameter  | parameter type | description          |
| ---------- | -------------- | ------------------------ |
| label_name | string     | name of  vertex label    |
| primary_field | string  | primary field of vertex label |
| field_spec | list       | specification of a field |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, true]`, where true is specified only for optional fields.  
**Output:** If successful, it returns a success message.  
**Example input:**  
```
CALL db.createVertexLabel('Person', 'id', 'id', 'int64', false, 'name', 'string', true)
```  
**Example output:**  
```
Added label [Person]
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createVertexLabel(label_name, primary_field, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.alterLabelModFields(label_type, label_name, field_spec...)

Modifies the specified fields in the label.  
**Parameters:**  
| parameter  | parameter type | description           |
| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |
| label_name | string     | name of the label     |
| field_spec | list       | specification of a field  |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.The target field should exist.  
**Output:**  
| field_name | field_type | description               |
| ---------- | ---------- | --------------------------------- |
| affected   | integer    | number of vertexes/edges modified |  
**Example input:**  
```
CALL db.alterLabelModFields(
'vertex',
'new_label',
['birth_date', DATETIME, true],
['gender', BOOL, true])
```  
**Example output:**  
| affected |
| -------- |
| 1024     |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.alterLabelModFields(label_type, label_name, field_spec...)'}"
TuGraph DB的并发性能优化最初面临的主要问题是什么？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

在调研讨论的过程中我们发现，多位开发者在论坛提出其耗时甚至多于 Java target 数倍之多。因此，我们决定从问题和开源代码出发，来定位、解决问题。  
这是一个典型的并发程序优化问题，根据以往的程序优化经验，我们分步推进该问题的解决：  
（1）识别问题  
通过对程序运行时的性能数据进行收集和分析，我们找到了程序运行瓶颈所在，通过调用分析，初步将问题定位为数据竞争导致的并发问题。  
（2）深入阅读 Antlr4 开源代码  
接下来，我们对 Antlr4 的源代码进行仔细的阅读和理解，掌握其内部的结构和核心逻辑，找出了核心的数据结构和关键的调用链路。为我们破解性能难题和分析修改的正确性做好了准备。  
（3）梳理数据竞争链路  
根据上述分析，我们判断问题的症结极大概率是数据竞争造成的。形成数据竞争至少有两个条件：一是线程之间共享内存数据，二是至少存在两个线程去读写某个共享内存。  
进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为 DFA、ATN 等结构），拼接出了数据竞争的完整链路。  
（4）破解数据竞争问题  
数据竞争问题是多线程程序中常见而又复杂的问题，可以考虑通过破解多种竞争条件来解决。就本文问题来说，也存在多种破解方案选择，如何制定最优的解决方案是一项极具挑战的工作，主要难点有两个：  
（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。  
关于程序正确性的保证，我们通过双重验证来保证。首先在设计之初我们已经从源代码角度，推断出共享数据仍然是安全的，其次我们也设计了实验对此进行了验证，验证结果与我们的分析一致' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='性能优先

1.简介

TuGraph目前是世界上最快的图数据库，在图数据库标准评测LDBC SNB Interactive位居榜首（2023.3）。TuGraph的设计基于性能优先，致力于打造高性能的单机图数据库。该文档是TuGraph基于性能优先在存储层的核心设计。' metadata={'Header 1': '性能优先', 'Header 2': '1.简介'}","page_content='功能概览

4.核心功能

4.5 数据预热

TuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.5 数据预热'}"
C++客户端中实例化单节点client对象需要哪些参数？,"page_content='C++客户端

2.使用示例

2.1.实例化client对象

引入依赖并实例化  
#### 2.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
``` C++
RpcClient client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```  
#### 2.1.2.实例化HA集群直接连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化
``` C++
RpcClient client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 2.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化。
```java
std::vector<std::string> urls = {""189.33.97.23:9091"", ""189.33.97.24:9091"", ""189.33.97.25:9091""};
TuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, ""admin"", ""73@TuGraph"");
```
```
RpcClient(std::vector<std::string>& urls, std::string user, std::string password)
@param urls: tugraph host list
@param user: login user name
@param password: login password
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='Python客户端

3.RPC Client

3.1.实例化client对象

#### 3.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, url: str, user: str, password: str)
```  
#### 3.1.2.实例化HA集群直连连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, url: str, user: str, password: str)
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 3.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化
```python
client = liblgraph_client_python.client([""189.33.97.23:9091"",""189.33.97.24:9091"", ""189.33.97.25:9091""], ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, urls: list, user: str, password: str)
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.1.实例化client对象'}","page_content='Java客户端

2.使用示例

2.1.实例化client对象

添加maven依赖  
```xml
<dependency>
<groupId>com.antgroup.tugraph</groupId>
<artifactId>tugraph-db-java-rpc-client</artifactId>
<version>1.4.1</version>
</dependency>
```  
引入依赖
```java
import com.antgroup.tugraph.TuGraphDbRpcClient;
```  
#### 2.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
```java
TuGraphDbRpcClient client = new TuGraphDbRpcClient(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
public TuGraphDbRpcClient(String url, String user, String pass)
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```  
#### 2.1.2.实例化HA集群直连连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。
```java
TuGraphDbRpcClient client = new TuGraphDbRpcClient(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
public TuGraphDbRpcClient(String url, String user, String pass)
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 2.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化
```java
List<String> urls = new ArrayList<>();
urls.add(""189.33.97.23:9091"");
urls.add(""189.33.97.24:9091"");
urls.add(""189.33.97.25:9091"");
TuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, ""admin"", ""73@TuGraph"");
```
```
public TuGraphDbRpcClient(List<String> urls, String user, String password)
@param urls: tugraph host list
@param user: login user name
@param password: login password
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}"
TuGraph-DB查询引擎目前支持使用哪种查询语言，并计划在未来支持哪种查询语言？,"page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='功能概览

4.核心功能

4.1.查询语言

TuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。
- __支持Procedure嵌入__  
- __可插拔优化框架__ 各类优化功能  
- __可扩展安全性检查框架__ 对于cypher进行' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.1.查询语言'}","page_content='技术规划

2. 已完成功能

TuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。  
| 版本号   | 功能                               | 时间         |
|-------|----------------------------------|------------|
| 3.3.0 | 开源初版                             | 2022.9.1   |
| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |
| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |
| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |
| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |
| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}"
DeleteProcedure 函数接受什么类型的参数，并命名它们？,"page_content='C++客户端

2.使用示例

2.10.删除存储过程

```C++
std::string str;
bool ret = client.DeleteProcedure(str, ""CPP"", ""test_plugin1"");
```
```
bool DeleteProcedure(std::string& result, const std::string& procedure_type,
const std::string& procedure_name, const std::string& graph = ""default"");
@param [out] result              The result.
@param [in]  procedure_type      the procedure type, currently supported CPP and PY.
@param [in]  procedure_name      procedure name.
@param [in]  graph               (Optional) the graph to query.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Java客户端

2.使用示例

2.10.删除存储过程

```java
String result = client.deleteProcedure(""CPP"", ""sortstr"", ""default"");
log.info(""loadProcedure : "" + result);
```
```
@param procedureType: the procedure type, currently supported CPP and PY
@param procedureName: procedure name
@param graph: the graph to query.
@return: the result of procedure execution
public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Python客户端

3.RPC Client

3.10.删除存储过程

```python
ret, res = client.deleteProcedure(""CPP"", ""sortstr"", ""default"")
```
```
deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.10.删除存储过程'}"
如果要在FrontierTraversal中并行执行遍历，事务的哪种模式必须被选用？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

图数据库中十分常见的一大类分析是基于一个或多个点出发，逐层地拓展并访问邻居。
尽管这类分析也可以使用 Cypher 完成，但是当访问的层数较深时，其性能会受到串行解释执行的限制。
使用 C++ Core API 编写存储过程尽管避免了解释执行，但依然受限于单个线程的处理能力。
为了让用户能够方便地通过并行处理的方式加速这一类应用场景，我们基于 C++ OLAP API 封装了一个 Traversal 框架，用户可以直接使用其中的 FrontierTraversal 和 PathTraversal 类来完成这种逐层遍历的分析任务，具体的使用方法可以参考相应的 C++ API 文档（lgraph_traversal.h）。  
```c
ParallelVector<size_t> FindVertices(
GraphDB & db,
Transaction & txn,
std::function<bool(VertexIterator &)> filter,
bool parallel = false
);
```  
该方法可用于找到所有满足条件（filter 返回 true）的点，当 parallel 为 true 时则会并行该查找过程。  
```c
template <typename VertexData>
ParallelVector<VertexData> ExtractVertexData(
GraphDB & db,
Transaction & txn,
ParallelVector<size_t> & frontier,
std::function<void(VertexIterator &, VertexData &)> extract,
bool parallel = false
);
```  
该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。  
FrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。
两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。
选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。  
```c
void SetFrontier(size_t root_vid);
void SetFrontier(ParallelVector<size_t> & root_vids);
void SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter);
```  
两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。  
两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,
std::function<bool(VertexIterator &)> out_neighbour_filter = nullptr
);
void ExpandInEdges(
std::function<bool(InEdgeIterator &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
void ExpandEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,
std::function<bool(InEdgeIterator &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
```  
上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。  
```c
ParallelVector<size_t> & GetFrontier();
```  
当前点集合的扩展结束后，新的点集合可以通过上述方法取得。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &, Path &, IteratorHelper &)> out_edge_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> out_neighbour_filter = nullptr
);
void ExpandInEdges(
std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter = nullptr
);
void ExpandEdges(
std::function<bool(OutEdgeIterator &, Path &, IteratorHelper &)> out_edge_filter = nullptr,
std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter = nullptr
);
```  
PathTraversal 的三种遍历方式与 FrontierTraversal 类似，只是用户自定义的过滤函数中增加了两个参数，其中：Path 包含了到新扩展的这条边之前的路径，IteratorHelper 可用于将路径中的点/边转为数据库中对应的迭代器，相关文档可参考对应的 C++ API 文档。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='静态图

接口

| API | 接口说明 | 入参说明 |
| --- | --- | --- |
| void open(VertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext) | vertexCentric function进行open操作 | vertexCentricFuncContext：K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型，M表示图遍历中定义的消息类型，R表示遍历结果类型。 |
| void init(ITraversalRequest traversalRequest) | 图遍历初始化接口 | traversalRequest：图遍历触发点，其中K表示vertex id的类型。 |
| void compute(K vertexId, Iterator messageIterator) | 图遍历接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。<br>messageIterator：图遍历过程中所有发送给当前vertex的消息，其中M表示遍历迭代过程中定义的发送消息类型。 |  
- 详细接口  
```java
public interface VertexCentricTraversalFunction<K, VV, EV, M, R> extends VertexCentricFunction<K, VV
, EV, M> {

void open(VertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext);
/** 图遍历算法初始化方法 */
void init(ITraversalRequest<K> traversalRequest);
/** 实现图遍历逻辑 */
void compute(K vertexId, Iterator<M> messageIterator);

void finish();

void close();

interface VertexCentricTraversalFuncContext<K, VV, EV, M, R> extends VertexCentricFuncContext<K,
VV, EV, M> {
/** 获取图遍历结果 */
void takeResponse(ITraversalResponse<R> response);
/** 获取开始图遍历的点 */
TraversalVertexQuery<K, VV> vertex();
/** 获取开始图遍历的边 */
TraversalEdgeQuery<K, EV> edges();

void broadcast(IGraphMessage<K, M> message);
}

interface TraversalVertexQuery<K, VV> extends VertexQuery<K, VV> {
/** 获取图遍历中点的迭代器 */
Iterator<K> loadIdIterator();
}

interface TraversalEdgeQuery<K, EV> extends EdgeQuery<K, EV> {
/** 通过指定的点id，获取对应的图遍历起点 */
TraversalEdgeQuery<K, EV> withId(K vertexId);
}
}
```' metadata={'Header 1': '静态图', 'Header 2': '接口'}","page_content='动态图

接口

| API | 接口说明 | 入参说明 |
| --- | --- | --- |
| void open(IncVertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext) | vertexCentricFunction进行open操作 | vertexCentricFuncContext：K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型，M表示图遍历中定义的消息类型，R表示遍历结果类型。 |
| void init(ITraversalRequest traversalRequest) | 图遍历初始化接口 | traversalRequest：图遍历触发点，其中K表示vertex id的类型。 |
| void evolve(K vertexId, TemporaryGraph<K, VV, EV> temporaryGraph) | 首轮计算对增量图实现处理逻辑 | vertexId：当前计算点的id，其中K表示vertex id的类型。<br>temporaryGraph：临时增量图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。 |
| void compute(K vertexId, Iterator messageIterator) | 图遍历接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。<br>messageIterator：图遍历过程中所有发送给当前vertex的消息，其中M表示遍历迭代过程中定义的发送消息类型。 |
| void finish(K vertexId, MutableGraph<K, VV, EV> mutableGraph) | 图遍历完成接口 | vertexId：当前计算点的id，其中K表示vertex id的类型。<br>mutableGraph：可变图，其中K表示vertexId的类型，VV表示vertex value类型，EV表示edge value类型。 |  
- 详细接口  
```java
public interface IncVertexCentricTraversalFunction<K, VV, EV, M, R> extends IncVertexCentricFunction<K, VV
, EV, M> {

void open(IncVertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext);

void init(ITraversalRequest<K> traversalRequest);

void evolve(K vertexId, TemporaryGraph<K, VV, EV> temporaryGraph);

void compute(K vertexId, Iterator<M> messageIterator);

void finish(K vertexId, MutableGraph<K, VV, EV> mutableGraph);

interface IncVertexCentricTraversalFuncContext<K, VV, EV, M, R> extends IncGraphContext<K, VV, EV,
M> {
/** 激活遍历起点用以下一轮迭代使用 */
void activeRequest(ITraversalRequest<K> request);
/** 收集遍历结果 */
void takeResponse(ITraversalResponse<R> response);

void broadcast(IGraphMessage<K, M> message);
/** 获取历史图数据 */
TraversalHistoricalGraph<K, VV, EV> getHistoricalGraph();
}


interface TraversalHistoricalGraph<K, VV, EV>  extends HistoricalGraph<K, VV, EV> {
/** 获取指定版本快照 */
TraversalGraphSnapShot<K, VV, EV> getSnapShot(long version);
}

interface TraversalGraphSnapShot<K, VV, EV> extends GraphSnapShot<K, VV, EV> {
/** 获取开始图遍历的点 */
TraversalVertexQuery<K, VV> vertex();
/** 获取开始图遍历的边 */
TraversalEdgeQuery<K, EV> edges();
}
}
```' metadata={'Header 1': '动态图', 'Header 2': '接口'}"
RpcSingleClient 构造函数需要哪些参数?,"page_content='Python客户端

3.RPC Client

3.1.实例化client对象

#### 3.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, url: str, user: str, password: str)
```  
#### 3.1.2.实例化HA集群直连连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, url: str, user: str, password: str)
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 3.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化
```python
client = liblgraph_client_python.client([""189.33.97.23:9091"",""189.33.97.24:9091"", ""189.33.97.25:9091""], ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, urls: list, user: str, password: str)
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.1.实例化client对象'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

引入依赖并实例化  
#### 2.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
``` C++
RpcClient client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```  
#### 2.1.2.实例化HA集群直接连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化
``` C++
RpcClient client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"");
```
```
RpcClient(const std::string& url, const std::string& user, const std::string& password);
@param url: tugraph host looks like ip:port
@param user: login user name
@param password: login password
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 2.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化。
```java
std::vector<std::string> urls = {""189.33.97.23:9091"", ""189.33.97.24:9091"", ""189.33.97.25:9091""};
TuGraphDbRpcClient client = new TuGraphDbRpcClient(urls, ""admin"", ""73@TuGraph"");
```
```
RpcClient(std::vector<std::string>& urls, std::string user, std::string password)
@param urls: tugraph host list
@param user: login user name
@param password: login password
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}","page_content='RPC API

5.存储过程

5.1.加载存储过程

加载存储过程的请求包含以下参数：
- name: 必要参数，存储过程名称
- read_only: 必要参数，是否只读
- code: 必要参数，存储过程文件读入生成的ByteString
- desc: 可选参数，存储过程描述
- code_type: 可选参数，存储过程代码类型，PY、SO、CPP、ZIP四者之一  
以C++为例，用户加载存储过程的方式如下所示：
```C++
std::string content;
if (!FieldSpecSerializer::FileReader(source_file, content)) {
std::swap(content, result);
return false;
}
LGraphRequest req;
req.set_is_write_op(true);
lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();
pluginRequest->set_graph(graph);
pluginRequest->set_type(procedure_type == ""CPP"" ? lgraph::PluginRequest::CPP
: lgraph::PluginRequest::PYTHON);
pluginRequest->set_version(version);
lgraph::LoadPluginRequest* loadPluginRequest = pluginRequest->mutable_load_plugin_request();
loadPluginRequest->set_code_type([](const std::string& type) {
std::unordered_map<std::string, lgraph::LoadPluginRequest_CodeType> um{
{""SO"", lgraph::LoadPluginRequest::SO},
{""PY"", lgraph::LoadPluginRequest::PY},
{""ZIP"", lgraph::LoadPluginRequest::ZIP},
{""CPP"", lgraph::LoadPluginRequest::CPP}};
return um[type];
}(code_type));
loadPluginRequest->set_name(procedure_name);
loadPluginRequest->set_desc(procedure_description);
loadPluginRequest->set_read_only(read_only);
loadPluginRequest->set_code(content);
cntl->Reset();
cntl->request_attachment().append(FLAGS_attachment);
req.set_client_version(server_version);
req.set_token(token);
LGraphRPCService_Stub stub(channel.get());
LGraphResponse res;
stub.HandleRequest(cntl.get(), &req, &res, nullptr);
if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
server_version = std::max(server_version, res.server_version());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
```
加载存储过程的响应不包含参数，如果加载失败则抛出BadInput异常' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.1.加载存储过程'}"
TuGraph“中的expire_time默认设置是？,"page_content='场景：流浪地球

2.使用说明

前置条件：TuGraph已安装' metadata={'Header 1': '场景：流浪地球', 'Header 2': '2.使用说明'}","page_content='技术规划

2. 已完成功能

TuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。  
| 版本号   | 功能                               | 时间         |
|-------|----------------------------------|------------|
| 3.3.0 | 开源初版                             | 2022.9.1   |
| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |
| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |
| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |
| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |
| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}","page_content='Token使用说明

2. Token有效期

2.4. Token有效期修改

为了方便开发者自行开发，TuGraph提供了两种方式修改有效期，均需要admin权限。  
* 通过接口调用设置。涉及有效期修改的接口`update_token_time`和有效期查询接口`get_token_time`。
具体可查询[REST接口文档](../7.client-tools/9.restful-api-legacy.md)。  
* 通过启动参数设置。server端启动时，添加参数`-unlimited_token 1` 参数可以设置为无期限。可参考[服务运行文档](../5.installation&running/7.tugraph-running.md)。' metadata={'Header 1': 'Token使用说明', 'Header 2': '2. Token有效期', 'Header 3': '2.4. Token有效期修改'}"
TuGraph图学习模块中包括哪四种采样算子？,"page_content='Learn Tutorial

6. 采样算子及编译

TuGraph在cython层实现了一种获取全图数据的算子及4种采样算子，具体如下：' metadata={'Header 1': 'Learn Tutorial', 'Header 2': '6. 采样算子及编译'}","page_content='使用 TuGraph 图学习模块进行点分类

5. 编译采样算子

采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：
在tugraph-db/build文件夹下执行
`make -j2`  
或在tugraph-db/learn/procedures文件夹下执行
`python3 setup.py build_ext -i`  
```python
from lgraph_db_python import *  # 导入tugraph-db的python接口模块
import importlib  # 导入importlib模块
getdb = importlib.import_module(""getdb"")  #获取getdb算子
getdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子
```  
如代码所示，得到算子so文件后，import 导入使用。' metadata={'Header 1': '使用 TuGraph 图学习模块进行点分类', 'Header 2': '5. 编译采样算子'}","page_content='Sampling API

3. 图采样算子介绍

图采样算子在cython层实现，用于对输入的图进行采样处理，生成的NodeInfo用于保存feature属性、label属性等点信息，EdgeInfo用于保存边信息，这些元数据信息可以被用于特征抽取、网络嵌入等任务中。目前TuGraph图学习模块支持GetDB、NeighborSampling、EdgeSampling、RandomWalkSampling、NegativeSampling五种采样算子。' metadata={'Header 1': 'Sampling API', 'Header 2': '3. 图采样算子介绍'}"
当执行UpsertEdge操作时，根据提供的参数是否存在于现有边，返回值将是什么？,"page_content='业务开发指南

导入数据

批量upsert边数据

如果两点之间不存在某条类型的边就插入，如果存在就更新该边的属性，也就是两点之间同类型的边只能有一条。  
第四个参数是一个`list`类型，每个数组里面的元素是个`map`类型，每个`map`里面是：边的起点类型主键字段和对应的值、边的终点类型主键字段和对应的值、边类型自身的属性字段和值。每个map里面至少有两个元素。  
第二个参数和第三个参数是为第四个参数服务的。分别说明了起点和终点的类型是什么，以及第四个参数中那个字段代表起点主键字段值，那个字段代表终点主键字段值。  
注：第二个参数和第三个参数中配置的起点和终点的主键字段并不是起点和终点schema中的主键字段名，只是起一个占位和区别的作用，方便识别第四个参数中哪个字段代表起点和终点的主键字段。  
推荐使用driver里面的参数化特性，避免自己构造语句。
```
CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据'}","page_content='业务开发指南

导入数据

批量upsert边数据-根据边的属性确定唯一

上面描述的upsert逻辑是两点之间同类型的边只能有一条，如果要求两点之间同类型的边可以有多条，并且根据边上的某个属性来确定唯一，需要在原来的基础上多加一个字段，如下：
```
CALL db.upsertEdge('edge1',{type:'node1',key:'node1_id'}, {type:'node2',key:'node2_id'}, [{node1_id:1,node2_id:2,score:10},{node1_id:3,node2_id:4,score:20}], 'score')
```
在最后多了一个字段`score`, 逻辑变成：如果两点之间不存在一条`edge1`类型的边，并且`score`值等于某个值，就插入；否则就更新改边的属性。
边上的`score`字段需要提前加上一个特殊的`pair unique`索引，如下：
```
CALL db.addEdgeIndex('edge1', 'score', false, true)
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert边数据-根据边的属性确定唯一'}","page_content='业务开发指南

导入数据

批量upsert点数据

如果不存在就插入点，如果存在就更新点的属性，根据点的主键字段值判断是否存在。  
第二个参数是一个`list`类型，每个`list`里面的元素是个`map`类型，每个`map`里面是点的字段和对应的值。  
推荐使用driver里面的参数化特性，第二个参数直接传入一个 `list`结构体，避免自己构造语句。
```
CALL db.upsertVertex('node1', [{id:1, name:'name1'},{id:2, name:'name2'}])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '导入数据', 'Header 3': '批量upsert点数据'}"
ANTLR4支持生成哪些目标语言的解析器？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

关于 Antlr4

Antlr4 是一款备受欢迎的开源解析器生成器，能够根据语法规则快速生成自定义解析器。其支持 LL(\*)解析，拥有更强大的错误处理能力和更快的解析速度。不仅如此，Antlr4 还支持 Java、Python、C++、JavaScript、Go 等 10 种目标语言，广泛应用于多种开发语言生态中。简单易用的 API 和文档使得开发人员能够快速上手。无论是编程语言、数据格式、编译器还是解释器等领域，Antlr4 都发挥着重要作用。  
著名的开源项目如 Apache Spark、Eclipse IDE 和 MongoDB 等都选择了 Antlr4。 对于语言工具开发者而言，Antlr4 是不可或缺的工具，能大幅提高开发效率和代码质量。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '关于 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

当 TuGraph 遇见 Antlr4

ISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4 作为一种强大的解析器生成器，成为了蚂蚁图数据库 TuGraph 生成 GQL 解释器的理想选择。Antlr4 能够帮助团队更快、更准确地构建图数据库的查询语言，从而提高产品性能和用户体验。  
然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target 的并发性能不足以支持所需的超高并发 GQL 请求。经过调研并与 Antlr 开源社区讨论，我们发现\*\*并发性能这个问题普遍存在，并且在过去 5 年中持续困扰着 C++生态的开发者。\*\*我们决定解决这个问题。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '当 TuGraph 遇见 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

贡献和成果

对Antlr4的优化的效果十分显著，32 线程的并发性能提升超过 18 倍 。考虑到实际生产服务器性能远高于测试机型，实际的性能提升效果将比测试结果更高， 优化后 GQL 解析能力已能完全满足企业业务的需要。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '贡献和成果'}"
如果对DateTime对象添加超出其范围的微秒数会发生什么？,"page_content='Cypher API

5.附录2. 内置procedures列表

* db.subgraph()

**Scope:** whole instance.  
**Parameters:**  
| parameter  | parameter type | description                                                           |
| ---------- | -------------- | --------------------------------------------------------------------- |
| vids       | list           | list of vertex id                                                     |  
**Output:**  
Get a json containing all the properties of nodes and relationships.  
**Example input:**  
```
CALL db.subgraph([3937,4126,4066,4010])
```  
**Example output**  
| subgraph |
| -------- |
| {""nodes"":[{""identity"":3937,""label"":""movie"",""properties"":{""duration"":136,""id"":1,""poster_image"":""http://image.tmdb.org/t/p/w185/gynBNzwyaHKtXqlEKKLioNkjKgN.jpg"",""rated"":""R"",""summary"":""Thomas A. Anderson is a man living two lives. By day he is an average computer programmer and by night a malevolent hacker known as Neo who finds himself targeted by the police when he is contacted by Morpheus a legendary computer hacker who reveals the shocking truth about our reality."",""tagline"":""Welcome to the Real World."",""title"":""The Matrix""}},{""identity"":4010,""label"":""user"",""properties"":{""id"":44,""login"":""Howard""}},{""identity"":4066,""label"":""user"",""properties"":{""id"":202,""login"":""Enoch""}},{""identity"":4126,""label"":""user"",""properties"":{""id"":464,""login"":""Wilburn""}}],""relationships"":[{""dst"":4126,""forward"":true,""identity"":0,""label"":""is_friend"",""label_id"":3,""src"":4010,""temporal_id"":0},{""dst"":4010,""forward"":true,""identity"":0,""label"":""is_friend"",""label_id"":3,""src"":4066,""temporal_id"":0},{""dst"":4066,""forward"":true,""identity"":0,""label"":""is_friend"",""label_id"":3,""src"":4126,""temporal_id"":0}]} |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.subgraph()'}","page_content='业务开发指南

点类型操作

点类型添加字段

>该操作会同步变更所有该类型点的属性数据，数据量大的时候，有时间消耗。  
如下例子，对于点类型`node1`，一次添加了两个字段：`field1`，字符串类型，可选，默认值是 `null`; `field2`，`int64`类型，必选，默认值是0.
```
CALL db.alterLabelAddFields('vertex', 'node1', ['field1', string, null ,true], ['field2', int64, 0, false])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '点类型操作', 'Header 3': '点类型添加字段'}","page_content='GeaFlow支持以下日期函数：
* [from_unixtime](#from_unixtime)
* [from_unixtime_millis](#from_unixtime_millis)
* [unix_timestamp](#unix_timestamp)
* [unix_timestamp_millis](#unix_timestamp_millis)
* [isdate](#isdate)
* [now](#now)
* [day](#day)
* [weekday](#weekday)
* [lastday](#lastday)
* [day_of_month](#day_of_month)
* [week_of_year](#week_of_year)
* [date_add](#date_add)
* [date_sub](#date_sub)
* [date_diff](#date_diff)
* [add_months](#add_months)
* [date_format](#date_format)
* [date_part](#date_part)
* [date_trunc](#date_trunc)'"
VertexLockGuard是什么？,"page_content='OlapBase API

7. 图类OlapBase

7.3 锁机制

TuGraph实现了一对锁机制，来控制程序对于点数据的访存权限。分别是：  
- `void AcquireVertexLock(size_t vid)`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存
- `void ReleaseVertexLock(size_t vid)`：对点vid解锁，所有线程均可访存该锁对应的点数据
- `VertexLockGuard GuardVertexLock(size_t vid)`：在对vid操作时，对点vid加锁，退出作用域时时自动释放锁' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.3 锁机制'}","page_content='运维监控

1.设计思路

可视化监控并不是TuGraph自身不可或缺的一部分，因此在设计时将可视化监控作为TuGraph周边生态中的一个应用，来减少和TuGraph数据库的耦合度，以及对于TuGraph自身的影响。TuGraph可视化监控采用目前最火热的开源解决方案，TuGraph Monitor + Prometheus + Grafana来实现。其中TuGraph Monitor作为TuGraph服务的客户端，通过TCP链接向TuGraph服务发起Procedure请求，TuGraph服务在接收到请求后收集自身所在机器的cpu，memory，disk，io，以及请求数量等指标的统计结果进行响应。TuGraph Monitor在接收到TuGraph响应的指标数据后，将数据包装成prometheus需要的格式，保存在内存中，等待Prometheus服务通过http请求获取。Prometheus服务会定期通过http请求从TuGraph Monitor获取封装好的请求数据，按照获取的时间保存在自己的时序数据库中。Grafana可以根据用户的配置，从Prometheus处获取某个时间段内的统计数据，并在web界面上绘制浅显易懂的图形来展示最终结果。整个请求链路中，都采用了主动获取，即PULL的模型，好处之一是它能最大限度的避免数据生产者和数据消费者之间的耦合度，使得开发更简单，好处之二是数据生产者不需要考虑数据消费者的数据处理能力，即使某个消费者的数据处理能力较弱，也不会因为生产者生产数据过快而压垮消费者。主动拉取模型的不足之处在于数据的实时性不够，但在这个场景中，数据并没有很高的实时性要求。' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路'}","page_content='运维监控

1.设计思路

1.3.Prometheus

Prometheus是一个开源的监控平台，并配备有专属的时序数据库，它会定期通过http请求从TuGraph Monitor服务获取统计指标，并保存在自己的时序数据库中。详细信息请参考官网: [https://prometheus.io/docs/introduction/first_steps](https://prometheus.io/docs/introduction/first_steps)' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路', 'Header 3': '1.3.Prometheus'}"
value pack时的null array的具体含义是什么？,"page_content='RESTful API Legacy

6.Deprecated

6.3.服务器状态

#### 6.3.1.修改服务器配置  
修改服务器配置，配置修改后立即生效，并将影响所有服务器。这些配置的优先级高于配置文件以及命令行参数。  
- **URI**: `/config`
- **METHOD**: PUT
- **REQUEST**:  
请求为一个字典，使用 `{""opt1"":v1}` 可以将名为`opt1`的配置修改为`v1`。  
| 配置名               | 说明                   | 值类型 |
| -------------------- | ---------------------- | ------ |
| OPT_DB_ASYNC         | 是否启用异步模式       | 布尔值 |
| OPT_TXN_OPTIMISTIC   | 是否默认使用乐观事务锁 | 布尔值 |
| OPT_AUDIT_LOG_ENABLE | 是否启用审计日志       | 布尔值 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• PUT http://localhost:7070/config
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""OPT_DB_ASYNC"": true,
""OPT_AUDIT_LOG_ENABLE"": false
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.3.2.当前服务器状态  
- **URI**: `/info`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| lgraph_version | 服务器版本号 | 字符串 |
| git_branch | 服务器代码分支 | 字符串 |
| git_commit | 服务器代码版本 | 字符串 |
| web_commit | 前端码版本 | 字符串 |
| cpp_id | CPP 编译器 ID | 字符串 |
| cpp_version | CPP 编译器版本 | 字符串 |
| python_version | PYTHON 版本 | 字符串 |
| node | 点 uri | 字符串 |
| relationship | 边 uri | 字符串 |
| cpu | cpu 信息 | 字典，格式参见[服务器 CPU 状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E7%8A%B6%E6%80%81) |
| disk | 硬盘 IO 信息 | 字典，格式参见[服务器硬盘状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E7%9B%98%E7%8A%B6%E6%80%81) |
| memory | 内存信息 | 字典，格式参见[服务器内存状态](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81) |
| db_space | 图数据库占用空间 | 字典，格式参见[图数据库占用空间](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4) |
| db_config | 图数据库配置信息 | 字典，格式参见[图数据库配置信息](#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF) |
| up_time | 数据库在线时长（秒） | 整型 |  
**Example request.**  
```
• GET http://localhost:7070/info
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""lgraph_version"": ""1.2.0"",
""git_branch"": ""master"",
""git_commit"": ""9e2977d"",
""web_commit"": ""1e2823d"",
""cpu_id"": ""GUN"",
""cpu_version"": ""4.8.5"",
""python_version"": ""3.2"",
""node"": ""/node"",
""relationship"": ""/relationship"",
""cpu"": {
""self"": 25,
""server"": 35,
""unit"": ""%""
},
""disk"": {
""read"": 2000,
""write"": 2000,
""unit"": ""B/s""
},
""memory"": {
""self"": 25016,
""server_avail"": 46865636,
""server_total"": 65860552,
""unit"": ""KB""
},
""db_space"": {
""space"": 57344,
""unit"": ""B""
},
""db_config"": {
""db_async"": false,
""disable_auth"": false,
""enable_ha"": false,
...
},
""up_time"": 3235
}
```  
#### 6.3.3.服务器 CPU 状态  
- **URI**: `/info/cpu`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| self | 图数据库应用程序 CPU 使用率 | 整型 |
| server | 服务器 CPU 使用率 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/cpu
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""self"": 25,
""server"": 35,
""unit"": ""%""
}
```  
#### 6.3.4.服务器硬盘状态  
- **URI**: `/info/disk`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| read | 服务器硬盘读速率 | 整型 |
| write | 服务器硬盘写速率 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/disk
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""read"": 2000,
""write"": 2000,
""unit"": ""B/s""
}
```  
#### 6.3.5.服务器内存状态  
- **URI**: `/info/memory`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| self | 图数据库应用程序内存使用量 | 整型 |
| server_avail | 服务器可用内存 | 整型 |
| server_total | 服务器总内存 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/memory
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""self"": 25016,
""server_avail"": 46865636,
""server_total"": 65860552,
""unit"": ""KB""
}
```  
#### 6.3.6.图数据库占用空间  
- **URI**: `/info/db_space`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| space | 图数据库占用空间 | 整型 |
| disk_avail | 图数据库可用空间 | 整型 |
| disk_total | 服务器硬盘总空间 | 整型 |
| unit | 单位 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/db_space
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""disk_avail""::360074579968,
""disk_total""::984373800960,
""space"": 57344,
""unit"": ""B""
}
```  
#### 6.3.7.图数据库配置信息  
- **URI**: `/info/db_config`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| db_async | 图数据库工作模式（同步或异步） | 布尔值 |
| disable_auth | 是否禁用身份验证 | 布尔值 |
| enable_ha | 是否启用高可用模式 | 布尔值 |
| enable_rpc | 是否启用 RPC 服务器 | 布尔值 |
| bind_host | REST 服务器的主机 | 字符串 |
| enable_audit_log | 是否启用日志审计 | 布尔值 |
| port | REST 服务器的端口 | 整型 |
| rpc_port | RPC 服务器的端口 | 整型 |
| optimistic_txn | 是否默认使用乐观事务锁 | 布尔值 |
| thread_limit | 图数据库应用程序的可用线程数 | 整型 |
| enable_ssl | 是否使用 SSL 进行身份验证 | 布尔值 |
| verbose | 输出的详细程度 | 整型 |  
**Example request.**  
```
• GET http://localhost:7070/info/db_config
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""db_async"":false,
""disable_auth"":false,
""enable_ha"":false,
""enable_rpc"":false,
""bind_host"":""127.0.0.1"",
""enable_audit_log"":false,
""port"":7070,
""optimistic_txn"":false,
""rpc_port"":9091,
""thread_limit"":0,
""enable_ssl"":false,
""verbose"":2
}
```  
#### 6.3.8.高可用服务器列表  
_(仅在高可用模式下有效)_  
- **URI**: `/info/peers`
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回一个服务器信息列表，其中每个服务器信息格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| rpc_address | 服务器 RPC 地址 | 字符串 |
| rest_address | 服务器 REST 地址 | 字符串 |
| state | 服务器状态 | 字符串 |  
其中服务器状态可为 `MASTER`,`SLAVE`,`OFFLINE`。  
**Example request.**  
```
• GET http://localhost:7070/info/peers
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
[
{
""rest_address"":""192.168.1.22:17071"",
""rpc_address"":""192.168.1.22:19091"",
""state"":""MASTER""
},
{
""rest_address"":""192.168.1.22:17072"",
""rpc_address"":""192.168.1.22:19092"",
""state"":""SLAVE""
}
]
}
```  
#### 6.3.9.当前 Leader 信息  
_(仅在高可用模式下有效)_  
- **URI**: `/info/leader`
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前 leader 服务器信息，格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| rpc_address | 服务器 RPC 地址 | 字符串 |
| rest_address | 服务器 REST 地址 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/leader
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""rest_address"":""192.168.1.22:17071"",
""rpc_address"":""192.168.1.22:19091""
}
```  
#### 6.3.10.服务器统计信息  
- **URI**: `/info/statistics`
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回当前服务器统计信息，格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| requests/second | 每秒处理的请求数量 | 浮点型 |
| writes/second | 每秒处理的写请求数量 | 浮点型 |
| running_tasks | 正在执行的请求数量 | 整型 |
| failure_rate | 请求失败率 | 浮点型 |  
**Example request.**  
```
• GET http://localhost:7070/info/statistics
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""failure_rate"": 2.3,
""requests/second"": 122.3,
""running_tasks"": 10,
""writes/second"": 12.4
}
```  
#### 6.3.11.审计日志信息  
- **URI**: `/info/log/?begin_time={begin_time}&end_time={end_time}&user={user}&num_log={num_log}&descending_order={descending_order}`
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| begin_time | 查询日志的起始时间(必填，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |
| end_time | 查询日志的结束时间(默认为当前时间，格式为 YYYY-mm-dd HH:MM:SS) | 时间戳 |
| user | 查询日志的操作者(管理员可查询所有用户的日志，普通用户只能查询本人日志) | 字符串 |
| num_log | 查询日志的数量(默认为 100) | 整型 |
| descending_order | 查询结果是否降序输出(默认为 true) | 布尔值 |  
- **METHOD**: GET
- **RESPONSE**: 如果成功，则返回 200 代码，并返回审计日志列表，其中每个元素是一条操作日志，其格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| index | 该操作的索引值 | 整型 |
| begin_time | 该操作的开始时间 | 字符串 |
| end_time | 该操作的结束时间 | 字符串 |
| user | 该操作的发起者 | 字符串 |
| graph | 该操作的图 | 字符串 |
| type | 该操作的类型 | 字符串 |
| read_write | 该操作为读操作或者写操作 | 字符串 |
| success | 该操作是否成功 | 布尔值 |
| content | 该操作的简要内容 | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/info/log/?begin_time=2020-02-17%2015:00:00&end_time=2020-02-20%2012:00:00&user=admin&num_log=100&descending_order=false
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
[
{
""begin_time"": ""2020-02-17 15:27:15"",
""content"": ""post /login    Successful"",
""end_time"": ""2020-02-17 15:27:15"",
""graph"": """",
""index"": 1,
""read_write"": ""read"",
""success"": true,
""type"": ""Security"",
""user"":""admin""
},
{
""begin_time"": ""2020-02-17 15:27:15"",
""content"": ""Load plugin : `echo`    Successful"",
""end_time"": ""2020-02-17 15:27:15"",
""graph"": ""default"",
""index"": 2,
""read_write"": ""write"",
""success"": true,
""type"": ""Plugin"",
""user"": ""admin""
},
...
]
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.3.服务器状态'}","page_content='RESTful API Legacy

6.Deprecated

6.9.索引

URI 格式为  
```
http://{host}:{port}/db/{graph_name}/index/{label}/{field}
```  
提供索引操作，接受 GET/POST 请求。  
#### 6.9.1.创建索引  
该操作会启动一个创建索引的后台任务，用户可以通过列出该 Label 相关的所有索引来检查新建索引的状态。  
- **URI**: `/db/{graph_name}/index`
- **METHOD**: POST
- **REQUEST**:  
| 域名    | 说明     | 类型                                  |
|-------|--------|-------------------------------------|
| label | Label 名 | 字符串                                 |
| field | 域名     | 字符串                                 |
| type  | 索引类型   | int类型，0表示非唯一索引，1表示全局唯一索引，2表示两点间唯一索引 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/db/graph1/index
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""label"": ""Person"",
""field"": ""birthyear"",
""is_unique"" : false
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.9.2.列出所有索引  
- **URI**: `/db/{graph_name}/index`
- **METHOD**: GET
- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。  
**Example request.**  
```
• GET http://localhost:7070/db/graph1/index
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
[
{
""field"": ""name"",
""label"": ""City"",
""is_unique"": false
},
{
""field"": ""title"",
""label"": ""Film"",
""is_unique"": false
},
{
""field"": ""name"",
""label"": ""Person"",
""is_unique"": true
},
{
""label"": ""Person"",
""field"": ""age"",
""is_unique"": false
}
]
}
```  
#### 6.9.3.列出所有与某个 Label 相关的索引  
- **URI**: `/db/{graph_name}/index/{label}`
- **METHOD**: GET
- **RESPONSE**: 索引列表，其中每一个元素是一个索引描述，格式与[创建索引](#indexspec)时使用格式相同。  
**Example request.**  
```
• GET http://localhost:7070/db/graph1/index/Person
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
[
{
""label"": ""Person"",
""field"": ""name"",
""is_unique"": true
},
{
""label"": ""Person"",
""field"": ""age"",
""is_unique"": false
}
]
}
```  
#### 6.9.4.删除索引  
- **URI**: `/db/{graph_name}/index/{label}/{field}`
- **METHOD**: DELETE
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• DELETE http://localhost:7070/db/graph1/index/Person/name
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
```  
#### 6.9.5.根据索引获取点  
- **URI**: `/db/{graph_name}/index/{label}/?field={field}&value={value}`
- **METHOD**: GET
- **RESPONSE**: 点 vid 列表  
**Example request.**  
```
• GET http://localhost:7070/db/graph1/index/Person/?field=birthyear&value=1986
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
Output:
{
[
1,
8
]
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.9.索引'}","page_content='Geaflow支持以下逻辑运算：  
操作|描述
----------------------|------
boolean1 OR boolean2 | 如果boolean1为true或boolean2为true，则返回true。
boolean1 AND boolean2 | 仅在boolean1为true和boolean2为true时才返回true。
NOT boolean | 返回给定布尔变量的NOT操作的结果。
boolean IS FALSE | 如果布尔变量为false，则返回true。如果布尔变量是UNKNOWN，则返回false。
boolean IS NOT FALSE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回true。
boolean IS TRUE | 如果布尔变量为true，则返回true。如果布尔变量是UNKNOWN，则返回false。
boolean IS NOT TRUE | 如果布尔变量为false，则返回true。如果布尔变量是UNKNOWN，则返回true。
value1 = value2 | 如果value1等于value2，则返回true。
value1 <> value2 | 如果value1不等于value2，则返回true。
value1 > value2 | 如果value1大于value2，则返回true。
value1 >= value2 | 如果value1大于或等于value2，则返回true。
value1 < value2 | 如果value1小于value2，则返回true。
value1 <= value2 | 如果value1小于或等于value2，则返回true。
value IS NULL | 如果value为null，则返回true。
value IS NOT NULL | 如果value不为null，则返回true。
value1 IS DISTINCT FROM value2 | 如果value1与value2不同，则返回true。如果value1和value2都为null，则它们被视为相等。
value1 IS NOT DISTINCT FROM value2 | 如果value1等于value2，则返回true。如果value1和value2都为null，则它们被视为相等。
value1 BETWEEN value2 AND value3 | 如果value1大于或等于value2且小于value3，则返回true。
value1 NOT BETWEEN value2 AND value3 | 如果value1小于value2或大于或等于value3，则返回true。
string1 LIKE string2 [ ESCAPE string3 ] | 对字符串string1进行模糊匹配，如果匹配到模式string2则返回true，如果不匹配则返回false。
string1 NOT LIKE string2 [ ESCAPE string3 ] | 对字符串string1进行模糊匹配，如果匹配到模式string2则返回false，如果不匹配则返回true。
value IN (value [, value]* ) | 如果value等于列表中的任何一个值，则返回true。
value NOT IN (value [, value]* ) | 如果value不等于列表中的任何一个值，则返回true。'"
"tugraph支持边属性匹配吗？，MATCH (n:chunk {id: '21604c19-0d30-11ef-b83b-0242ac110005'})-[r:kw {name:""生活补贴""}]-(m) RETURN n, r, m 类似这种cypher 为啥不能过滤边属性？","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。
- 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。
- 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

2. 图项目、点、边、属性命名规则和建议

2.2 使用限制

|**描述**|**最大个数**|
|-------- |--------- |
|用户数、角色数|65536|
|图项目的个数|4096|
|每个图项目的点和边类型数量之和|4096|
|每个点或边类型的属性数量|1024|  
注：
1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；  
示例： ```match (`match`:match) return `match`.id limit 1```  
2、大小写敏感性：TuGraph大小写敏感；  
3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；  
4、属性名字保留关键字：SRC_ID / DST_ID / SKIP' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '2. 图项目、点、边、属性命名规则和建议', 'Header 3': '2.2 使用限制'}","page_content='RESTful API Legacy

4.查询

4.2.调用带参数的 Cypher

Cypher 支持使用参数进行查询。当调用带参数的 Cypher 查询时，TuGraph 会缓存该查询的
执行计划（execution plan），以加速后续同类查询的速度。  
- **URI**: `/cypher`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| graph | 数据库 | 字符串 |
| cypher | 查询语句 | 字符串 |
| parameters | 参数 | 列表 |  
- **RESPONSE**:  
与 [调用 Cypher](#%E8%B0%83%E7%94%A8Cypher) 相同。  
**Example request.**  
```
• POST http://localhost:7070/db/graph1/cypher
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{
""graph"": ""default"",
""script"": ""MATCH (n:Person {name:$param1}) RETURN n.birthyear"",
""parameters"": {
""$param1"": ""Lindsay Lohan""
}
}
```  
**Example response.**  
```
• 200: OK
Output:
{
""elapsed"": 0.005886077880859375,
""header"": [
{
""name"": ""n.birthyear"",
""type"": 0
}
],
""result"": [
[
1986
]
],
""size"": 1
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '4.查询', 'Header 3': '4.2.调用带参数的 Cypher'}"
TuGraph是如何通过语句定义点类型和边类型的？,"page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。
- 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。
- 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。  
###### 1.3.1.1.2 non_unique索引  
点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的点的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。
但是，不同于unique索引，超过475bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
##### 1.3.1.2 边索引  
###### 1.3.1.2.1 unique索引  
和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。  
###### 1.3.1.2.2 pair_unique索引  
pair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，
相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，
索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。
因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。  
###### 1.3.1.2.3 non_unique索引  
和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）
2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节  
##### 1.3.2.1 唯一索引  
和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，
在同一个图中，相同label的点的该组属性不会存在相同的值。
由于底层存储设计，组合索引key需要保存属性的长度，因此，
组合唯一索引key的最大长度是480-2*(属性个数-1) bytes，**超过的属性不能建立唯一索引**。  
##### 1.3.2.2 非唯一索引  
和点的普通非唯一索引类似，点的非唯一索引指的是非全局唯一的索引，即若一组属性设置了非唯一索引，
在同一个图中，相同label的点的该组属性可以存在相同的值。
由于非唯一索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475-2*(属性个数-1) bytes，
**超过的属性不能建立非唯一索引**。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='地理空间数据类型使用示例

3. 数据类型

目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:  
- Point：点    point(2.0, 2.0, 7203)
- Linestring：折线 LINESTRING(0 2,1 1,2 0)
- Polygon：多边形  POLYGON((0 0,0 7,4 2,2 0,0 0))  
其中坐标点都是double型，创建图模型和插入数据示例如下：  
**创建标记美食位置的点模型**  
```
CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)
```  
![image.png](../../../images/spatail/createVertexLabel.png)  
**插入标记美食点的数据**  
```
CREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n
```  
![image.png](../../../images/spatail/createFoodData.png)  
**创建具有折线属性的点模型**  
```
CALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)
```  
![image.png](../../../images/spatail/createVertexLabel_lineTest.png)  
**插入具有折线属性的点数据**  
```
CREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n
```  
![image.png](../../../images/spatail/createLineTestData.png)  
**创建具有多边型属性的点模型**  
```
CALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)
```  
![image.png](../../../images/spatail/createVertexLabel_PolygonTest.png)  
**插入具有多边型属性的点数据**  
```
CREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n
```' metadata={'Header 1': '地理空间数据类型使用示例', 'Header 2': '3. 数据类型'}"
想问一下，如果log_dir不设置，是不是就不会保存日志文件?,"page_content='日志信息

2.服务器日志

2.1.服务器日志配置项

服务器日志的输出位置可以通过`log_dir`配置指定。服务器日志详细程度可通过`verbose`配置项指定。  
`log_dir`配置项默认为空。若`log_dir`配置项为空，则所有日志会输出到控制台(daemon模式下若log_dir配置项为空则不会向console输出任何日志)；若手动指定`log_dir`配置项，则日志文件会生成在对应的路径下面。单个日志文件最大大小为256MB。  
`verbose`配置项控制日志的详细程度，从粗到细分为`0, 1, 2`三个等级，默认等级为`1`。等级为`2`时，日志记录最详细，服务器将打印`DEBUG`及以上等级的全部日志信息；等级为`1`时，服务器将仅打印`INFO`等级及以上的主要事件的日志；等级为`0`时，服务器将仅打印`ERROR`等级及以上的错误日志。' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.1.服务器日志配置项'}","page_content='日志信息

2.服务器日志

2.3.存储过程日志

用户在存储过程的编写过程中可以使用日志功能将所需的调试信息输出到日志中进行查看，辅助开发。调试信息会输出到与服务器日志相同的日志文件中(如未指定`log_dir`则同样输出至console)  
#### 2.3.1.cpp存储过程
请使用2.2中提供的log宏输出调试信息，避免使用cout或者printf等输出方式。具体使用方式可参考如下示例代码（详见`procedures/demo/log_demo.cpp`）  
```
#include <stdlib.h>
#include ""lgraph/lgraph.h""
#include ""tools/lgraph_log.h""  // add log dependency
using namespace lgraph_api;

void LogExample() {
LOG_DEBUG() << ""This is a debug level log message."";
LOG_INFO() << ""This is a info level log message."";
LOG_WARN() << ""This is a warning level log message."";
LOG_ERROR() << ""This is a error level log message."";
}

extern ""C"" bool Process(GraphDB& db, const std::string& request, std::string& response) {
response = ""TuGraph log demo"";
LogExample();
return true;
}
```
将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。  
#### 2.3.1.python存储过程
请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.3.存储过程日志'}","page_content='日志信息

2.服务器日志

2.2.服务器日志输出宏使用示例

如果开发者在开发过程中希望在代码中添加日志，可以参考如下示例  
```
#include ""tools/lgraph_log.h"" //添加日志依赖


void LogExample() {
// 数据库启动阶段已经对日志模块进行了初始化，开发者只需直接调用宏即可
// 日志等级分为DEBUG, INFO, WARNING, ERROR, FATAL五个等级
LOG_DEBUG() << ""This is a debug level log message."";
LOG_INFO() << ""This is a info level log message."";
LOG_WARN() << ""This is a warning level log message."";
LOG_ERROR() << ""This is a error level log message."";
LOG_FATAL() << ""This is a fatal level log message."";
}
```
更多用法可以参考test/test_lgraph_log.cpp中的日志宏的使用方法' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.2.服务器日志输出宏使用示例'}"
当调用算法 `algo.shortestPath` 实际应用中的例子是什么？,"page_content='Cypher API

5.附录2. 内置procedures列表

* algo.shortestPath(startNode, endNode, config)

get one of the shortest paths between two vertexes.  
**Parameters:**  
| parameter | parameter type | description                          |
| --------- | -------------- | ------------------------------------------------------------ |
| startNode | Node       | the source node of paths                     |
| endNode   | Node       | the destination node paths                   |
| config    | MAP        | the filter of shortest paths, the formate as {maxHops:3, relationshipQuery:'HAS_CHILD'} |  
**Output:**  
If successful, it will returns one group result of the shortest path.  
**Example input:**  
```
MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})
CALL algo.shortestPath(n1,n2) YIELD nodeCount,totalCost RETURN nodeCount,totalCost
```  
**Example output:**  
| nodeCount | totalCost |
| --------- | --------- |
| 2     | 1     |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.shortestPath(startNode, endNode, config)'}","page_content='QA汇总

Cypher QA

查询最短路径

Q：如何查询最短路径，shortestPath 函数如何使用？
A：使用示例如下（示例图谱：MovieDemo）  
```
MATCH (n1 {name:'Corin Redgrave'}),(n2 {name:'Liam Neeson'})
CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,relationshipIds,cost
RETURN nodeIds,relationshipIds,cost
```  
详尽使用方案请参考官网文档https://www.tugraph.org/doc?version=V3.3.0&id=10000000000658658。' metadata={'Header 1': 'QA汇总', 'Header 2': 'Cypher QA', 'Header 3': '查询最短路径'}","page_content='Cypher API

5.附录2. 内置procedures列表

* algo.allShortestPaths(startNode, endNode, config))

get the path of backuped files.  
**Output:**  
If successful, it returns the path of snapshot.  
**Example input:**  
```
MATCH (n1 {name:'Hugo Weaving'}),(n2 {title:'The Matrix'})
CALL algo.allShortestPaths(n1,n2) YIELD nodeIds,cost RETURN nodeIds,cost
```  
**Example output:**  
| nodeIds | cost |
| ------- | ---- |
| [2,665] | 1    |
| ...     |      |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* algo.allShortestPaths(startNode, endNode, config))'}"
方法 GetLabel() 返回什么类型的结果？,"page_content='Cypher API

5.附录2. 内置procedures列表

* db.getLabelSchema(label_type, label_name)

Get the schema definition of the label in a subgraph.  
**Scope:** subgraph, as specified in the `graph` parameter in REST or RPC request.  
**Parameters:**  
| parameter  | parameter type | description           |
| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |
| label_name | string     | name of the label     |  
**Output:** a list of label specifications, in which each element is a list of the following fields:  
| field_name | field_type | description           |
| ---------- | ---------- | ----------------------------- |
| name       | string     | name of the field         |
| type       | string     | type of the field         |
| optional   | boolean    | whether the field is optional |  
**Example input:**  
```
CALL db.getLabelSchema('vertex', 'Person')
```  
**Example output:**  
| name     | type   | optional |
| ------------ | ------ | -------- |
| id       | INT32  | false    |
| born     | INT32  | true     |
| name     | STRING | true     |
| poster_image | STRING | true     |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.getLabelSchema(label_type, label_name)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.deleteLabel(label_type, label_name)

Delete a vertex or edge label.  
**Parameters:**  
| parameter  | parameter type | description           |
| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |
| label_name | string     | name of the label     |  
**Output:**  
| field_name | field_type | description              |
| ---------- | ---------- | -------------------------------- |
| affected   | integer    | number of vertexes/edges deleted |  
**Example input:**  
```
CALL db.deleteLabel('vertex', 'Person')
```  
**Example output:**  
| affected |
| -------- |
| 1024     |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.deleteLabel(label_type, label_name)'}","page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

TuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。  
Label 操作对应的 URI 格式为  
```
http://{host}:{port}/db/{graph_name}/label/{type}/{label_name}
```  
其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | Label 名 | 字符串 |
| fields | 数据列定义 | 列表 |
| is_vertex | 是否是点 Label | 布尔值 |
| primary | 点的主键属性 | 字符串 |
| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。  
`edge_constraints` 在 `is_vertex` 为 `false` 的时候设置，这个字段只有边有。这个字段限制了该边的起点和终点只能是哪些点的组合，比如：`[[""vertex_label1"",""vertex_label2""],[""vertex_label3"",""vertex_label4""]]`，限制了该边只能是从 `vertex_label1` 到 `vertex_label2` 和 从 `vertex_label3` 到 `vertex_label4`。如果不想有任何限制，不设置该字段即可。  
其中`fields`为一个数组，其中每个元素定义数据的一列，内容如下：  
| 域名     | 说明                                     | 类型                                                                                                |
| -------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------- |
| name     | 列名                                     | 字符串                                                                                              |
| type     | 列数据类型                               | 字符串，有以下类型： int8, int16, int32, int64, float, double, string, date, datetime, binary, bool |
| optional | 数据是否可以为空（可选，缺省值为 false） | 布尔值                                                                                              |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/db/{graph_name}/label
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""name"":""Actor"",
""fields"": [
{""name"":""uid"", ""type"":""int64"", ""optional"":false},
{""name"":""name"", ""type"":""string"", ""optional"":true}
],
""is_vertex"":true,
""primary"" : ""uid""
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.6.2.列出所有 Label  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| edge | 边 Label 列表 | 列表 |
| vertex | 点 Label 列表 | 列表 |  
**Example request.**  
```
• GET http://localhost:7070/db/{graph_name}/label
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""edge"": [
""HAS_CHILD"",
""MARRIED"",
""BORN_IN"",
""DIRECTED"",
""WROTE_MUSIC_FOR"",
""ACTED_IN""
],
""vertex"": [
""Person"",
""City"",
""Film""
]
}
```  
#### 6.6.3.获取 Label 的数据格式定义  
- **URI**: `/db/{graph_name}/label/{[node|relationship]}/{label_name}`
- **METHOD**: GET
- **RESPONSE**: 数据列定义表，类型是一个词典，key 为列名，value 为列定义，列定义见如下：
-  
| 域名     | 说明             | 类型   |
| -------- | ---------------- | ------ |
| optional | 该列值是否可为空 | 布尔值 |
| type     | 列值类型         | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/db/{graph_name}/label/node/person
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""age"":{
""optional"":false,
""type"":""int16""
},
""id"":{
""optional"":false,
""type"":""int8""
},
""name"":{
""optional"":false,
""type"":""string""
}
}
```  
#### 6.6.4.Schema 导入  
- **URI**: `/db/{graph_name}/schema/text`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 文件内容描述 | 字符串 |  
description 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。  
- **RESPONSE**:  
Schema 导入会根据 description 比较新的 Schema 和数据库中原有的 Schema 是否兼容，检查的粒度为 Label。如果不一致则出错，如果一致则添加原先 Schema 中不存在的 Label，返回 200。  
**Example request.**  
```
• POST http://localhost:7070/db/graph1/schema/text
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{
""description"": ""{\\""schema\\"":[{\\""label\\"":\\""actor\\"",\\""primary\\"":\\""aid\\"",\\""properties\\"":[{\\""name\\"":\\""aid\\"",\\""type\\"":\\""STRING\\""}],\\""type\\"":\\""VERTEX\\""}]}""
}
```  
上述 description 的值是如下 json 序列化后的字符串:  
```json
{
""schema"": [
{
""label"": ""actor"",
""type"": ""VERTEX"",
""properties"": [{ ""name"": ""aid"", ""type"": ""STRING"" }],
""primary"": ""aid""
}
]
}
```  
**Example response.**  
```
• 200: OK
Output:
{
""log"": """"
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}"
Rust 存储过程目前支持哪个版本？,"page_content='Rust 存储过程

1. 介绍

Rust 存储过程目前仅支持v1版本，TuGraph能够支持一切编译成动态库的语言作为插件。Rust语言作为系统编程语言的新起之秀，在安全性上、可靠性以及人体工程学上相较于C++具有较大优势。  
我们提供了TuGraph的[Rust binding]库来支持在Rust中调用lgrahp api，同时提供[tugraph-plugin-util] 工具库来帮助大家更加简洁地编写Rust插件代码。  
[Rust binding]: https://crates.io/crates/tugraph
[tugraph-plugin-util]: https://crates.io/crates/tugraph-plugin-util' metadata={'Header 1': 'Rust 存储过程', 'Header 2': '1. 介绍'}","page_content='Rust 存储过程

2. 如何使用

Rust存储过程的使用分三步：
* 编译，从rust源码编译出so库。我们准备了一份一站式的插件编写教程，从IDE的插件安装，环境配置，到编译，详细参考`rust-tugraph-plugin-tutorial`。
* 加载，将so库加载到服务端，可以通过REST或RPC接口，这一步和C++库的使用方式类似，可以参考[文档](1.procedure.md)。
* 运行，和c++ procdure使用方式相同，不在赘述。' metadata={'Header 1': 'Rust 存储过程', 'Header 2': '2. 如何使用'}","page_content='Rust 存储过程

3.API文档

Rust社区习惯，所有的代码和文档都可以从[`crates.io`](https://crates.io/crates/tugraph )以及[`docs.rs`](https://docs.rs/tugraph/latest/tugraph )找到。' metadata={'Header 1': 'Rust 存储过程', 'Header 2': '3.API文档'}"
TuGraph单元测试使用的是什么测试框架？,"page_content='集成测试

2.TuGraph集成测试框架

TuGraph采用pytest框架作为自己的集成测试框架，pytest框架作为目前使用最广泛的cs端集成测试框架，以其灵活简单，容易上手，并且支持参数化的使用方式而著称，TuGraph基于pytest提供的功能，抽象出了不同的工具，通过参数来控制各个工具的处理逻辑，以方便大家进行高效的测试代码开发。  
更多pytest信息请参考官网: [https://docs.pytest.org/en/7.2.x/getting-started.html](https://docs.pytest.org/en/7.2.x/getting-started.html)' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架'}","page_content='TuGraph与ARM架构

内容：

TuGraph作为蚂蚁集团开源的高性能图数据库，近期在完成多平台认证的基础上，在ARM架构上发挥出极致的性能，获得了国际权威图数据库基准测试LDBC SNB的官方认证，并基于ARM架构打破了官方记录。  
**本次测试，验证了TuGraph对于ARM架构的兼容性，成为对x86和ARM架构均完整适配的图数据库；同时充分发挥出了新硬件的功能和性能优势，性能数据****较上一次官方纪录提升了31%，云端机器开销降低40%****。**  
评测流程和相关文件已同步发布在Github（https://github.com/TuGraph-family/tugraph-snb-interactive），开发者可参照来复现评测结果，**也可以通过阿里云轻松一键部署，以可视化方式试用TuGraph丰富的功能（****https://aliyun-computenest.github.io/quickstart-tugraph/****）。**该测试流程也适用于x86等其他软硬件环境。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：'}","page_content='TuGraph由LDBC认定全球领先

基本介绍

TuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。  
**随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品**。  
开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。  
图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。  
蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。  
蚂蚁集团 2015 年开始自主研发分布式图数据库、流式图计算等图相关技术，2016 年发布自研分布式图数据库，并应用于支付宝。至今 TuGraph 已应用于蚂蚁内部 150 多个场景，包括在线支付的实时链路，以支付宝风险识别能力提升近 10 倍、风险审理分析效率提升 90%的成绩，验证了其高可靠性。  
LDBC（关联数据基准委员会）发布最新图数据库 SNB 测试结果，TuGraph 在功能完整性、吞吐率、响应速度等层面全球领先。  
目前，蚂蚁集团已形成了一套以图数据库为底座、同时包含流式图计算，离线图学习的大规模图计算系统。  
蚂蚁集团图数据库负责人洪春涛表示，图技术是未来大数据、人工智能和高性能计算产业发展的关键所在，它很有可能会成为下一代的数据底座。蚂蚁集团愿意通过开源持续输出核心技术优势，推动图数据库更广泛的应用生态，携手行业抢占技术高地，不断探索技术的可能性。' metadata={'Header 1': 'TuGraph由LDBC认定全球领先', 'Header 2': '基本介绍'}"
创建 Label 的请求是否需要指定该 Label 是否为点（vertex）或边（relationship）？,"page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

Create a vertex or edge label.  
**Parameters:**  
| parameter  | parameter type | description           |
| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |
| label_name | string     | name of the label     |
| extra      | string     | for edge, it means constraints; for vertex, it means primary property |
| field_spec | list       | specification of a field  |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.
for edge, `extra` should be a json array string, like this `[[""label1"",""label2""], [""label3"",""label4""]]`, if edge has no constraints, give an empty json array, like this `[]`  
**Output:**  
If successful, it returns a success message.  
**Example input:**  
```
CALL db.createLabel('vertex', 'new_label', 'id', ['id','int32',false], ['name','string', true]);
CALL db.createLabel('edge', 'new_edge', '[[""id1"",""id2""]]', ['id','int32',false], ['name', 'string', true]);
```  
**Example output:**  
```
Vertex label [new_label] successfully added.
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}","page_content='RESTful API Legacy

6.Deprecated

6.6.元数据管理

TuGraph 是一个具备多图能力的强模式属性图数据库。在每一张子图中，每种点和边都需要有预定义的数据格式。数据格式由 Label 决定，每种 Label 都有自己的数据格式。用户可以使用 REST API 添加，删除和查询 Label 及其对应的数据格式。  
Label 操作对应的 URI 格式为  
```
http://{host}:{port}/db/{graph_name}/label/{type}/{label_name}
```  
其中{type}可以是 node 或者 relationship。  
#### 6.6.1.创建Label  
创建 Label 的过程同时也是定义其数据类型的过程。只有创建了 Label 才能在图中插入相应类型的点或者边。  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | Label 名 | 字符串 |
| fields | 数据列定义 | 列表 |
| is_vertex | 是否是点 Label | 布尔值 |
| primary | 点的主键属性 | 字符串 |
| edge_constraints | 边的约束 | 列表 |  
`primary` 在 `is_vertex` 为 `true` 的时候设置，这个字段只有点才有, 创建点的时候必须设置。  
`edge_constraints` 在 `is_vertex` 为 `false` 的时候设置，这个字段只有边有。这个字段限制了该边的起点和终点只能是哪些点的组合，比如：`[[""vertex_label1"",""vertex_label2""],[""vertex_label3"",""vertex_label4""]]`，限制了该边只能是从 `vertex_label1` 到 `vertex_label2` 和 从 `vertex_label3` 到 `vertex_label4`。如果不想有任何限制，不设置该字段即可。  
其中`fields`为一个数组，其中每个元素定义数据的一列，内容如下：  
| 域名     | 说明                                     | 类型                                                                                                |
| -------- | ---------------------------------------- | --------------------------------------------------------------------------------------------------- |
| name     | 列名                                     | 字符串                                                                                              |
| type     | 列数据类型                               | 字符串，有以下类型： int8, int16, int32, int64, float, double, string, date, datetime, binary, bool |
| optional | 数据是否可以为空（可选，缺省值为 false） | 布尔值                                                                                              |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/db/{graph_name}/label
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""name"":""Actor"",
""fields"": [
{""name"":""uid"", ""type"":""int64"", ""optional"":false},
{""name"":""name"", ""type"":""string"", ""optional"":true}
],
""is_vertex"":true,
""primary"" : ""uid""
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.6.2.列出所有 Label  
- **URI**: `/db/{graph_name}/label`
- **METHOD**: GET
- **RESPONSE**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| edge | 边 Label 列表 | 列表 |
| vertex | 点 Label 列表 | 列表 |  
**Example request.**  
```
• GET http://localhost:7070/db/{graph_name}/label
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""edge"": [
""HAS_CHILD"",
""MARRIED"",
""BORN_IN"",
""DIRECTED"",
""WROTE_MUSIC_FOR"",
""ACTED_IN""
],
""vertex"": [
""Person"",
""City"",
""Film""
]
}
```  
#### 6.6.3.获取 Label 的数据格式定义  
- **URI**: `/db/{graph_name}/label/{[node|relationship]}/{label_name}`
- **METHOD**: GET
- **RESPONSE**: 数据列定义表，类型是一个词典，key 为列名，value 为列定义，列定义见如下：
-  
| 域名     | 说明             | 类型   |
| -------- | ---------------- | ------ |
| optional | 该列值是否可为空 | 布尔值 |
| type     | 列值类型         | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/db/{graph_name}/label/node/person
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""age"":{
""optional"":false,
""type"":""int16""
},
""id"":{
""optional"":false,
""type"":""int8""
},
""name"":{
""optional"":false,
""type"":""string""
}
}
```  
#### 6.6.4.Schema 导入  
- **URI**: `/db/{graph_name}/schema/text`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 文件内容描述 | 字符串 |  
description 的具体描述方法见《TuGraph 操作手册》中数据导入配置文件的相关内容。  
- **RESPONSE**:  
Schema 导入会根据 description 比较新的 Schema 和数据库中原有的 Schema 是否兼容，检查的粒度为 Label。如果不一致则出错，如果一致则添加原先 Schema 中不存在的 Label，返回 200。  
**Example request.**  
```
• POST http://localhost:7070/db/graph1/schema/text
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8
Input:
{
""description"": ""{\\""schema\\"":[{\\""label\\"":\\""actor\\"",\\""primary\\"":\\""aid\\"",\\""properties\\"":[{\\""name\\"":\\""aid\\"",\\""type\\"":\\""STRING\\""}],\\""type\\"":\\""VERTEX\\""}]}""
}
```  
上述 description 的值是如下 json 序列化后的字符串:  
```json
{
""schema"": [
{
""label"": ""actor"",
""type"": ""VERTEX"",
""properties"": [{ ""name"": ""aid"", ""type"": ""STRING"" }],
""primary"": ""aid""
}
]
}
```  
**Example response.**  
```
• 200: OK
Output:
{
""log"": """"
}
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.6.元数据管理'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createEdgeLabel( label_name, field_spec...)

Create an edge label.  
**Parameters:**  
| parameter  | parameter type | description          |
| ---------- | -------------- | ------------------------ |
| label_name | string     | name of the label    |
| edge_constraints | string | edge constraints |
| field_spec | list       | specification of a field |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields.  
`edge_constraints` is a json array string, This parameter limits the combination of starting and ending vertex of the edge, for example: `'[[""vertex_label1"",""vertex_label2""],[""vertex_label3"",""vertex_label4""]]'`, which limits the edge direction can only be from `vertex_label1` to `vertex_label2` or from `vertex_label3` to `vertex_label4`. If you don't want to have any constraints, give an empty array string, like this `'[]'`  
**Output:**  
If successful, it returns a success message.  
**Example input:**  
```
CALL db.createEdgeLabel('KNOWS', '[]', 'name', 'int32', true)
```  
**Example output:**  
```
Added type [KNOWS]
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createEdgeLabel( label_name, field_spec...)'}"
TuGraph 中使用的两种主要图分析操作是什么？,"page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

TuGraph 的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。 在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。  
TuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法。涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。  
<table><tbody><tr><td>算法类型</td><td>中文算法名</td><td>英文算法名</td><td>程序名</td></tr><tr><td rowspan=""5"">路径查询</td><td>广度优先搜索</td><td>Breadth-First Search</td><td>bfs</td></tr><tr><td>单源最短路径</td><td>Single-Source Shortest Path</td><td>sssp</td></tr><tr><td>全对最短路径</td><td>All-Pair Shortest Path</td><td>apsp</td></tr><tr><td>多源最短路径</td><td>Multiple-source Shortest Paths</td><td>mssp</td></tr><tr><td>两点间最短路径</td><td>Single-Pair Shortest Path</td><td>spsp</td></tr><tr><td rowspan=""9"">重要性分析</td><td>网页排序</td><td>Pagerank</td><td>pagerank</td></tr><tr><td>介数中心度</td><td>Betweenness Centrality</td><td>bc</td></tr><tr><td>置信度传播</td><td>Belief Propagation</td><td>bp</td></tr><tr><td>距离中心度</td><td>Closeness Centrality</td><td>clce</td></tr><tr><td>个性化网页排序</td><td>Personalized PageRank</td><td>ppr</td></tr><tr><td>带权重的网页排序</td><td>Weighted Pagerank Algorithm</td><td>wpagerank</td></tr><tr><td>信任指数排名</td><td>Trustrank</td><td>trustrank</td></tr><tr><td>sybil检测算法</td><td>Sybil Rank</td><td>sybilrank</td></tr><tr><td>超链接主题搜索</td><td>Hyperlink-Induced Topic Search</td><td>hits</td></tr><tr><td rowspan=""4"">关联性分析</td><td>平均集聚系数</td><td>Local Clustering Coefficient</td><td>lcc</td></tr><tr><td>共同邻居</td><td>Common Neighborhood</td><td>cn</td></tr><tr><td>度数关联度</td><td>Degree Correlation</td><td>dc</td></tr><tr><td>杰卡德系数</td><td>Jaccard Index</td><td>ji</td></tr><tr><td rowspan=""5"">图结构</td><td>直径估计</td><td>Dimension Estimation</td><td>de</td></tr><tr><td>K核算法</td><td>K-core</td><td>kcore</td></tr><tr><td>k阶团计数算法</td><td>Kcliques</td><td>kcliques</td></tr><tr><td>k阶桁架计数算法</td><td>Ktruss</td><td>ktruss</td></tr><tr><td>最大独立集算法</td><td>Maximal independent set</td><td>mis</td></tr><tr><td rowspan=""8"">社区发现</td><td>弱连通分量</td><td>Weakly Connected Components</td><td>wcc</td></tr><tr><td>标签传播</td><td>Label Propagation Algorithm</td><td>lpa</td></tr><tr><td>EgoNet算法</td><td>EgoNet</td><td>en</td></tr><tr><td>鲁汶社区发现</td><td>Louvain</td><td>louvain</td></tr><tr><td>强连通分量</td><td>Strongly Connected Components</td><td>scc</td></tr><tr><td>监听标签传播</td><td>Speaker-listener Label Propagation Algorithm</td><td>slpa</td></tr><tr><td>莱顿算法</td><td>Leiden</td><td>leiden</td></tr><tr><td>带权重的标签传播</td><td>Weighted Label Propagation Algorithm</td><td>wlpa</td></tr><tr><td rowspan=""3"">模式挖掘</td><td>三角计数</td><td>Triangle Counting</td><td>triangle</td></tr><tr><td>子图匹配算法</td><td>Subgraph Isomorphism</td><td>subgraph_isomorphism</td></tr><tr><td>模式匹配算法</td><td>Motif</td><td>motif</td></tr></tbody></table>' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='OLAP API

1. TuGraph 图分析引擎介绍

TuGraph的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助TuGraph的 C++ / Python 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如PageRank、LPA、WCC等迭代式图算法，最后根据运行结果做出相应的对策。  
在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
TuGraph图计算系统社区版内置6个算法，商业版内置了25种算法，用户几乎不需要自己实现具体的图计算过程。其详细介绍可参考algorithms.md。  
根据数据来源及实现不同，可分为Procedure、Embed和Standalone三种运行方式，均继承于OlapBase API，OlapBase API接口文档可参考olapbase-api.md。  
其中Procedure和Embed的数据来源是图数据库中预加载的db数据，可以分别编译生成tugraph-web加载使用的.so文件和后台终端使用的embed文件，输入的图数据均通过db的加载形式，其接口文档可参考olapondb-api.md。
Standalone用于编译生成standalone文件，区别于前者，该文件的输入图数据通过txt、二进制、ODPS文件的形式加载，其接口文档可参考olapondisk-api.md。' metadata={'Header 1': 'OLAP API', 'Header 2': '1. TuGraph 图分析引擎介绍'}"
TuGraph-DB如何在代码中增加日志输出埋点？,"page_content='TuGraph Management

简介

TuGraph Management 是一款为TuGraph开发的算法任务管理工具。采用了sofastack与brpc作为通信框架，并使用sqlite进行持久化存储。  
主要功能：  
- 算法任务状态持久化存储  
- 算法任务结果持久化存储  
- 延时触发与定时触发算法任务支持' metadata={'Header 1': 'TuGraph Management', 'Header 2': '简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.3 通过OGM进行增操作**

OGM支持对TuGraph的实体执行CRUD 操作，同时支持发送任意TuGraph支持的Cypher语句，包括通过CALL调用存储过程。  
**CREATE**  
在完成图对象的构建后，即可通过类的实例化创建节点，当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边，最后使用session.save方法将数据存入数据库。  
注意：TuGraph数据库为强schema类型数据库，在创建实体前需要该数据的label已经存在，且新建过程中需要提供唯一的主键。  
```
Movie jokes = new Movie（""Jokes""，1990）； // 新建Movie节点jokes session.save(jokes); // 将jokes存储在TuGraph中

Movie speed = new Movie(""Speed"", 2019);

Actor alice = new Actor(""Alice Neeves"");

alice.actsIn(speed);

session.save(speed);

/1 将speed节点与alice节点通过ACTS_IN进行连接 11 存储speed节点以及speed关联的边和alice节点
```' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.3 通过OGM进行增操作**'}","page_content='技术规划

2. 已完成功能

TuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。  
| 版本号   | 功能                               | 时间         |
|-------|----------------------------------|------------|
| 3.3.0 | 开源初版                             | 2022.9.1   |
| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |
| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |
| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |
| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |
| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}"
在删除边的全文索引时，如果边标签或字段不存在会抛出什么异常？,"page_content='业务开发指南

边类型操作

边类型删除索引

如下例子，对于边类型`edge1`，删除字段`field1`上的索引。
```
CALL db.deleteEdgeIndex('edge1', 'field1')
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '边类型删除索引'}","page_content='业务开发指南

边类型操作

边类型删除字段

>该操作会同步变更所有该类型边的属性数据，数据量大的时候，有时间消耗。  
如下操作，对于边类型`edge1`，一次删除了两个字段: `field1` 和 `field2`。
```
CALL db.alterLabelDelFields('edge', 'edge1', ['field1', 'field2'])
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '边类型删除字段'}","page_content='业务开发指南

边类型操作

边类型添加索引

>该操作会同步构建索引数据，数据量大的时候，有时间消耗。  
如下例子，对于边类型`edge1`，给字段`field1`添加了一个非唯一索引。
```
CALL db.addEdgeIndex('edge1', 'field1', false, false)
```
如下例子，对于边类型`edge1`，给字段`field2`添加了一个唯一索引。
```
CALL db.addEdgeIndex('edge1', 'field2', true, false)
```' metadata={'Header 1': '业务开发指南', 'Header 2': '边类型操作', 'Header 3': '边类型添加索引'}"
Grafana主要用于什么？,"page_content='运维监控

2.部署方案

2.4.第四步

+ 下载符合您机器架构以及系统版本的Grafana安装包，下载地址: [https://grafana.com/grafana/download](https://grafana.com/grafana/download)  
+ 安装Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)  
+ 启动Grafana，细节请参考: [ https://grafana.com/docs/grafana/v7.5/installation/]( https://grafana.com/docs/grafana/v7.5/installation/)  
+ 配置Grafana，首先在数据源设置中配置Prometheus的IP地址，配置完成后可以通过测试连接功能，验证是否成功连接数据源。然后，导入如下模版，并在页面中根据实际情况，修改正确的接口IP和端口。最后可以根据实际情况设置刷新时间和监控时间范围  
```json
{
""annotations"": {
""list"": [
{
""builtIn"": 1,
""datasource"": {
""type"": ""grafana""
},
""enable"": true,
""hide"": true,
""iconColor"": ""rgba(0, 211, 255, 1)"",
""name"": ""Annotations & Alerts"",
""target"": {
""limit"": 100,
""matchAny"": false,
""tags"": [],
""type"": ""dashboard""
},
""type"": ""dashboard""
}
]
},
""editable"": true,
""fiscalYearStartMonth"": 0,
""graphTooltip"": 0,
""id"": 2,
""links"": [],
""liveNow"": false,
""panels"": [
{
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
}
},
""mappings"": [],
""unit"": ""kbytes""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""D {instance=\""localhost:7010\"", job=\""TuGraph\"", resouces_type=\""memory\"", type=\""available\""}""
},
""properties"": [
{
""id"": ""displayName"",
""value"": ""others""
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""D {__name__=\""resources_report\"", instance=\""localhost:7010\"", job=\""TuGraph\"", resouces_type=\""memory\"", type=\""available\""}""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-green"",
""mode"": ""fixed""
}
},
{
""id"": ""displayName"",
""value"": ""others""
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""others""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-blue"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""graph_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-orange"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 16,
""w"": 6,
""x"": 0,
""y"": 0
},
""id"": 14,
""options"": {
""displayLabels"": [
""name"",
""value""
],
""legend"": {
""displayMode"": ""table"",
""placement"": ""bottom"",
""values"": [
""percent"",
""value""
]
},
""pieType"": ""pie"",
""reduceOptions"": {
""calcs"": [
""lastNotNull""
],
""fields"": """",
""values"": false
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""memory\"",type=\""self\""}"",
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""memory\"",type=\""available\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""B""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""memory\"",type=\""total\""}"",
""hide"": true,
""legendFormat"": ""{ {label_name} }"",
""range"": true,
""refId"": ""C""
},
{
""datasource"": {
""type"": ""__expr__""
},
""expression"": ""$C -$A - $B"",
""hide"": false,
""refId"": ""D"",
""type"": ""math""
}
],
""title"": ""内存"",
""type"": ""piechart""
},
{
""alert"": {
""alertRuleTags"": {},
""conditions"": [
{
""evaluator"": {
""params"": [
1000
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\n  QPS超过1000"",
""name"": ""请求统计 alert"",
""noDataState"": ""no_data"",
""notifications"": []
},
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""axisLabel"": """",
""axisPlacement"": ""auto"",
""barAlignment"": 0,
""drawStyle"": ""line"",
""fillOpacity"": 7,
""gradientMode"": ""none"",
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
},
""lineInterpolation"": ""smooth"",
""lineWidth"": 1,
""pointSize"": 5,
""scaleDistribution"": {
""type"": ""linear""
},
""showPoints"": ""auto"",
""spanNulls"": false,
""stacking"": {
""group"": ""A"",
""mode"": ""none""
},
""thresholdsStyle"": {
""mode"": ""off""
}
},
""mappings"": [],
""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},
""unit"": "" ""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""write""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-blue"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 16,
""w"": 12,
""x"": 6,
""y"": 0
},
""id"": 4,
""options"": {
""legend"": {
""calcs"": [
""min"",
""max"",
""mean"",
""last""
],
""displayMode"": ""table"",
""placement"": ""bottom""
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""request\"",type=~\""total|write\""}"",
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 1000,
""visible"": true
}
],
""title"": ""请求统计"",
""type"": ""timeseries""
},
{
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
}
},
""mappings"": [],
""unit"": ""decbits""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""graph_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-red"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""available""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-orange"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""D""
},
""properties"": [
{
""id"": ""displayName"",
""value"": ""other""
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""other""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-purple"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 16,
""w"": 6,
""x"": 18,
""y"": 0
},
""id"": 12,
""options"": {
""displayLabels"": [
""name"",
""value""
],
""legend"": {
""displayMode"": ""table"",
""placement"": ""bottom"",
""sortBy"": ""Value"",
""sortDesc"": true,
""values"": [
""value"",
""percent""
]
},
""pieType"": ""pie"",
""reduceOptions"": {
""calcs"": [
""lastNotNull""
],
""fields"": """",
""values"": false
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""exemplar"": false,
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk\"",type=\""available\""}"",
""format"": ""time_series"",
""instant"": false,
""interval"": """",
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk\"",type=\""self\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""B""
},
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk\"",type=\""total\""}"",
""hide"": true,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""C""
},
{
""datasource"": {
""type"": ""__expr__""
},
""expression"": ""$C - $A - $B"",
""hide"": false,
""refId"": ""D"",
""type"": ""math""
}
],
""title"": ""磁盘"",
""transformations"": [
{
""id"": ""configFromData"",
""options"": {
""applyTo"": {
""id"": ""byFrameRefID""
},
""configRefId"": ""config"",
""mappings"": []
}
}
],
""type"": ""piechart""
},
{
""alert"": {
""alertRuleTags"": {},
""conditions"": [
{
""evaluator"": {
""params"": [
90
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\nCPU使用率超过90%"",
""name"": ""CPU使用率 alert"",
""noDataState"": ""no_data"",
""notifications"": [
{
}
]
},
""datasource"": {
""type"": ""prometheus""
},
""description"": """",
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""axisLabel"": """",
""axisPlacement"": ""auto"",
""barAlignment"": 0,
""drawStyle"": ""line"",
""fillOpacity"": 4,
""gradientMode"": ""none"",
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
},
""lineInterpolation"": ""linear"",
""lineWidth"": 1,
""pointSize"": 5,
""scaleDistribution"": {
""type"": ""linear""
},
""showPoints"": ""auto"",
""spanNulls"": false,
""stacking"": {
""group"": ""A"",
""mode"": ""none""
},
""thresholdsStyle"": {
""mode"": ""off""
}
},
""mappings"": [],
""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},
""unit"": ""percent""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""graph_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-orange"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""total_used""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-purple"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""self""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-green"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""total""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""light-purple"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 14,
""w"": 12,
""x"": 0,
""y"": 16
},
""id"": 6,
""options"": {
""legend"": {
""calcs"": [
""min"",
""max"",
""mean"",
""last""
],
""displayMode"": ""table"",
""placement"": ""bottom""
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""code"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""cpu\"",type=~\""total|self\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 90,
""visible"": true
}
],
""title"": ""CPU使用率"",
""type"": ""timeseries""
},
{
""alert"": {
""alertRuleTags"": {},
""conditions"": [
{
""evaluator"": {
""params"": [
10000
],
""type"": ""gt""
},
""operator"": {
""type"": ""and""
},
""query"": {
""params"": [
""A"",
""5m"",
""now""
]
},
""reducer"": {
""params"": [],
""type"": ""avg""
},
""type"": ""query""
}
],
""executionErrorState"": ""alerting"",
""for"": ""5m"",
""frequency"": ""1m"",
""handler"": 1,
""message"": ""【生产图数据库Grafana】\n  磁盘IO超过10MB/S"",
""name"": ""磁盘IO alert"",
""noDataState"": ""no_data"",
""notifications"": []
},
""datasource"": {
""type"": ""prometheus""
},
""fieldConfig"": {
""defaults"": {
""color"": {
""mode"": ""palette-classic""
},
""custom"": {
""axisLabel"": """",
""axisPlacement"": ""auto"",
""barAlignment"": 0,
""drawStyle"": ""line"",
""fillOpacity"": 7,
""gradientMode"": ""none"",
""hideFrom"": {
""legend"": false,
""tooltip"": false,
""viz"": false
},
""lineInterpolation"": ""smooth"",
""lineWidth"": 1,
""pointSize"": 5,
""scaleDistribution"": {
""type"": ""linear""
},
""showPoints"": ""auto"",
""spanNulls"": false,
""stacking"": {
""group"": ""A"",
""mode"": ""none""
},
""thresholdsStyle"": {
""mode"": ""off""
}
},
""mappings"": [],
""thresholds"": {
""mode"": ""absolute"",
""steps"": [
{
""color"": ""green"",
""value"": null
},
{
""color"": ""red"",
""value"": 80
}
]
},
""unit"": ""bps""
},
""overrides"": [
{
""matcher"": {
""id"": ""byName"",
""options"": ""read""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""super-light-green"",
""mode"": ""fixed""
}
}
]
},
{
""matcher"": {
""id"": ""byName"",
""options"": ""write""
},
""properties"": [
{
""id"": ""color"",
""value"": {
""fixedColor"": ""super-light-red"",
""mode"": ""fixed""
}
}
]
}
]
},
""gridPos"": {
""h"": 14,
""w"": 12,
""x"": 12,
""y"": 16
},
""id"": 2,
""options"": {
""legend"": {
""calcs"": [
""min"",
""max"",
""mean"",
""last""
],
""displayMode"": ""table"",
""placement"": ""bottom""
},
""tooltip"": {
""mode"": ""single"",
""sort"": ""none""
}
},
""targets"": [
{
""datasource"": {
""type"": ""prometheus""
},
""editorMode"": ""builder"",
""expr"": ""resources_report{instance=\""localhost:7010\"",job=\""TuGraph\"",resouces_type=\""disk_rate\"",type=~\""read|write\""}"",
""hide"": false,
""legendFormat"": ""{ {type} }"",
""range"": true,
""refId"": ""A""
}
],
""thresholds"": [
{
""colorMode"": ""critical"",
""op"": ""gt"",
""value"": 10000,
""visible"": true
}
],
""title"": ""磁盘IO"",
""type"": ""timeseries""
}
],
""refresh"": """",
""schemaVersion"": 36,
""style"": ""dark"",
""tags"": [],
""templating"": {
""list"": []
},
""time"": {
""from"": ""now-24h"",
""to"": ""now""
},
""timepicker"": {
""hidden"": false,
""refresh_intervals"": [
""10s""
]
},
""timezone"": """",
""title"": ""TuGraph监控页面"",
""version"": 20,
""weekStart"": """"
}
```  
验证效果，刷新浏览器页面。如果正确显示饼图和折线图，则配置完成。' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.4.第四步'}","page_content='运维监控

1.设计思路

1.4.Grafana

Grafana是一个开源的可视化和分析软件，它可以从包含Prometheus在内的多个数据源中获取数据，并且可以将时序数据库中的数据转换为精美图形和可视化效果的工具。具体信息请参考官网: [https://grafana.com/docs/grafana/v7.5/getting-started/](https://grafana.com/docs/grafana/v7.5/getting-started/)' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路', 'Header 3': '1.4.Grafana'}","page_content='功能概览

6.生态工具

6.3.运维监控

TuGraph 使用 Prometheus 加 Grafana 的监控框架，采用松耦合的方式。Prometheus 从 TuGraph 的监控接口获取监控信息，存储在本地时序数据库中，然后通过 Grafana 在网页端交互展示。  
TuGraph 提供的监控的状态包括图数据库的状态和服务器的状态，前者包括读写负载、点边数量等数据库端的状态，后者包括内存、CPU、硬盘等服务器的实时状态。如果某些监控状态超过了预期的阈值，就需要主动告警，通常需要对接其他运维管控系统，比如群消息、邮件告警等。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.3.运维监控'}"
DeleteProcedure 函数是用来执行什么操作的？,"page_content='Python客户端

3.RPC Client

3.10.删除存储过程

```python
ret, res = client.deleteProcedure(""CPP"", ""sortstr"", ""default"")
```
```
deleteProcedure(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, graph: str) -> (bool, str)
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.10.删除存储过程'}","page_content='C++客户端

2.使用示例

2.10.删除存储过程

```C++
std::string str;
bool ret = client.DeleteProcedure(str, ""CPP"", ""test_plugin1"");
```
```
bool DeleteProcedure(std::string& result, const std::string& procedure_type,
const std::string& procedure_name, const std::string& graph = ""default"");
@param [out] result              The result.
@param [in]  procedure_type      the procedure type, currently supported CPP and PY.
@param [in]  procedure_name      procedure name.
@param [in]  graph               (Optional) the graph to query.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}","page_content='Java客户端

2.使用示例

2.10.删除存储过程

```java
String result = client.deleteProcedure(""CPP"", ""sortstr"", ""default"");
log.info(""loadProcedure : "" + result);
```
```
@param procedureType: the procedure type, currently supported CPP and PY
@param procedureName: procedure name
@param graph: the graph to query.
@return: the result of procedure execution
public boolean deleteProcedure(String procedureType, String procedureName, String graph) throws Exception
```
本接口支持在单机模式和HA模式下使用。其中，由于删除存储过程是写请求，HA模式下的client只能向leader发送删除存储过程请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.10.删除存储过程'}"
描绘 PairUniqueIndex 的钥匙生成形式是什么？,"page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。  
###### 1.3.1.1.2 non_unique索引  
点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的点的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。
但是，不同于unique索引，超过475bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
##### 1.3.1.2 边索引  
###### 1.3.1.2.1 unique索引  
和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。  
###### 1.3.1.2.2 pair_unique索引  
pair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，
相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，
索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。
因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。  
###### 1.3.1.2.3 non_unique索引  
和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）
2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节  
##### 1.3.2.1 唯一索引  
和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，
在同一个图中，相同label的点的该组属性不会存在相同的值。
由于底层存储设计，组合索引key需要保存属性的长度，因此，
组合唯一索引key的最大长度是480-2*(属性个数-1) bytes，**超过的属性不能建立唯一索引**。  
##### 1.3.2.2 非唯一索引  
和点的普通非唯一索引类似，点的非唯一索引指的是非全局唯一的索引，即若一组属性设置了非唯一索引，
在同一个图中，相同label的点的该组属性可以存在相同的值。
由于非唯一索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475-2*(属性个数-1) bytes，
**超过的属性不能建立非唯一索引**。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

配置文件包含两部分：schema 和 files。`schema`部分定义 label，`files`部分描述要导入的数据文件。  
#### 3.1.1.关键字  
- schema (数组形式）
- label（必选，字符串形式）
- type（必选，值只能是 VERTEX 或者 EDGE）
- properties（数组形式，对于点必选，对于边如果没有属性可以不配置）
- name（必选，字符串形式）
- type （必选，BOOL，INT8，INT16，INT32，INT64，DATE，DATETIME，FLOAT，DOUBLE，STRING，BLOB）
- optional（可选，代表该字段可以配置，也可以不配置）
- index（可选，该字段是否需要建索引）
- unique（可选，该字段是否建索引，并且是 unique 类型的，即全局唯一）
- pair_unique（可选，该字段是否建索引，并且是 pari_unique 类型的，即两点间唯一，仅用于边索引）unique与pair_unique只能设置一个，同时设置并运行将会因为输入异常而终止
- primary (仅点配置，必选，主键字段，需指定一个 property，用来唯一确定一个点)
- temproal (仅边配置，可选，指定时间戳属性用于存储层排序)
- temporal_field_order (仅边配置，可选，默认为""ASC""，表示升序，也可配置为""DESC""，表示降序)
- constraints (仅边配置，可选，数组形式，起点和终点的 label，不配置或者为空代表不限制)
- detach_property (点边都可配置，可选，默认是`false`。`true` 代表属性数据单独存放，在内存不够，属性数据比较多的场景下可以减少io读放大)
- files （数组形式）
- path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）
- header（可选，数字，头信息占文件起始的几行，没有就是 0）
- format（必须选，只能是 JSON 或者 CSV）
- label（必选，字符串）
- columns（数组形式）
- SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)
- DST_ID (特殊字符串，仅边有，代表这列是目的点数据)
- SKIP  (特殊字符串，代表跳过这列数据)
- [property]
- SRC_ID (仅边配置，值是起始点标签)
- DST_ID (仅边配置，值是目的点标签)  
#### 3.1.2.索引长度
因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。
##### 3.1.2.1.unique索引
unique索引是全局唯一的，该索引key的最大长度是480bytes。primary作为特殊的unique索引，因此最大key的长度也是480bytes，超过无法建立索引。
##### 3.1.2.2.pair_unique索引
pair_unique索引是指两点间唯一的索引，这种类型的索引只能创建于边的schema中，这种索引在用户指定的key后面加上了源点和目标点的vid，每个vid是5bytes长度。因此最大key的长度是470bytes，超过无法建立索引。
##### 3.1.2.3.非唯一索引
非唯一索引是指既没有设置unique为1，也没有设置pair_unique为1的索引，在TuGraph的实现中，此类索引一个key可能映射到多个值，为了加速查找和写入，在用户指定的key后面加上了一组vid或euid中的最大值。其中对于创建于点中的非唯一索引，key后面跟着vid，每个vid是5bytes长度，因此最大长度是475bytes。
对于创建于边中的非唯一索引，key后面跟着euid，每个euid是24bytes长度，因此最大长度是456bytes。索引key超过对应长度则会自动截断。' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.subgraph()

**Scope:** whole instance.  
**Parameters:**  
| parameter  | parameter type | description                                                           |
| ---------- | -------------- | --------------------------------------------------------------------- |
| vids       | list           | list of vertex id                                                     |  
**Output:**  
Get a json containing all the properties of nodes and relationships.  
**Example input:**  
```
CALL db.subgraph([3937,4126,4066,4010])
```  
**Example output**  
| subgraph |
| -------- |
| {""nodes"":[{""identity"":3937,""label"":""movie"",""properties"":{""duration"":136,""id"":1,""poster_image"":""http://image.tmdb.org/t/p/w185/gynBNzwyaHKtXqlEKKLioNkjKgN.jpg"",""rated"":""R"",""summary"":""Thomas A. Anderson is a man living two lives. By day he is an average computer programmer and by night a malevolent hacker known as Neo who finds himself targeted by the police when he is contacted by Morpheus a legendary computer hacker who reveals the shocking truth about our reality."",""tagline"":""Welcome to the Real World."",""title"":""The Matrix""}},{""identity"":4010,""label"":""user"",""properties"":{""id"":44,""login"":""Howard""}},{""identity"":4066,""label"":""user"",""properties"":{""id"":202,""login"":""Enoch""}},{""identity"":4126,""label"":""user"",""properties"":{""id"":464,""login"":""Wilburn""}}],""relationships"":[{""dst"":4126,""forward"":true,""identity"":0,""label"":""is_friend"",""label_id"":3,""src"":4010,""temporal_id"":0},{""dst"":4010,""forward"":true,""identity"":0,""label"":""is_friend"",""label_id"":3,""src"":4066,""temporal_id"":0},{""dst"":4066,""forward"":true,""identity"":0,""label"":""is_friend"",""label_id"":3,""src"":4126,""temporal_id"":0}]} |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.subgraph()'}"
在上述文本中，类FieldData用于表示哪些类型的数据？,"page_content='OlapBase API

6. 自定义数据结构

6.2 组合数据结构

为了便于计算，我们根据计算场景不同，定义了几种点和边数据的数据结构，分别是：  
- `EdgeUnit<EdgeData>`：表示权值类型为EdgeData的边，用于解析输入文件，包含三个成员变量：
- `size_t src`：边的起始点
- `size_t dst`：边的终点
- `EdgeData edge_data`：边的权值
- `AdjUnit<EdgeData>`：表示权值类型为EdgeData的边，用于批处理计算过程中，包含两个成员变量：
- `size_t neighbour`：边的邻居点
- `EdgeData edge_data`：边的权值
- `AdjList<EdgeData>`：权值类型为EdgeData的点的邻接表，常用于表示点的入边和出边集合，包含两个成员变量：
- `AdjUnit<T> * begin`：列表的起始指针
- `AdjUnit<T> * end`：列表的结束指针。begin和end的用法类似于vector容器的begin和end指针，可以使用这两个指针对邻接表进行循环访问。' metadata={'Header 1': 'OlapBase API', 'Header 2': '6. 自定义数据结构', 'Header 3': '6.2 组合数据结构'}","page_content='TuGraph图模型说明

1. 数据模型

1.2. 数据类型

TuGraph支持多种可用于属性的数据类型。具体支持的数据类型如下：  
| **数据类型** | **最小值**          | **最大值**          | **描述**                            |
| ------------ | ------------------- | ------------------- | ----------------------------------- |
| BOOL         | false               | true                | 布尔值                              |
| INT8         | -128                | 127                 | 8位整型                          |
| INT16        | -32768              | 32767               | 16位整型                         |
| INT32        | - 2^31              | 2^31 - 1            | 32位整型                         |
| INT64        | - 2^63              | 2^63 - 1            | 64位整型                         |
| DATE         | 0000-00-00          | 9999-12-31          | ""YYYY-MM-DD"" 格式的日期             |
| DATETIME     | 0000-00-00 00:00:00.000000 | 9999-12-31 23:59:59.999999 | ""YYYY-MM-DD HH:mm:ss[.ffffff]"" 格式的日期时间 |
| FLOAT        |                     |                     | 32位浮点数                       |
| DOUBLE       |                     |                     | 64位浮点数                       |
| STRING       |                     |                     | 不定长度的字符串                    |
| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |
| POINT        |                     |                     | EWKB格式数据，表示点              |
| LINESTRING   |                     |                     | EWKB格式数据，表示线              |
| POLYGON      |                     |                     | EWKB格式数据，表示面(多边形)       |
| FLOAT_VECTOR |                     |                     | 包含32位浮点数的动态向量               |' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.2. 数据类型'}","page_content='地理空间数据类型使用示例

3. 数据类型

目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:  
- Point：点    point(2.0, 2.0, 7203)
- Linestring：折线 LINESTRING(0 2,1 1,2 0)
- Polygon：多边形  POLYGON((0 0,0 7,4 2,2 0,0 0))  
其中坐标点都是double型，创建图模型和插入数据示例如下：  
**创建标记美食位置的点模型**  
```
CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)
```  
![image.png](../../../images/spatail/createVertexLabel.png)  
**插入标记美食点的数据**  
```
CREATE (n:food {id:10001, name: 'aco Bell',pointTest:point(3.0,4.0,7203)}) RETURN n
```  
![image.png](../../../images/spatail/createFoodData.png)  
**创建具有折线属性的点模型**  
```
CALL db.createVertexLabel('lineTest', 'id', 'id', int64, false, 'name', string, true,'linestringTest',linestring,true)
```  
![image.png](../../../images/spatail/createVertexLabel_lineTest.png)  
**插入具有折线属性的点数据**  
```
CREATE (n:lineTest {id:102, name: 'Tom',linestringTest:linestringwkt('LINESTRING(0 2,1 1,2 0)', 7203)}) RETURN n
```  
![image.png](../../../images/spatail/createLineTestData.png)  
**创建具有多边型属性的点模型**  
```
CALL db.createVertexLabel('polygonTest', 'id', 'id', int64, false, 'name', string, true,'polygonTest',polygon,true)
```  
![image.png](../../../images/spatail/createVertexLabel_PolygonTest.png)  
**插入具有多边型属性的点数据**  
```
CREATE (n:polygonTest {id:103, name: 'polygonTest',polygonTest:polygonwkt('POLYGON((0 0,0 7,4 2,2 0,0 0))', 7203)}) RETURN n
```' metadata={'Header 1': '地理空间数据类型使用示例', 'Header 2': '3. 数据类型'}"
在线全量导入TuGraph时，如果发生数据包错误，默认行为是什么？,"page_content='数据导入

5.在线增量导入

在线导入模式可用于将一批文件导入已在运行中的 TuGraph 实例中。这对于处理通常以固定的时间间隔进行的增量批处理更新非常便利。`lgraph_import --online true`选项使导入工具能够在线模式工作。与`离线模式`一样，在线模式有自己的命令行选项集，可以使用`-h，--help`选项进行打印输出：  
```shell
$ lgraph_import --online true -h
Available command line options:
--online            Whether to import online.
-h, --help          Print this help message. Default=0.

Available command line options:
--log               Log file to use, empty means stderr. Default="""".
-v, --verbose       Verbose level to use, higher means more verbose.
Default=1.
-c, --config_file   Config file path.
-r, --url           DB REST API address.
-u, --username      DB username.
-p, --password      DB password.
-i, --continue_on_error
When we hit a duplicate uid or missing uid, should we
continue or abort. Default=0.
-g, --graph         The name of the graph to import into. Default=default.
--skip_packages     How many packages should we skip. Default=0.
--delimiter         Delimiter used in the CSV files
--breakpoint_continue
When the transmission process is interrupted,whether
to re-transmit from zero package next time. Default=false
-h, --help          Print this help message. Default=0.
```  
文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据发送到正在运行的 TuGraph 实例中，该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。  
如果用户和密码有效，并且指定的图存在，导入工具将将数据发送到服务器，服务器随后解析数据并将其写入指定的图。数据将以大约 16MB 大小的包发送，在最近的换行符处中断。每个包都是以原子方式导入的，这意味着如果成功导入包，则成功导入所有数据，否则，任何数据都不会进入数据库。如果指定了`--continue_on_error true`，则忽略数据完整性错误，并忽略违规行。否则，导入将在第一个错误包处停止，并打印出已导入的包数。在这种情况下，用户可以修改数据以消除错误，然后使用`--skip_packages N`重做导入以跳过已导入的包。' metadata={'Header 1': '数据导入', 'Header 2': '5.在线增量导入'}","page_content='数据导入

6.在线全量导入

6.1 从原数据导入

从原数据导入的执行方式是向运行中的TuGraph实例发送导入请求，
实例接到请求后先使用离线导入（V3）的方式将数据导入一个临时的db中，然后在实例中新建子图并将临时db的数据文件迁移到新子图中，最后刷新实例的元数据。
相比在线增量导入，在线全量导入的性能更高。
`lgraph_import --online true --online_type 1`选项使导入工具能够在线全量导入。
与`离线模式`一样，在线模式有自己的命令行选项集，可以使用`-h，--help`选项进行打印输出：  
```shell
$ lgraph_import --online true --online_type 1 -h
Available command line options:
--online_type       The type of import online, 0 for increment, 1 for full
import data,2 for full import file. Default=0.
--v3                Whether to use lgraph import V3. Default=1.
-h, --help          Print this help message. Default=0.

Available command line options:
--full              Whether to full import online. Default=0.
-h, --help          Print this help message. Default=0.

Available command line options:
-c, --config_file   Config file path.
-r, --url           DB REST API address.
-u, --user          DB username.
-p, --password      DB password.
-i, --continue_on_error
When we hit a duplicate uid or missing uid, should we
continue or abort. Default=0.
-g, --graph         The name of the graph to import into. Default=default.
--delimiter         Delimiter used in the CSV files. Default=,.
--log               Log dir to use, empty means stderr. Default="""".
-v, --verbose       Verbose level to use, higher means more verbose.
Default=1.
--overwrite         Whether to overwrite the existing DB if it already
exists. Default=0.
--parse_block_size  Block size per parse. Default=8388608.
--parse_block_threads
How many threads to parse the data block. Default=5.
--parse_file_threadsHow many threads to parse the files. Default=5.
--generate_sst_threads
How many threads to generate sst files. Default=15.
--read_rocksdb_threads
How many threads to read rocksdb in the final stage.
Default=15.
--vid_num_per_reading
How many vertex data to read each time. Default=10000.
--max_size_per_reading
Maximum size of kvs per reading. Default=33554432.
--compact           Whether to compact. Default=0.
--keep_vid_in_memoryWhether to keep vids in memory. Default=1.
--enable_fulltext_index
Whether to enable fulltext index. Default=0.
--fulltext_index_analyzer
fulltext index analyzer. Default=StandardAnalyzer.
Possible values: {<2>: SmartChineseAnalyzer,
StandardAnalyzer}
-h, --help          Print this help message. Default=0.
```  
文件的相关配置在配置文件中指定，其格式与`离线模式`完全相同。但是，我们现在不是将数据导入本地数据库，而是将数据导入正在运行的 TuGraph 实例中，
该实例通常运行在与运行导入工具的客户端计算机不同的计算机上。因此，我们需要指定远程计算机的 HTTP 地址的URL、DB用户和密码。
并且，配置文件（config_file参数）要求是 TuGraph 实例机器上的uri路径，其file配置也要求是 TuGraph 实例机器上资源的绝对路径。  
如果用户和密码有效，导入工具将在服务器端执行在线全量导入。如果想导入的图已存在，可以使用`--overwrite true` 选项强制覆盖子图。' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入', 'Header 3': '6.1 从原数据导入'}","page_content='数据导入

6.在线全量导入

在线全量导入可用于将一批文件导入运行中的TuGraph实例，TuGraph支持将两种不同类型的数据在线导入到实例中：
1. 和离线导入类型相同的原数据文件（csv等）
2. TuGraph的底层存储文件，即data.mdb文件，该文件可以由离线导入生成，也可以是其他TuGraph db的文件。
这两种方式的适用场景不同，第一种是直接将数据导入到TuGraph中，优点是一次性自动导入，操作步骤简单。但是会在server端启动一个离线导入线程，
只适合单机情况下的小规模数据导入。第二种是将已经准备好的底层存储文件导入到TuGraph中，虽然需要提前准备好mdb文件，但是对系统资源却没有很高的要求，
而且支持远程下载文件导入，非常方便，适用于高可用模式或者大规模数据的在线导入。' metadata={'Header 1': '数据导入', 'Header 2': '6.在线全量导入'}"
ORDER BY在GQL中有什么作用？,"page_content='ISO GQL

2.Clauses

2.6.ORDER BY

`ORDER BY`是`RETURN`的子句，对输出的结果进行排序。  
#### 对结果排序  
```
MATCH (n:Person WHERE n.birthyear < 1970)
RETURN n.birthyear AS q
ORDER BY q ASC
LIMIT 5
```  
返回结果
```JSON
[{""q"":1873},{""q"":1908},{""q"":1910},{""q"":1930},{""q"":1932}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.6.ORDER BY'}","page_content='Example

Order By

```sql
SELECT * from user order by age;

SELECT age, count(id) as cnt FROM user GROUP BY age Having count(id) > 10 Order by cnt;
```' metadata={'Header 1': 'Example', 'Header 2': 'Order By'}","page_content='ISO GQL

2.Clauses

2.1.MATCH

`MATCH`子句式是GQL最基础的子句，几乎所有查询都是通过 `MATCH`展开。  
`MATCH`子句用于指定在图中搜索的匹配模式，用来匹配满足一定条件的点或者路径。  
#### 点查询  
##### 查询所有点  
```
MATCH (n)
RETURN n
```  
##### 查询特定标签的点  
```
MATCH (n:Person)
RETURN n
```  
##### 通过属性匹配点  
```
MATCH (n:Person{name:'Michael Redgrave'})
RETURN n.birthyear
```  
返回结果
```JSON
[{""n.birthyear"":1908}]
```  
##### 通过过滤条件匹配点  
```
MATCH (n:Person WHERE n.birthyear > 1910)
RETURN n.name LIMIT 2
```  
返回结果
```JSON
[{""n.name"":""Christopher Nolan""},{""n.name"":""Corin Redgrave""}]
```  
#### 边查询  
##### 出边匹配  
```
MATCH (n:Person WHERE n.birthyear = 1970)-[e]->(m)
RETURN n.name, label(e), m.name
```  
返回结果
```JSON
[{""label(e)"":""BORN_IN"",""m.name"":""London"",""n.name"":""Christopher Nolan""},{""label(e)"":""DIRECTED"",""m.name"":null,""n.name"":""Christopher Nolan""}]
```  
##### 入边匹配  
```
MATCH (n:Person WHERE n.birthyear = 1939)<-[e]-(m)
RETURN n.name, label(e), m.name
```  
返回结果
```JSON
[{""label(e)"":""HAS_CHILD"",""m.name"":""Rachel Kempson"",""n.name"":""Corin Redgrave""},{""label(e)"":""HAS_CHILD"",""m.name"":""Michael Redgrave"",""n.name"":""Corin Redgrave""}]
```  
##### 带过滤条件的边匹配  
```
MATCH (n:Person)-[e:BORN_IN WHERE e.weight > 20]->(m)
RETURN n.name, e.weight, m.name
```  
返回结果
```JSON
[{""e.weight"":20.549999237060547,""m.name"":""New York"",""n.name"":""John Williams""},{""e.weight"":20.6200008392334,""m.name"":""New York"",""n.name"":""Lindsay Lohan""}]
```  
#### 路径匹配  
##### 不定跳查询  
```
MATCH (n:Person)-[e]->{2,3}(m:Person)
RETURN m.name LIMIT 2
```  
返回结果
```JSON
[{""m.name"":""Liam Neeson""},{""m.name"":""Natasha Richardson""}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.1.MATCH'}"
TuGraph-DB是否有http的接口？对应的接口代码在哪里？,"page_content='可视化操作手册

2.操作指南

2.1.访问

当用户完成图数据库的安装后，可以通过浏览器访问Browser。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7070。  
- 例如：127.0.0.1:7070。
- 推荐使用Chrome。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.1.访问'}","page_content='可视化操作手册（旧版）

操作详情

1.连接数据库

当用户完成图数据库的安装后，可以通过浏览器进行访问，TuGraph Browser 工具。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7090。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '1.连接数据库'}","page_content='RESTful API Legacy

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。  
**注意：除""登陆""、""查询""和""存储过程""外，其余接口自 **2023年4月30日** 起将不再提供支持，统一使用Cypher接口提供服务。**' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '1.简介'}"
请问lgraph_peer工具是只有编译方式部署后才有吗？,"page_content='Procedure API

5.Procedure v2接口

5.1.编写存储过程

用户可以通过使用 lgraph API 来编写 C++ 存储过程。一个简单的 C++ 存储过程举例如下：  
```c++
// peek_some_node_salt.cpp
#include <cstdlib>
#include ""lgraph/lgraph.h""
#include ""lgraph/lgraph_types.h""
#include ""lgraph/lgraph_result.h""

#include ""tools/json.hpp""

using json = nlohmann::json;
using namespace lgraph_api;

extern ""C"" LGAPI bool GetSignature(SigSpec &sig_spec) {
sig_spec.input_list = {
{.name = ""limit"", .index = 0, .type = LGraphType::INTEGER},
};
sig_spec.result_list = {
{.name = ""node"", .index = 0, .type = LGraphType::NODE},
{.name = ""salt"", .index = 1, .type = LGraphType::FLOAT}
};
return true;
}

extern ""C"" LGAPI bool ProcessInTxn(Transaction &txn,
const std::string &request,
Result &response) {
int64_t limit;
try {
json input = json::parse(request);
limit = input[""limit""].get<int64_t>();
} catch (std::exception &e) {
response.ResetHeader({
{""errMsg"", LGraphType::STRING}
});
response.MutableRecord()->Insert(
""errMsg"",
FieldData::String(std::string(""error parsing json: "") + e.what()));
return false;
}

response.ResetHeader({
{""node"", LGraphType::NODE},
{""salt"", LGraphType::FLOAT}
});
for (size_t i = 0; i < limit; i++) {
auto r = response.MutableRecord();
auto vit = txn.GetVertexIterator(i);
r->Insert(""node"", vit);
r->Insert(""salt"", FieldData::Float(20.23*float(i)));
}
return true;
}
```  
从代码中我们可以看到：
- 存储过程定义了一个获取签名的方法`GetSignature`。该方法返回了存储过程的签名，其中包含输入参数名称及其类型，返回参数及其类型。这使得Cypher查询语句在调用存储过程能够利用签名信息校验输入数据以及返回数据是否合理。
- 入口函数是`ProcessInTxn`函数，它的参数有三个，分别为：  
- `txn`: 存储过程所处的事务，通常来说即调用该存储过程的Cypher语句所处事务。
- `request`: 输入数据，其内容为`GetSignature`中定义的输入参数类型及其Cypher查询语句中传入的值经过json序列化后的字符串。e.g. `{num_iteration: 10}`
- `response`: 输出数据，为保证在Cypher语言中能够兼容，用户可以通过往`lgraph_api::Result` 写入存储过程处理后的数据，最后用`lgraph_api::Result::Dump`来序列化成json格式的数据。  
`ProcessInTxn`函数的返回值是一个布尔值。当它返回`true`的时候，表示该请求顺利完成，反之表示这个存储过程在执行过程中发现了错误。  
C++存储过程编写完毕后需要编译成动态链接库。TuGraph 提供了`compile.sh`脚本来帮助用户自动编译存储过程。`compile.sh`脚本只有一个参数，是该存储过程的名称，在上面的例子中就是`custom_pagerank`。编译调用命令行如下：  
```bash
g++ -fno-gnu-unique -fPIC -g --std=c++14 -I/usr/local/include/lgraph -rdynamic -O3 -fopenmp -o custom_pagerank.so custom_pagerank.cpp /usr/local/lib64/liblgraph.so -shared
```  
如果编译顺利，会生成 custom_pagerank.so，然后用户就可以将它加载到服务器中了。' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.1.编写存储过程'}","page_content='快速上手

2.安装

2.2.新旧前端说明

进入容器，可以通过修改配置文件""/usr/local/etc/lgraph.json""中的""web""参数来选择使用老版本或新版本的前端。对于老版本，可以将""web""的值设为""/usr/local/share/lgraph/resource""；对于新版本，可以将""web""的值设为""/usr/local/share/lgraph/browser-resource""。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.2.新旧前端说明'}","page_content='命令行工具

1.单命令模式

在单命令模式下，`lgraph_cypher`可用于提交单个 Cypher 查询并将结果直接打印到终端，打印结果也可以容易地重定向写入指定文件。当用户需要从服务器获取大量结果并将其保存在文件中时，这非常便利。
在此模式下，`lgraph_cypher`工具具有以下选项：' metadata={'Header 1': '命令行工具', 'Header 2': '1.单命令模式'}"
当前图数据库应用程序使用的CPU比率是多少？,"page_content='性能优先

1.简介

TuGraph目前是世界上最快的图数据库，在图数据库标准评测LDBC SNB Interactive位居榜首（2023.3）。TuGraph的设计基于性能优先，致力于打造高性能的单机图数据库。该文档是TuGraph基于性能优先在存储层的核心设计。' metadata={'Header 1': '性能优先', 'Header 2': '1.简介'}","page_content='TuGraph与ARM架构

内容：

**背景介绍：**

在高速信息化的21世纪，计算机软硬件均经历着翻天覆地的变化，从Intel和AMD的x86 CPU架构到ARM RISC精简指令CPU，内存也演进出超高带宽内存HBM、非易失内存NVM。近年来基于ARM架构的CPU越来越普遍，在手机中ARM芯片已占90%以上份额，个人PC中苹果M1/M2均采用ARM架构，在服务器领域华为鲲鹏、飞腾等ARM架构CPU也逐步被接纳。本次测试使用的倚天710，是阿里基于ARMv9架构自研的CPU，已在阿里云服务中大规模部署，成为中国首个云上大规模应用的自研CPU。  
数据库作为底层系统软件，面对CPU的更新换代也迎来了更多的挑战和机遇。在ARM架构中，CPU通常拥有更多的核数、更低的能耗、更高的性价比。作为拥抱开源的图数据库产品，TuGraph不仅需要兼容新型硬件，更需要充分发挥出新硬件的功能和性能优势。适配和测试工作包括超多线程的支持、更加细致的负载均衡策略、并发读写性能优化等。  
**本次测试机构国际关联数据基准委员会LDBC是由高校、研究所、企业联合组成的非盈利组织，其中企业成员包括Intel、Oracle、Neo4j、蚂蚁集团等国内外知名图数据厂商，致力于推进图数据的规范标准化。**本次测试使用的图数据来自LDBC的社交网络运营场景SNB（Social Network Benchmark），LDBC SNB的图数据是一个包含14类顶点和20类边的属性图，用户可以指定scale factor生成不同规模的数据。LDBC SNB的交互式工作负载由14个复杂的只读查询、7个简单的只读查询和8个事务型更新查询组成。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**背景介绍：**'}","page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}"
