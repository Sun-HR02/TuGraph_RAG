Q,K1,K2,K3,K4,K5,K6,K7,K8,K9,K10
在添加边时，如果指定的值不包含在value_dict中，将会发生什么？具体会如何处理这种情况？,"page_content='src/python/python_api.cpp/ ""AddEdge"",
            [](Transaction& a, int64_t src, int64_t dst, std::string& label,
               const pybind11::dict& value_dict) {
                std::vector<std::string> fnames;
                std::vector<FieldData> fdata;
                PyDictToVectors(value_dict, fnames, fdata);
                return a.AddEdge(src, dst, label, fnames, fdata);
            },
            ""Adds an edge from src to dst with the specified label, and fill it ""
            ""with the values given in value_dict.\n""
            ""Returns the id of the newly added edge.\n""
            ""Fields that are not in value_dict are considered null."",
            pybind11::arg(""src""), pybind11::arg(""dst""), pybind11::arg(""label_name""),
            pybind11::arg(""value_dict""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""UpsertEdge"",
            [](Transaction& a, int64_t src, int64_t dst, std::string& label,
               const pybind11::dict& value_dict) {
                std::vector<std::string> fnames;
                std::vector<FieldData> fdata;
                PyDictToVectors(value_dict, fnames, fdata);
                return a.UpsertEdge(src, dst, label, fnames, fdata);
            },
            ""Upserts an edge from src to dst with the specified label, and fill ""
            ""it with the values given in value_dict.\n""
            ""If an src->dst edge already exists, it is updated with the new ""
            ""value. Otherwise a new edge is created.\n""
            ""Returns True if the edge is created, False if the edge is updated.\n""
            ""Fields that are not in value_dict are considered null."",
            pybind11::arg(""src""), pybind11::arg(""dst""), pybind11::arg(""label_name""),
            pybind11::arg(""value_dict""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""AddVertex"",
            [](Transaction& a, const std::string& label_name, const pybind11::dict& value_dict) {
                std::vector<std::string> fnames;
                std::vector<FieldData> fdata;
                PyDictToVectors(value_dict, fnames, fdata);
                return a.AddVertex(label_name, fnames, fdata);
            },
            ""Adds a vertex with the specified label name and set the value as ""
            ""specified in value_dict.\n""
            ""Returns the id of the newly added vertex.\n""
            ""Fields that are not specified in the dict are considered null."",
            pybind11::arg(""label_name""), pybind11::arg(""value_dict""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}",空,空,空,空,空,空,空
如何使用LIMIT子句从TuGraph中查询前两个人的名字，返回的名字会是什么？,"page_content='TuGraph console client

`lgraph_cli`使用

TuGraph>
```  
语句可以中间换行，多行输入。  
```powershell
TuGraph> match(n)
-> return n
-> limit 1;
+-------------------------------------------------------------------------------------------------------------------------------------+
| n                                                                                                                                   |' metadata={'Header 1': 'TuGraph console client', 'Header 2': '`lgraph_cli`使用'}","page_content='TuGraph console client

`lgraph_cli`使用

TuGraph> match(n) return n limit 1;
+-------------------------------------------------------------------------------------------------------------------------------------+
| n                                                                                                                                   |
+-------------------------------------------------------------------------------------------------------------------------------------+' metadata={'Header 1': 'TuGraph console client', 'Header 2': '`lgraph_cli`使用'}","page_content='TuGraph console client

`lgraph_cli`使用

echo ""match(n) return n limit 1;"" | lgraph_cli --ip 127.0.0.1 --port 7687 --graph default --user admin --password 73@TuGraph
+-------------------------------------------------------------------------------------------------------------------------------------+
| n                                                                                                                                   |' metadata={'Header 1': 'TuGraph console client', 'Header 2': '`lgraph_cli`使用'}",空,空,空,空,空,空,空
如何查询TuGraph数据库中现有角色及其相关信息？,"page_content='部署高可用模式

9.查看服务器状态

备份组的当前状态可以在 TuGraph 可视化工具、REST API 以及 Cypher 查询中获取。  
在 TuGraph 可视化工具中，可以在 DBInfo 部分中找到备份组中的服务器及其角色列表。  
使用 REST API 时，可以使用`GET /info/peers` 请求获取信息。  
在 Cypher 中，使用`CALL dbms.listServers()`语句来查询当前备份组的状态信息。' metadata={'Header 1': '部署高可用模式', 'Header 2': '9.查看服务器状态'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

![角色管理-删除](../../../images/browser/role-delete.png)  
#### 2.5.2.数据库信息  
##### 2.5.2.1.基础信息  
`基础信息`获取当前系统运行的状态，并展示关键信息。  
![数据库信息-基础信息](../../../images/browser/db_basic.png)  
|参数    |含义    |
|-------|--------|
|TuGraph版本号|当前TuGraph的版本号，x.x.x|
|运行时间|TuGraph服务启动到现在的时间|
|服务器代码版本|tugraph-db仓库的当前commit|
|前端代码版本|tugraph-web仓库的当前commit|
|CPP编译器版本号|编译TuGraph时的CPP版本号|
|Python版本号|编译TuGraph时的Python版本号|
|CPP编译器ID|编译TuGraph时的CPP类型|  
也可以通过命令获取当前系统运行状态。  
```
CALL dbms.system.info()' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

#### 3.4 控制台  
##### 3.4.1 数据库基础信息  
- 展示数据库相关的基础配置信息
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/17.tugraph-browser-config.png)  
##### 3.4.2 权限管理  
- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/18.tugraph-browser-auth.png)  
##### 3.4.3 实时状态  
- 这里展示了数据库实时状态，包括：CPU 使用率、内存用率、磁盘使用率、数据请求次数、磁盘 IO' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

|运行时间|TuGraph服务启动到现在的时间|
|服务器代码版本|tugraph-db仓库的当前commit|
|前端代码版本|tugraph-web仓库的当前commit|
|CPP编译器版本号|编译TuGraph时的CPP版本号|
|Python版本号|编译TuGraph时的Python版本号|
|CPP编译器ID|编译TuGraph时的CPP类型|  
也可以通过命令获取当前系统运行状态。  
```
CALL dbms.system.info()
```  
##### 2.5.2.2.数据库配置信息  
`数据库配置信息`获取当前系统运行的配置参数，并展示关键信息。调整配置参数或了解详细配置参数请参考[数据库运行-服务配置](../5.installation&running/7.tugraph-running.md)。  
![数据库信息-数据库配置信息](../../../images/browser/db_configuration.png)' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.3.6 帮助  
- 其中记录了 TuGraph-browser 的使用方式
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)  
#### 3.4 控制台  
##### 3.4.1 数据库基础信息  
- 展示数据库相关的基础配置信息
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/17.tugraph-browser-config.png)  
##### 3.4.2 权限管理  
- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}",空,空,空,空,空
TuGraph可以最多创建多少个点和边？此外，在点和边上最多可以创建多少个属性？,"page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。
- 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。
- 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

2. 图项目、点、边、属性命名规则和建议

2.2 使用限制

|**描述**|**最大个数**|
|-------- |--------- |
|用户数、角色数|65536|
|图项目的个数|4096|
|每个图项目的点和边类型数量之和|4096|
|每个点或边类型的属性数量|1024|  
注：
1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；  
示例： ```match (`match`:match) return `match`.id limit 1```  
2、大小写敏感性：TuGraph大小写敏感；  
3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；  
4、属性名字保留关键字：SRC_ID / DST_ID / SKIP' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '2. 图项目、点、边、属性命名规则和建议', 'Header 3': '2.2 使用限制'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}",空,空,空,空,空
请问在启动TuGraph 4.3.2镜像后，进入容器时没有找到setup.sh脚本，是不是因为当前工作目录已经更改？,"page_content='开始上手(GeaFlow Console运行)

准备工作

x86架构拉取x86镜像：
```shell
docker pull tugraph/geaflow-console:0.1
```  
如果是arm架构，拉取arm镜像：
```shell
docker pull tugraph/geaflow-console-arm:0.1
```  
如果遇到网络问题导致拉取失败，也可以通过下面命令直接构建镜像(构建镜像之前需要先启动docker容器,构建脚本根据机器类型build对应类型的镜像):  
```shell
git clone https://github.com/TuGraph-family/tugraph-analytics.git
cd tugraph-analytics/
bash ./build.sh --all' metadata={'Header 1': '开始上手(GeaFlow Console运行)', 'Header 2': '准备工作'}","page_content='src/client/python/TuGraphClient/setup.py/ from setuptools import setup

setup(
    name='TuGraphClient',
    version='2.0',
    description='rest client for TuGraph',
    install_requires=[
        'httpx',
    ],
    packages=[''],
    entry_points={}
)' metadata={'file_name': 'setup.py', 'file_path': 'src/client/python/TuGraphClient/setup.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/TuGraphClient/setup.py'}","page_content='src/python/FMA_shell/setup.py/ from setuptools import setup

setup(
    name=""lgraph_cypher"",
    description='cypher quarry command line tool for TuGraph',
    install_requires=[
        'click==7.0',
        'prompt_toolkit==2.0.9',
        'prettytable==0.7.2',
        'requests==2.32.2',
    ],
    packages=['lgraph_shell'],
    entry_points={
        'console_scripts': [
            'lgraph_cypher = lgraph_shell.lgraph_cypher:start'
        ]
    }
)' metadata={'file_name': 'setup.py', 'file_path': 'src/python/FMA_shell/setup.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/FMA_shell/setup.py'}","page_content='TuGraph Management

使用

TuGraph Management使用Maven进行管理，请运行如下命令启动TuGraph Management  
`mvn spring-boot:run`  
TuGraph Management 使用了sofastack框架，并使用brpc与TuGraph进行通信，sofastack默认端口为`6071`，brpc默认端口为`6091`，如需修改服务端口，请修改`./src/main/resources/application.properties`文件中的对应配置项。' metadata={'Header 1': 'TuGraph Management', 'Header 2': '使用'}","page_content='本地包部署

4. Ubuntu 下的安装方法

用于在 Ubuntu 上安装的 TuGraph 的.deb 安装包，其中包含了 TuGraph 可执行文件以及编写嵌入式程序和存储过程所需的头文件和相关库文件。  
使用已经下载完成的`tugraph_x.y.z.deb`安装包在终端下安装，只需要运行以下命令：  
```shell
$ sudo dpkg -i tugraph-x.y.z.deb
```  
该命令默认将 TuGraph 安装于`/usr/local`目录下。用户也可以通过指定 `--instdir=<directory>` 选项更改安装目录。' metadata={'Header 1': '本地包部署', 'Header 2': '4. Ubuntu 下的安装方法'}",空,空,空,空,空
如何通过lgraph_server -d start命令启动时生成的pid文件指定路径，并且这个pid文件是否有参数可以控制其存储位置？,空,空,空,空,空,空,空,空,空,空
如何在使用ARM机器（如M1芯片的Mac）时修改cmake命令以编译TuGraph？,"page_content='从源码编译

2.编译介绍

以下是编译TuGraph的步骤：  
1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤
2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`，如果在arm机器编译（如M1芯片的Mac中，需要加上` -DENABLE_BUILD_ON_AARCH64=ON`）
3. `make`
4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build' metadata={'Header 1': '从源码编译', 'Header 2': '2.编译介绍'}","page_content='TuGraph-db

3. 从源代码编译

建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile]  
以下是编译TuGraph的步骤：  
1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤
2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`
3. `make`
4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build' metadata={'Header 1': 'TuGraph-db', 'Header 2': '3. 从源代码编译'}","page_content='TuGraph-db

3. 从源代码编译

4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build
$ cmake .. -DOURSYSTEM=centos7
$ make
$ make package
```' metadata={'Header 1': 'TuGraph-db', 'Header 2': '3. 从源代码编译'}","page_content='开始上手(GeaFlow Console运行)

准备工作

x86架构拉取x86镜像：
```shell
docker pull tugraph/geaflow-console:0.1
```  
如果是arm架构，拉取arm镜像：
```shell
docker pull tugraph/geaflow-console-arm:0.1
```  
如果遇到网络问题导致拉取失败，也可以通过下面命令直接构建镜像(构建镜像之前需要先启动docker容器,构建脚本根据机器类型build对应类型的镜像):  
```shell
git clone https://github.com/TuGraph-family/tugraph-analytics.git
cd tugraph-analytics/
bash ./build.sh --all' metadata={'Header 1': '开始上手(GeaFlow Console运行)', 'Header 2': '准备工作'}",空,空,空,空,空,空
在启动参数中，cleanup_dir指定的目录用于执行什么操作？,"page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

##### 2.2.5.2.启动命令  
通过fixtures组件引入工具，并通过启动参数来控制备份不同的binlog，函数开始执行前会拷贝binlog到指定的目录，函数执行完成后会清理cleanup_dir指定的目录  
```python
@pytest.mark.parametrize(""backup_binlog"", [BINLOGOPT], indirect=True)
def test_backup_binlog(self, backup_binlog):
pass
```  
#### 2.2.6.backup_copy_dir  
##### 2.2.6.1.启动参数
采用python字典传入
+ cmd是启动命令
+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入  
```python
BACKUPOPT = {""cmd"" : ""./lgraph_backup --src ./testdb -dst ./testdb1"",
""cleanup_dir"":[]}
```' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}","page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

```  
##### 2.2.6.2.启动命令  
通过fixtures组件引入工具，并通过启动参数来控制备份不同的db，函数开始执行前会拷贝db到指定的目录，函数执行完成后会清理cleanup_dir指定的目录  
```python
@pytest.mark.parametrize(""backup_copy_dir"", [BACKUPOPT], indirect=True)
def test_backup_copy_dir(self, backup_copy_dir):
pass
```  
#### 2.2.7.build_so  
##### 2.2.7.1.启动参数
采用python字典传入
+ cmd是启动命令，采用python列表传入，可以一次编译多个so
+ so_name是执行完成后需要清理的so，可以是多个，通过python列表传入  
```python' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}","page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

```  
##### 2.2.4.2.启动命令  
通过fixtures组件引入工具，并通过启动参数来控制导出不同的数据，函数开始执行前会导出数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录  
```python
@pytest.mark.parametrize(""exportor"", [EXPORT_DEF_OPT], indirect=True)
def test_exportor(self, exportor):
pass
```  
#### 2.2.5.backup_binlog  
##### 2.2.5.1.启动参数
采用python字典传入
+ cmd是启动命令
+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入  
```python' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}","page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

""cleanup_dir"":[""./testdb""]}
```  
##### 2.2.1.2.启动命令
通过fixtures组件引入工具，并通过启动参数来控制不同的处理逻辑，函数开始执行前会启动server，函数执行完成后会停止server，并清理cleanup_dir指定的目录  
```python
@pytest.mark.parametrize(""server"", [SERVEROPT], indirect=True)
def test_server(self, server):
pass
```  
#### 2.2.2.client  
##### 2.2.2.1.启动参数
采用python字典传入
+ host是TuGraph Server的ip和端口
+ user是TuGraph Server的用户名
+ password是TuGraph Server 中user对应的密码  
```python' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}","page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

""cleanup_dir"":[""./testdb"", ""./.import_tmp""]}
```  
##### 2.2.3.2.启动命令  
通过fixtures组件引入工具，并通过启动参数来控制导入不同的数据，函数开始执行前会导入数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录  
```python
@pytest.mark.parametrize(""importor"", [IMPORTOPT], indirect=True)
def test_importor(self, importor):
pass
```  
#### 2.2.4.exportor  
##### 2.2.4.1.启动参数
采用python字典传入
+ cmd是启动命令
+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入  
```python' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}",空,空,空,空,空
如何使用什么命令来启动 TuGraph？,"page_content='数据库运行

3.服务操作

3.1.启动服务

TuGraph 需要通过 `lgraph_server -d start` 命令行启动，启动命令示例如下：  
```bash
$ ./lgraph_server -d start -c lgraph.json
Starting lgraph...
The service process is started at pid 12109.
```  
此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.1.启动服务'}","page_content='TuGraph Management

使用

TuGraph Management使用Maven进行管理，请运行如下命令启动TuGraph Management  
`mvn spring-boot:run`  
TuGraph Management 使用了sofastack框架，并使用brpc与TuGraph进行通信，sofastack默认端口为`6071`，brpc默认端口为`6091`，如需修改服务端口，请修改`./src/main/resources/application.properties`文件中的对应配置项。' metadata={'Header 1': 'TuGraph Management', 'Header 2': '使用'}","page_content='数据库运行

2.运行模式

2.1.运行普通进程

`lgraph_server -d run`命令可以将 TuGraph 作为普通进程运行。普通进程依赖命令行终端，因此终端结束时，TuGraph 进程也会自动终止。普通进程模式配合`--log_dir """"`可以将进程日志直接输出到终端，因此更方便调试。注：当不使用`-d run`命令时，将默认运行普通进程。  
lgraph_server的默认路径为：/usr/local/bin/lgraph_server 。  
lgraph.json的默认路径为：/usr/local/etc/lgraph.json 。  
启动命令：  
```shell
$ ./lgraph_server -d run -c lgraph.json --log_dir """"
```
或者：
```shell
$ ./lgraph_server -c lgraph.json --log_dir """"
```  
普通模式的运行输出示例：  
```shell' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.1.运行普通进程'}","page_content='部署高可用模式

3.启动初始备份组

安装好TuGraph之后，可以使用`lgraph_server`命令在不同的机器上启动高可用集群。本节主要讲解高可用集群的启动方式，启动之后的集群状态管理参见[lgraph_peer工具](../6.utility-tools/5.ha-cluster-management.md)' metadata={'Header 1': '部署高可用模式', 'Header 2': '3.启动初始备份组'}","page_content='运维监控

2.部署方案

2.2.第二步

启动TuGraph Monitor工具，启动命令如下：  
```shell
./lgraph_monitor --server_host 127.0.0.1:9091 -u admin -p your_password \
--monitor_host 127.0.0.1:9999  --sampling_interval_ms 1000
```  
参数含义如下  
```shell
Available command line options:
--server_host       Host on which the tugraph rpc server runs.
Default=127.0.0.1:9091.
-u, --user          DB username.
-p, --password      DB password.
--monitor_host      Host on which the monitor restful server runs.
Default=127.0.0.1:9999.' metadata={'Header 1': '运维监控', 'Header 2': '2.部署方案', 'Header 3': '2.2.第二步'}",空,空,空,空,空
TuGraph团队为了提高解析速度所进行的优化包括了哪些主要手段？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。  
关于程序正确性的保证，我们通过双重验证来保证。首先在设计之初我们已经从源代码角度，推断出共享数据仍然是安全的，其次我们也设计了实验对此进行了验证，验证结果与我们的分析一致' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为 DFA、ATN 等结构），拼接出了数据竞争的完整链路。  
（4）破解数据竞争问题  
数据竞争问题是多线程程序中常见而又复杂的问题，可以考虑通过破解多种竞争条件来解决。就本文问题来说，也存在多种破解方案选择，如何制定最优的解决方案是一项极具挑战的工作，主要难点有两个：  
（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

贡献和成果

对Antlr4的优化的效果十分显著，32 线程的并发性能提升超过 18 倍 。考虑到实际生产服务器性能远高于测试机型，实际的性能提升效果将比测试结果更高， 优化后 GQL 解析能力已能完全满足企业业务的需要。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '贡献和成果'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

在调研讨论的过程中我们发现，多位开发者在论坛提出其耗时甚至多于 Java target 数倍之多。因此，我们决定从问题和开源代码出发，来定位、解决问题。  
这是一个典型的并发程序优化问题，根据以往的程序优化经验，我们分步推进该问题的解决：  
（1）识别问题  
通过对程序运行时的性能数据进行收集和分析，我们找到了程序运行瓶颈所在，通过调用分析，初步将问题定位为数据竞争导致的并发问题。  
（2）深入阅读 Antlr4 开源代码  
接下来，我们对 Antlr4 的源代码进行仔细的阅读和理解，掌握其内部的结构和核心逻辑，找出了核心的数据结构和关键的调用链路。为我们破解性能难题和分析修改的正确性做好了准备。  
（3）梳理数据竞争链路  
根据上述分析，我们判断问题的症结极大概率是数据竞争造成的。形成数据竞争至少有两个条件：一是线程之间共享内存数据，二是至少存在两个线程去读写某个共享内存。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='TuGraph在图计算系统建设中的作用

TuGraph 技术优势

TuGraph 开源版特色

开源TuGraph特点包括:  
-   单机版图数据库能够处理数据量几个 TB 的数据，前提是磁盘足够大。
-   成本很低，因为是单机版，部署和运维都很容易。
-   性能很好，我们对其进行了大量优化。TuGraph 的 LDBC-SNB 测试目前是世界第一，大家可以在 GitHub 上获取测试 SNB 的条款并进行测试。
-   单机版图数据库是一个非常易用的完整系统，我们提供了导入导出工具和查询语言。此外，还提供了底层 API，用户可以使用它来编写复杂的程序。  
我们的开源版本的目标主要有三点：  
首先，我们希望提供一个免费的图数据库产品，能够让更多的人使用图数据库，尝试用它来解决问题。  
其次，我们希望促进图数据库标准的成形。目前图数据库的差异太大，每个数据库都有所不同，我们希望通过提供一个参考答案来帮助大家达成趋同。这样大家就可以根据我们提供的设计来判断哪些特征合理，如果觉得合理就可以遵循这个设计，慢慢地大家就会逐渐靠近。假如所有产品在主要特征上保持一致，这样所有人的学习成本就会降低。' metadata={'Header 1': 'TuGraph在图计算系统建设中的作用', 'Header 2': 'TuGraph 技术优势', 'Header 3': 'TuGraph 开源版特色'}",空,空,空,空,空
中止一个正在执行的任务时，应该使用哪种HTTP请求方法？,空,空,空,空,空,空,空,空,空,空
AllocVertexSubset函数用于什么目的？,"page_content='OlapOnDB API

3. 算法举例

3.1 主函数

auto all_vertices = olapondb.AllocVertexSubset();
all_vertices.Fill();
/*
函数用途：从所有节点中获取pagerank值最大的节点编号

函数流程描述：该函数对点集合all_vertices中所有为1的位对应的节点vi（又称为活跃点）执行Func A，再将Func A的返回值作为Func B的第二个输入参数，得到局部最大值（因为第一个输入参数为0，因此实际上返回值就是每个节点的pagerank值），最后再将所有线程的返回值汇总，再次 执行Func B得到全局返回值，并存入max_pr_vi变量中
*/
size_t max_pr_vi = olapondb.ProcessVertexActive<size_t>(

//Func A
[&](size_t vi) {
return vi;
},
all_vertices,
0,

//Func B
[&](size_t a, size_t b) {
return pr[a] > pr[b] ? a : b;
}
);' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '3. 算法举例', 'Header 3': '3.1 主函数'}","page_content='OlapBase API

7. 图类OlapBase

7.2 点集和边集及其相关操作

- `ParallelVector<VertexData> AllocVertexArray<VertexData>()`：分配一个类型为VertexData的数组，大小为点个数
- `void fill_vertex_array<V>(V * array, V value)`：将数组array中的所有元素赋值为value
- `ParallelBitset AllocVertexSubset()`：分配一个ParallelBitset集合，用于表示所有点的状态是否激活
- `AdjList<EdgeData> OutEdges(size_t vid)`：获取点v的所有出边集合
- `AdjList<EdgeData> InEdges(size_t vid)`：获取点v的所有入边集合
- `void Transpose()`：对有向图进行图反转' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.2 点集和边集及其相关操作'}","page_content='OlapOnDisk API

2. 算法举例

2.4 bfs算法流程

size_t root = root_vid;
auto active_in = graph.AllocVertexSubset();   //分配数组，active_in用于存放上一循环阶段已找到的节点
active_in.Add(root);            //把跟节点加入数组中
auto active_out = graph.AllocVertexSubset();  //分配数组active_out用于存放当前循环阶段找到的节点
parent.Fill((size_t)-1);               //将parent数组中的节点赋值为-1，-1表示未被找到
parent[root] = root;
size_t num_activations = 1;       //表示当前循环阶段找到的节点个数
size_t discovered_vertices = 0;    //表示当前循环阶段找到节点的总个数' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '2. 算法举例', 'Header 3': '2.4 bfs算法流程'}",空,空,空,空,空,空,空
如何在Web端导入10G数据时解决报错问题？,空,空,空,空,空,空,空,空,空,空
TuGraph支持哪些导出格式？,"page_content='TuGraph console client

在线数据导出

lgraph_cli 支持流式读取，导出数据只需要把lgraph_cli的输出重定向到文件中即可，导出格式支持csv和json。' metadata={'Header 1': 'TuGraph console client', 'Header 2': '在线数据导出'}","page_content='功能概览

6.生态工具

6.1.TuGraph DataX

![导入导出](../../../images/tugraph-datax.png)  
TuGraph 核心支持 CSV 和 JSON 合适的导入导出，提供空库导入和增量导入的模式。实际中会存在 MySQL、Kafka、Hive 等多数据源导入的需求，TuGraph 通过 DataX 做多数据源的对接。由于关系模型和图模型存在的差异，数据清洗的流程可以使用 SparkSQL 快速处理，TuGraph 本身仅关注 CSV 和 JSON 的简单场景导入可靠性和性能。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.1.TuGraph DataX'}","page_content='功能概览

4.核心功能

4.3.数据导入导出

尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。  
TuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.3.数据导入导出'}","page_content='数据导出

1.简介

TuGraph 可以通过 `lgraph_export` 工具来对已经存放在TuGraph的图数据进行数据导出。 `lgraph_export` 工具可以将指定 TuGraph 数据库的数据以 `csv` 或者 `json` 文件形式导出到指定目录，同时导出这些数据进行再导入时需要的配置文件 `import.config` ，详细描述可参见[配置文件](1.data-import.md)。' metadata={'Header 1': '数据导出', 'Header 2': '1.简介'}","page_content='数据导入

1.简介

在图数据库服务安装成功后，您可以使用`lgraph_import`批量导入工具将现有数据导入 TuGraph。`lgraph_import`支持从 CSV 文件和 JSON 数据源导入数据。  
> CSV 格式  
```
[movies.csv]
id, name, year, rating
tt0188766,King of Comedy,1999,7.3
tt0286112,Shaolin Soccer,2001,7.3
tt4701660,The Mermaid,2016,6.3
```  
> jsonline 格式  
```json
[""tt0188766"",""King of Comedy"",1999,7.3]
[""tt0286112"",""Shaolin Soccer"",2001,7.3]
[""tt4701660"",""The Mermaid"",2016,6.3]
```  
TuGraph 支持两种导入模式：  
- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。' metadata={'Header 1': '数据导入', 'Header 2': '1.简介'}",空,空,空,空,空
除了在语句前加EXPLAIN和PROFILE，TuGraph还有哪些其他调优方法？,"page_content='功能概览

2.存储层

在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。  
在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。  
存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。' metadata={'Header 1': '功能概览', 'Header 2': '2.存储层'}","page_content='功能概览

4.核心功能

4.1.查询语言

TuGraph 提供 Cypher 图查询语言，遵循OpenCypher标准。
- __支持Procedure嵌入__  
- __可插拔优化框架__ 各类优化功能  
- __可扩展安全性检查框架__ 对于cypher进行' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.1.查询语言'}",空,空,空,空,空,空,空,空
RpcSingleClient的构造函数需要哪些参数？,"page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ void RpcClient::Logout() {
    auto logoutFun = [](const std::shared_ptr<RpcSingleClient>& c) {
        try {
            if (c) c->Logout();
        } catch (std::exception &e) {
            LOG_ERROR() << e.what();
        }
    };
    if (client_type != INDIRECT_HA_CONNECTION) {
        logoutFun(base_client);
    }
    for (auto &c : client_pool) {
        logoutFun(c);
    }
}

void RpcClient::RefreshUserDefinedProcedure() {
    std::string result;
    GetClient(true)->
        CallCypher(result, ""CALL db.plugin.listUserPlugins()"", ""default"", true, 10);
    user_defined_procedures = nlohmann::json::parse(result.c_str());
}

void RpcClient::RefreshBuiltInProcedure() {
    std::string result;
    GetClient(true)->CallCypher(result, ""CALL dbms.procedures()"", ""default"", true, 10);
    built_in_procedures = nlohmann::json::parse(result.c_str());
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ std::shared_ptr<lgraph::RpcClient::RpcSingleClient>
    RpcClient::GetClient(lgraph::GraphQueryType type, const std::string &cypher,
                         const std::string &graph) {
    return GetClient(IsReadQuery(type, cypher, graph));
}

std::shared_ptr<lgraph::RpcClient::RpcSingleClient> RpcClient::GetClient(bool isReadQuery) {
    if (isReadQuery) {
        LoadBalanceClientPool();
        if (client_pool.empty())
            throw RpcException(""all instance is down, refuse req!"");
        return *client_pool.rbegin();
    } else {
        if (leader_client == nullptr)
            throw RpcException(""master instance is down, refuse req!"");
        return leader_client;
    }
}

std::shared_ptr<lgraph::RpcClient::RpcSingleClient> RpcClient::GetClientByNode(
    const std::string &url) {
    for (auto &c : client_pool) {
        if (c->GetUrl() == url)
            return c;
    }
    throw RpcException(""do not exit "" + url +"" client"");
}

void RpcClient::RefreshConnection() {
    try {
        RefreshClientPool();
        RefreshUserDefinedProcedure();
        RefreshBuiltInProcedure();
    } catch (std::exception &e) {
        LOG_ERROR() << ""[RpcClient] RpcClient Connection Exception, ""
                                   ""please connect again!"";
    }
}

void RpcClient::LoadBalanceClientPool() {
    if (!client_pool.empty()) {
        client_pool.push_back(client_pool.front());
        client_pool.pop_front();
    }
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ RpcClient::RpcSingleClient::~RpcSingleClient() {
    try {
        Logout();
    } catch (const RpcConnectionException& e) {
        LOG_DEBUG() << ""[RpcSingleClient] RpcSingleClient Connection Exception"";
    }
}

RpcClient::RpcClient(const std::string &url, const std::string &user,
                         const std::string &password)
    : user(user),
      password(password),
      base_client(std::make_shared<RpcSingleClient>(url, user, password)) {
    std::string result;
    bool ret = base_client->CallCypher(result, ""CALL dbms.ha.clusterInfo()"");
    if (ret) {
        client_type = DIRECT_HA_CONNECTION;
        cypher_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""merge ""};
        gql_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""insert "", ""drop ""};
        RefreshConnection();
    } else {
        client_type = SINGLE_CONNECTION;
    }
}

RpcClient::RpcClient(std::vector<std::string> &urls, std::string user,
                         std::string password)
    : user(std::move(user)),
      password(std::move(password)),
      urls(urls) {
    client_type = INDIRECT_HA_CONNECTION;
    cypher_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""merge ""};
    gql_write_constant = {""create "", ""set "", ""delete "", ""remove "", ""insert "", ""drop ""};
    RefreshConnection();
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='RPC API

3.登录

登录请求信息包含以下参数：
- user: 必要参数，用户名
- pass: 必要参数，密码
以C++为例，用户使用构建好的服务存根发送登录请求：
```C++
auto* req = request.mutable_acl_request();
auto* auth = req->mutable_auth_request()->mutable_login();
auth->set_user(user);
auth->set_password(pass);
// send data
cntl->Reset();
cntl->request_attachment().append(FLAGS_attachment);
req->set_client_version(server_version);
req->set_token(token);
LGraphRPCService_Stub stub(channel.get());
LGraphResponse res;' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ bool RpcClient::RpcSingleClient::CallProcedure(std::string& result,
                                               const std::string& procedure_type,
                                               const std::string& procedure_name,
                                               const std::string& param,
                                               double procedure_time_out, bool in_process,
                                               const std::string& graph, bool json_format)' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}",空,空,空,空,空
如何在Cython中导入与OLAP相关的模块和图数据库模块？,"page_content='Python Olap API

5. lgraph_db API

见procedures/algo_cython/lgraph_db.pxd与lgraph_db_python.py文件。  
lgraph_db.pxd中接口用法与功能基本与C++接口相同，lgraph_db.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。' metadata={'Header 1': 'Python Olap API', 'Header 2': '5. lgraph_db API'}","page_content='Python Olap API

4. Olap API

见procedures/algo_cython/olap_base.pxd文件，用法与功能基本与C++接口相同，olap_base.pxd中声明的接口都由C++实现，在py文件中必须通过`from cython.cimports.olap_base import *`的方式导入，由Cython编译py文件后才能运行。' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API'}","page_content='Python Olap API

4. Olap API

图类OlapBase

import cython
from cython.cimports.olap_base import *
from cython.cimports.libc.stdio import printf


@cython.cclass
class NeighborCore:
graph: cython.pointer(OlapBase[Empty])
active_in: ParallelBitset' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}","page_content='Python Olap API

6. 算法插件示例

import json

import cython
from cython.cimports.olap_base import *
from cython.cimports.lgraph_db import *
# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include ""xxx.h""

from cython.cimports.libc.stdio import printf
# 类似C++中#include <stdio.h>
# 其他常见的还有cython.cimports.libcpp.unordered_map等

import time' metadata={'Header 1': 'Python Olap API', 'Header 2': '6. 算法插件示例'}","page_content='Python Olap API

4. Olap API

图类OlapBase

import cython
from cython.cimports.olap_base import *


@cython.cclass
class CountCore:
graph: cython. pointer(OlapBase[Empty])
parent: ParallelVector[size_t]

@cython.cfunc
@cython.nogil
def Work(self, vi: size_t) -> size_t:
if self.graph.OutDegree(self.parent[vi]) > 0:
return 1
return 0' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}",空,空,空,空,空
在调用db.addEdgeIndex时，'unique'参数和'pair_unique'参数有什么区别？,"page_content='src/cypher/procedure/procedure.cpp/ CYPHER_ARG_CHECK(args.size() == 4,
                     ""need 3 parameters, e.g. ""
                     ""db.addEdgeIndex(label_name, field_name, unique, pair_unique)"")
    CYPHER_ARG_CHECK(args[0].IsString(), ""label_name type should be string"")
    CYPHER_ARG_CHECK(args[1].IsString(), ""field_name type should be string"")
    CYPHER_ARG_CHECK(args[2].IsBool(), ""unique type should be boolean"")
    CYPHER_ARG_CHECK(args[3].IsBool(), ""pair_unique type should be boolean"")
    CYPHER_DB_PROCEDURE_GRAPH_CHECK();
    CheckProcedureYieldItem(""db.addEdgeIndex"", yield_items);
    /* close the previous txn first, in case of nested transaction */
    if (ctx->txn_) ctx->txn_->Abort();
    auto label = args[0].constant.scalar.AsString();
    auto field = args[1].constant.scalar.AsString();
    auto unique = args[2].constant.scalar.AsBool();
    auto pair_unique = args[3].constant.scalar.AsBool();
    if (unique && pair_unique) {
        THROW_CODE(InputError, ""pair_unique and unique configuration cannot occur simultaneously)"");
    }
    lgraph::IndexType type;
    if (unique) {
        type = lgraph::IndexType::GlobalUniqueIndex;
    } else if (pair_unique) {
        type = lgraph::IndexType::PairUniqueIndex;
    } else {
        type = lgraph::IndexType::NonuniqueIndex;
    }
    auto ac_db = ctx->galaxy_->OpenGraph(ctx->user_, ctx->graph_);
    bool success = ac_db.AddEdgeIndex(label, field, type);
    if (!success) {
        throw lgraph::IndexExistException(label, field);
    }
    F' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.addEdgeIndex(label_name, field_name, unique, pair_unique)

create an index on some field of one edge label .  
**Parameters:**  
| parameter | parameter type | description               |
| ---------- | -------------- | ------------------------------------- |
| label_name | string     | name of the label             |
| field_name | string     | specification of a field          |
| unique  | boolean    | Specifies whether the index is unique |
| pair_unique | boolean    | Specifies whether the index is pair_unique |  
**Output:**' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.addEdgeIndex(label_name, field_name, unique, pair_unique)'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

- properties（数组形式，对于点必选，对于边如果没有属性可以不配置）
- name（必选，字符串形式）
- type （必选，BOOL，INT8，INT16，INT32，INT64，DATE，DATETIME，FLOAT，DOUBLE，STRING，BLOB）
- optional（可选，代表该字段可以配置，也可以不配置）
- index（可选，该字段是否需要建索引）
- unique（可选，该字段是否建索引，并且是 unique 类型的，即全局唯一）
- pair_unique（可选，该字段是否建索引，并且是 pari_unique 类型的，即两点间唯一，仅用于边索引）unique与pair_unique只能设置一个，同时设置并运行将会因为输入异常而终止
- primary (仅点配置，必选，主键字段，需指定一个 property，用来唯一确定一个点)
- temproal (仅边配置，可选，指定时间戳属性用于存储层排序)' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.addEdgeIndex(label_name, field_name, unique, pair_unique)

| field_name | string     | specification of a field          |
| unique  | boolean    | Specifies whether the index is unique |
| pair_unique | boolean    | Specifies whether the index is pair_unique |  
**Output:**  
If successful, it returns a success message.  
**Example input:**  
```
CALL db.addEdgeIndex('BornIn', 'id', true, false)
```  
**Example output:**  
```
Added index [BornIn:id]
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.addEdgeIndex(label_name, field_name, unique, pair_unique)'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

- unique（可选，该字段是否建索引，并且是 unique 类型的，即全局唯一）
- pair_unique（可选，该字段是否建索引，并且是 pari_unique 类型的，即两点间唯一，仅用于边索引）unique与pair_unique只能设置一个，同时设置并运行将会因为输入异常而终止
- primary (仅点配置，必选，主键字段，需指定一个 property，用来唯一确定一个点)
- temproal (仅边配置，可选，指定时间戳属性用于存储层排序)
- temporal_field_order (仅边配置，可选，默认为""ASC""，表示升序，也可配置为""DESC""，表示降序)
- constraints (仅边配置，可选，数组形式，起点和终点的 label，不配置或者为空代表不限制)
- detach_property (点边都可配置，可选，默认是`false`。`true` 代表属性数据单独存放，在内存不够，属性数据比较多的场景下可以减少io读放大)
- files （数组形式）' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}",空,空,空,空,空
图数据库相比于关系型数据库有哪些优势？,"page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.1. 性能

在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.1. 性能'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.2. 兼容性

现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.2. 兼容性'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.3. 直观性

使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.3. 直观性'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

图数据库的功能是传统关系型数据库的扩展。与关系型数据库仅支持的“表结构”相比，图数据库所支持的“图结构”更为灵活。图数据库在基于图的增加、删除、查询和修改方面采用不同于其他数据库的设计。在图数据操作抽象上，采用基于点的视角，例如点通过其所有“出边”（从一个点出发，连接到其他点的边）访问其邻接点。这是图数据库系统设计的核心。  
图数据库的独特性体现在以下三个方面:' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势'}","page_content='什么是图数据库

3. 图数据库与关系型数据库对比

| 分类         | 模型   | 优势                                   | 劣势                                     | 举例           |
| ------------ | ------ | -------------------------------------- | ---------------------------------------- | -------------- |
| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |
| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |' metadata={'Header 1': '什么是图数据库', 'Header 2': '3. 图数据库与关系型数据库对比'}",空,空,空,空,空
在创建节点时，出现报错信息：“message: Vertex unique index value [xxx] is too long”，这是否意味着属性值的长度超出了限制？,"page_content='src/core/vertex_index.cpp/ case IndexType::GlobalUniqueIndex:
        {
            if (k.Size() > GetMaxVertexIndexKeySize())
                THROW_CODE(InputError, ""Vertex unique index value [{}] is too long."", k.AsString());
            return table_->AddKV(txn, Value::ConstRef(k), Value::ConstRef(vid));
        }' metadata={'file_name': 'vertex_index.cpp', 'file_path': 'src/core/vertex_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/vertex_index.cpp'}","page_content='src/core/composite_index.cpp/ {
            if (k.Size() > _detail::MAX_KEY_SIZE - _detail::VID_SIZE) {
                THROW_CODE(ReachMaximumCompositeIndexField, ""The key of the composite index is ""
                           ""too long and exceeds the limit."");
            }
            CompositeIndexIterator it = GetUnmanagedIterator(txn, k, k, vid);
            if (!it.IsValid() || it.KeyOutOfRange()) {
                if (!it.PrevKV() || !it.KeyEquals(k)) {
                    // create a new VertexIndexValue
                    VertexIndexValue iv;
                    uint8_t r = iv.InsertVid(vid);
                    FMA_DBG_CHECK_NEQ(r, 0);
                    bool r2 = table_->AddKV(txn, iv.CreateKey(k), iv.GetBuf());
                    FMA_DBG_ASSERT(r2);
                    return true;
                }
            }
            // found an existing VertexIndexValue
            uint8_t ret = it.iv_.InsertVid(vid);' metadata={'file_name': 'composite_index.cpp', 'file_path': 'src/core/composite_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/composite_index.cpp'}","page_content='src/core/composite_index.cpp/ void CompositeIndex::_AppendCompositeIndexEntry(KvTransaction& txn, const Value& k, VertexId vid) {
    FMA_DBG_ASSERT(type_ == CompositeIndexType::UniqueIndex);
    if (k.Size() > _detail::MAX_KEY_SIZE) {
        THROW_CODE(ReachMaximumCompositeIndexField, ""The key of the composite index is ""
                   ""too long and exceeds the limit."");
    }
    table_->AppendKv(txn, k, Value::ConstRef(vid));
}

void CompositeIndex::_AppendNonUniqueCompositeIndexEntry(lgraph::KvTransaction &txn,
                                                         const lgraph::Value &k,
                                                         const std::vector<VertexId> &vids) {
    FMA_DBG_ASSERT(type_ == CompositeIndexType::NonUniqueIndex);
    FMA_DBG_ASSERT(!vids.empty());
    if (k.Size() > _detail::MAX_KEY_SIZE - _detail::VID_SIZE) {
        THROW_CODE(ReachMaximumCompositeIndexField, ""The key of the composite index is ""
                   ""too long and exceeds the limit."");
    }
    size_t vid_per_idv = _detail::NODE_SPLIT_THRESHOLD / _detail::VID_SIZE;
    for (size_t i = 0; i < vids.size(); i += vid_per_idv) {
        size_t end = i + vid_per_idv;
        end = end <= vids.size() ? end : vids.size();
        VertexIndexValue idv(vids.begin() + i, vids.begin() + end);
        Value real_key = idv.CreateKey(k);
        table_->AppendKv(txn, real_key, idv.GetBuf());
    }
}' metadata={'file_name': 'composite_index.cpp', 'file_path': 'src/core/composite_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/composite_index.cpp'}","page_content='src/import/import_v2.cpp/ const FieldData& unique_index_col = edge[pos];
                                if (unique_index_col.IsNull() ||
                                    unique_index_col.is_empty_buf()) {
                                    OnErrorOffline(""Invalid unique index key"",
                                                   config_.continue_on_error);
                                    continue;
                                }
                                if (unique_index_col.IsString() &&
                                    unique_index_col.string().size() >
                                        lgraph::_detail::MAX_KEY_SIZE) {
                                    OnErrorOffline(""Unique index string key is too long: ""
                                                   + unique_index_col.string().substr(0, 1024),
                                                   config_.continue_on_error);
                                    continue;
                                }
                                std::string unique_key;
                                unique_key.append((const char*)&pos, sizeof(pos));
                                unique_key.append(
                                    (const char*)&(src_vid < dst_vid ? src_vid : dst_vid),
                                    sizeof(VertexId));' metadata={'file_name': 'import_v2.cpp', 'file_path': 'src/import/import_v2.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/import/import_v2.cpp'}","page_content='src/core/composite_index.cpp/ {
    case CompositeIndexType::UniqueIndex:
        {
            if (k.Size() > _detail::MAX_KEY_SIZE) {
                THROW_CODE(ReachMaximumCompositeIndexField, ""The key of the composite index is ""
                           ""too long and exceeds the limit."");
            }
            return table_->AddKV(txn, k, Value::ConstRef(vid));
        }' metadata={'file_name': 'composite_index.cpp', 'file_path': 'src/core/composite_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/composite_index.cpp'}",空,空,空,空,空
在使用 GET 方法获取 TuGraph 中具体边的属性时，如果边不存在该属性，会返回什么错误代码？,"page_content='src/core/transaction.cpp/ emplate <typename FieldT>
typename std::enable_if<IS_FIELD_TYPE(FieldT), FieldData>::type Transaction::GetEdgeField(
    const EdgeUid& uid, const FieldT& fd) {
    _detail::CheckEdgeUid(uid);
    auto eit = graph_->GetUnmanagedOutEdgeIterator(txn_.get(), uid, false);
    if (!eit.IsValid()) THROW_CODE(InputError, ""Edge does not exist"");
    auto schema = curr_schema_->e_schema_manager.GetSchema(eit.GetLabelId());
    FMA_DBG_ASSERT(schema);
    Value prop = eit.GetProperty();
    FMA_DBG_ASSERT(prop.IsSlice());
    if (schema->DetachProperty()) {
        prop = schema->GetDetachedEdgeProperty(*txn_, uid);
    }
    return GetField(schema, prop, fd, blob_manager_, *txn_);
}

template <typename FieldT>
typename std::enable_if<IS_FIELD_TYPE(FieldT), void>::type Transaction::GetEdgeFields(
    const EdgeUid& uid, const size_t n_fields, const FieldT* fds, FieldData* fields) {
    _detail::CheckEdgeUid(uid);
    auto eit = graph_->GetUnmanagedOutEdgeIterator(txn_.get(), uid, false);
    if (!eit.IsValid()) THROW_CODE(InputError, ""Edge does not exist"");
    auto schema = curr_schema_->e_schema_manager.GetSchema(eit.GetLabelId());
    FMA_DBG_ASSERT(schema);
    Value prop = eit.GetProperty();
    FMA_DBG_ASSERT(prop.IsSlice());
    if (schema->DetachProperty()) {
        prop = schema->GetDetachedEdgeProperty(*txn_, eit.GetUid());
    }
    for (size_t i = 0; i < n_fields; i++) {
        fields[i] = GetField(schema, prop, fds[i], blob_manager_, *txn_);
    }
}' metadata={'file_name': 'transaction.cpp', 'file_path': 'src/core/transaction.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/transaction.cpp'}",空,空,空,空,空,空,空,空,空
TuGraph针对不同用户的需求提供了哪些类型的系统环境？,"page_content='环境和版本选择

1. 简介

TuGraph为不同需求的用户提供了差异化的系统环境和部署方式，来满足新手、系统开发者、生产运维人员、研究人员等不同用户的需求。' metadata={'Header 1': '环境和版本选择', 'Header 2': '1. 简介'}","page_content='环境分类

2.依赖系统库

针对三种环境，除去TuGraph的运行包，所需要的系统库如下：
* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。
* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。
* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='环境分类

1.分类

根据环境所承载功能的不同，区分为编译环境，运行环境，以及精简运行环境。
* 编译环境，具备TuGraph编译的所有依赖库，包含运行环境的所有依赖，并且能够编译TuGraph源码，但不包含预编译好的TuGraph可执行文件和库文件，供开发者编译源码使用。
* 运行环境，具备GCC/Java/Python环境，能够运行TuGraph的所有功能，并且能承载全文索引，java client，c++源码上传为plugin，以及python plugin的完整功能，内置TuGraph预编译好的可执行文件和库文件，供客户直接安装使用，无需编译源码。
* 精简运行环境，约等于裸系统加预编译TuGraph，仅能运行TuGraph的基本功能，无C++ plugin编译运行，仅so上传，无全文索引，无python plugin，供快速搭建试用。  
TuGraph编译后，会把所有的依赖库以.a的形式打包在一起，因此原则上运行不需要的其他的依赖库。但TuGraph支持存储过程，即在服务端编译C++代码，因此在环境中依然需要涉及的编译器。' metadata={'Header 1': '环境分类', 'Header 2': '1.分类'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='环境和版本选择

2. 环境能力选择

用户可以根据实际使用场景，来选择不同的环境。编译环境的能力最完备，所需的第三方软件也越多。与其相对应的，精简运行环境几乎不需要安装任何依赖库，能运行TuGraph除存储过程外的基础功能。  
| 环境     | 用途             | 备注        |
|--------|----------------|-----------|
| 编译环境   | 从源码编译TuGraph   | 适用于开发人员   |
| 运行环境   | 运行TuGraph安装包   | 适用于大部分用户  |
| 精简运行环境 | 运行精简TuGraph安装包 | 对系运行统依赖较小 |  
不同环境的具体介绍参见 [链接](../5.installation&running/2.environment-mode.md)。' metadata={'Header 1': '环境和版本选择', 'Header 2': '2. 环境能力选择'}",空,空,空,空,空
TuGraph-DB新增支持哪些空间数据类型？,"page_content='空间数据类型在TuGraph-DB中的实现

定义空间数据类型

TuGraph-DB当前已经支持Point、Linestring与Polygon三种类型  
-   • Point：点，创建方式例如POINT(2.0, 2.0, 7203)  
-   • Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)  
-   • Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))  
其中坐标点都是double型' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '定义空间数据类型'}","page_content='空间数据类型在TuGraph-DB中的实现

需求分析

结合上述案例，我们可以分析总结出对空间数据类型的需求:  
-   •支持不同坐标系下（包括地球地理坐标系，平面几何坐标系等）不同空间数据类型（包括Point、LineString,、Polygon）的存储与创建  
-   •支持不同坐标系下的常见空间查询操作, 包括Distance、BoundingBox、Disjoint（判断两个数据是否相交）的查询等  
-   •支持空间数据索引（R-Tree）  
-   •支持常见空间数据格式的导入（ESRI Shapefile data / OpenStreetMap）  
-   •支持空间数据的可视化' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '需求分析'}","page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的实现

OGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的实现'}","page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的实现

实现思路

在TuGraph-DB的实现，基于boost geometry库的基础上进行封装，用EWKB格式存储数据，其中Point类型为定长存储50，其余皆为变长存储。我们支持了Point, Linestring与Polygon三种类型，同时支持了WGS84, CARTESIAN两种坐标系，数据类型与坐标系均可根据需要拓展。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的实现', 'Header 3': '实现思路'}","page_content='技术规划

2. 已完成功能

| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}",空,空,空,空,空
在使用CREATE LABEL命令创建一个顶点标签时，主要属性名称应该由哪个参数来确定？,"page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

Create a vertex or edge label.  
**Parameters:**  
| parameter  | parameter type | description           |
| ---------- | -------------- | ------------------------- |
| label_type | string     | either 'vertex' or 'edge' |
| label_name | string     | name of the label     |
| extra      | string     | for edge, it means constraints; for vertex, it means primary property |
| field_spec | list       | specification of a field  |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createEdgeLabel( label_name, field_spec...)

Create an edge label.  
**Parameters:**  
| parameter  | parameter type | description          |
| ---------- | -------------- | ------------------------ |
| label_name | string     | name of the label    |
| edge_constraints | string | edge constraints |
| field_spec | list       | specification of a field |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`, where optional is specified as true, only for  optional fields.' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createEdgeLabel( label_name, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createLabel(label_type, label_name, extra, field_spec...)

| label_name | string     | name of the label     |
| extra      | string     | for edge, it means constraints; for vertex, it means primary property |
| field_spec | list       | specification of a field  |  
in which each `field_spec` is a list of string in the form of `[field_name, field_type, optional]`.' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createLabel(label_type, label_name, extra, field_spec...)'}","page_content='Cypher API

5.附录2. 内置procedures列表

* db.createVertexLabel(label_name, primary_field, field_spec...)

Create a vertex label.  
**Scope:** whole instance.  
**Parameters:**  
| parameter  | parameter type | description          |
| ---------- | -------------- | ------------------------ |
| label_name | string     | name of  vertex label    |
| primary_field | string  | primary field of vertex label |
| field_spec | list       | specification of a field |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* db.createVertexLabel(label_name, primary_field, field_spec...)'}",空,空,空,空,空,空
在HA模式下，客户端可以向哪些节点发送导入点边数据的请求？,"page_content='Java客户端

2.使用示例

2.12.从字节流中导入点边数据

@return: the result of import data
public boolean importDataFromContent(String desc, String data, String delimiter, boolean continueOnError,
int threadNums, String graph, double timeout) throws UnsupportedEncodingException
```
本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='C++客户端

2.使用示例

2.12.从字节流中导入点边数据

binary format.
@param [in]  timeout             (Optional) Maximum execution time, overruns will be
interrupted.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='Java客户端

2.使用示例

2.14.从文件中导入点边数据

@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@return: the result of import data
public boolean importDataFromFile(String confFile, String delimiter, boolean continueOnError, int threadNums,
int skipPackages, String graph, double timeout) throws IOException, UnsupportedEncodingException
```
本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.14.从文件中导入点边数据'}","page_content='C++客户端

2.使用示例

2.14.从文件中导入点边数据

binary format.
@param [in]  timeout             (Optional) Maximum execution time, overruns will be
interrupted.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.14.从文件中导入点边数据'}","page_content='Python客户端

3.RPC Client

3.14.从文件中导入点边数据

```python
ret, res = client.importDataFromFile(""./test/data/yago.conf"", "","", true, 16, 0, ""default"", 1000000000)
```
```
importDataFromFile(self: liblgraph_client_python.client, conf_file: str, delimiter: str, continue_on_error: bool, thread_nums: int, skip_packages: int, graph: str, json_format: bool, timeout: float) -> (bool, str)
```
本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.14.从文件中导入点边数据'}",空,空,空,空,空
在只读事务中调用 SetFields 方法会抛出什么异常？,空,空,空,空,空,空,空,空,空,空
GetVertexIndexIterator函数在liblgraph_python_api.Transaction中用于获取什么类型的迭代器？,"page_content='Python Olap API

5. lgraph_db API

Transaction：

```
GetVertexIndexIterator(
label: std::string,
field: std::string,
key_start: std::string,
key_end: std::string)-> VertexIndexIterator
```
获取索引迭代器。迭代器的field值为 [key_start, key_end]。所以在key_start=key_end=v时，返回指向field值为v的点的迭代器  
lgraph_db_python.py是lgraph_db.pxd中C++类 Galaxy与GraphDB的包装，将C++类包装为Python类，将lgraph_db_python.py编译为Python拓展后，可以直接在Python文件或Python命令行中`import lgraph_db_python`访问lgraph_db_python.PyGraphDB与PyGraphDB.PyGalaxy。' metadata={'Header 1': 'Python Olap API', 'Header 2': '5. lgraph_db API', 'Header 3': 'Transaction：'}","page_content='procedures/algo_cython/bfs_procedure.py/ # 通过 GetVertexIndexIterator 根据root节点label名和filed名与filed值（root_id）
    # 获取root节点的迭代器，通过迭代器获取vid，在无ID_MAPPING时，该vid与OlapOnDB中的id相同
    cost = time.time() - cost
    printf(""prepare_cost = %lf s\n"", cython.cast(cython.double, cost))
    a = BFSCore()
    cost = time.time()
    count = a.run(cython.address(olapondb), root_vid)
    cost = time.time() - cost
    printf(""core_cost = %lf s\n"", cython.cast(cython.double, cost))
    response[""found_vertices""] = count
    response[""num_vertices""] = olapondb.NumVertices()
    response[""num_edges""] = olapondb.NumEdges()
    return True


@cython.ccall
def Process(db: lgraph_db_python.PyGraphDB, inp: bytes):
    # Process为embed模式和procedure模式下插件入口，用cython.ccall修饰
    # Process函数必须名为Process，参数为lgraph_db_python.PyGraphDB与bytes
    # 返回值必须为(bool, str)
    _inp = inp.decode(""utf-8"")
    request = json.loads(_inp)
    response = {}
    addr = cython.declare(cython.Py_ssize_t, db.get_pointer())
    # 获取PyGraphDB中GraphDB对象的地址，转换为指针后传递
    procedure_process(cython.cast(cython.pointer(GraphDB), addr),
                      request, response)
    return (True, json.dumps(response))' metadata={'file_name': 'bfs_procedure.py', 'file_path': 'procedures/algo_cython/bfs_procedure.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/procedures/algo_cython/bfs_procedure.py'}","page_content='Python Olap API

6. 算法插件示例

root_id.encode('utf-8'), root_id.encode('utf-8')
).GetVid()
# 通过 GetVertexIndexIterator 根据root节点label名和filed名与filed值（root_id）
# 获取root节点的迭代器，通过迭代器获取vid，在无ID_MAPPING时，该vid与OlapOnDB中的id相同
cost = time.time() - cost
printf(""prepare_cost = %lf s\n"", cython.cast(cython.double, cost))
a = BFSCore()
cost = time.time()
count = a.run(cython.address(olapondb), root_vid)
cost = time.time() - cost
printf(""core_cost = %lf s\n"", cython.cast(cython.double, cost))' metadata={'Header 1': 'Python Olap API', 'Header 2': '6. 算法插件示例'}","page_content='Python Olap API

6. 算法插件示例

txn = db.CreateReadTxn()
olapondb = OlapOnDB[Empty](db[0], txn, SNAPSHOT_PARALLEL)
# 并行创建OlapOnDB
# Cython不支持如 *db 的解引用操作，通过db[0]来解引用
root_vid = txn.GetVertexIndexIterator(
label.encode('utf-8'), field.encode('utf-8'),
root_id.encode('utf-8'), root_id.encode('utf-8')
).GetVid()
# 通过 GetVertexIndexIterator 根据root节点label名和filed名与filed值（root_id）
# 获取root节点的迭代器，通过迭代器获取vid，在无ID_MAPPING时，该vid与OlapOnDB中的id相同
cost = time.time() - cost' metadata={'Header 1': 'Python Olap API', 'Header 2': '6. 算法插件示例'}","page_content='src/lgraph_api/lgraph_txn.cpp/ VertexCompositeIndexIterator Transaction::GetVertexCompositeIndexIterator(
    const std::string& label, const std::vector<std::string>& field,
    const std::vector<std::string>& key_start, const std::vector<std::string>& key_end) {
    ThrowIfInvalid();
    return VertexCompositeIndexIterator(txn_->GetVertexCompositeIndexIterator(
                                            label, field, key_start, key_end), txn_);
}

EdgeIndexIterator Transaction::GetEdgeIndexIterator(const std::string& label,
                                                    const std::string& field,
                                                    const std::string& key_start,
                                                    const std::string& key_end) {
    ThrowIfInvalid();
    return EdgeIndexIterator(txn_->GetEdgeIndexIterator(label, field, key_start, key_end), txn_);
}

bool Transaction::IsVertexIndexed(const std::string& label, const std::string& field) {
    ThrowIfInvalid();
    lgraph::VertexIndex* idx = txn_->GetVertexIndex(label, field);
    if (!idx || !idx->IsReady()) return false;
    return true;
}

bool Transaction::IsEdgeIndexed(const std::string& label, const std::string& field) {
    ThrowIfInvalid();
    lgraph::EdgeIndex* idx = txn_->GetEdgeIndex(label, field);
    if (!idx || !idx->IsReady()) return false;
    return true;
}' metadata={'file_name': 'lgraph_txn.cpp', 'file_path': 'src/lgraph_api/lgraph_txn.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_txn.cpp'}",空,空,空,空,空
在使用 db.importor.dataImportor 函数导入数据时，是否可以指定在遇到错误时继续执行，和设置并发线程数？,"page_content='C++客户端

2.使用示例

2.12.从字节流中导入点边数据

@param [in]  continue_on_error   (Optional) whether to continue when importing data fails.
@param [in]  thread_nums         (Optional) maximum number of threads.
@param [in]  graph               (Optional) the graph to query.
@param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,
binary format.
@param [in]  timeout             (Optional) Maximum execution time, overruns will be
interrupted.
@returns True if it succeeds, false if it fails.
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='Java客户端

2.使用示例

2.12.从字节流中导入点边数据

@param continueOnError: whether to continue when importing data fails
@param threadNums: maximum number of threads
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@return: the result of import data
public boolean importDataFromContent(String desc, String data, String delimiter, boolean continueOnError,
int threadNums, String graph, double timeout) throws UnsupportedEncodingException
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='Cypher API

5.附录2. 内置procedures列表

5.2.内置procedures完整列表

| db.importor.dataImportor              | 导入点或边数据                               | db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)                                             |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '5.2.内置procedures完整列表'}","page_content='Java客户端

2.使用示例

2.14.从文件中导入点边数据

@param delimiter: data separator
@param continueOnError: whether to continue when importing data fails
@param threadNums: maximum number of threads
@param skipPackages: skip packages number
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@return: the result of import data
public boolean importDataFromFile(String confFile, String delimiter, boolean continueOnError, int threadNums,' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.14.从文件中导入点边数据'}","page_content='src/client/python/rpc/client.cpp/ &LGraphPythonClient::ImportDataFromContent,
          ""import vertex or edge data from content string\n""
          ""desc                [in] data format description\n""
          ""data                [in] the data to be imported\n""
          ""delimiter           [in] data separator\n""
          ""continue_on_error   [in] whether to continue when importing data fails\n""
          ""thread_nums         [in] maximum number of threads\n""
          ""graph               [in] the graph to query\n""
          ""json_format         [in] Returns the format， true is json，Otherwise, binary format\n""
          ""timeout             [in] Maximum execution time, overruns will be interrupted\n"",
          pybind11::arg(""desc""), pybind11::arg(""data""), pybind11::arg(""delimiter""),
          pybind11::arg(""continue_on_error"") = false, pybind11::arg(""thread_nums"") = 8,
          pybind11::arg(""graph"") = ""default"", pybind11::arg(""json_format"") = true,
          pybind11::arg(""timeout"") = 0, pybind11::return_value_policy::move);

    c.def(""logout"", &LGraphPythonClient::Logout, ""Execute unbind token\n"");
}

PYBIND11_MODULE(liblgraph_client_pytho' metadata={'file_name': 'client.cpp', 'file_path': 'src/client/python/rpc/client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/rpc/client.cpp'}",空,空,空,空,空
在尝试读取一个已完成索引构建的顶点时，应该使用哪个函数？,空,空,空,空,空,空,空,空,空,空
在调用函数DeleteGraph时，如果操作未被授权，会抛出什么异常？,"page_content='src/db/acl.cpp/ void lgraph::AclManager::DelGraph(KvTransaction& txn, const std::string& curr_user,
                                  const std::string& graph) {
    if (!IsAdmin(curr_user)) {
        THROW_CODE(Unauthorized, ""Non-admin user cannot delete graphs."");
    }
    if (graph == _detail::META_GRAPH) THROW_CODE(InputError, ""Builtin graph cannot be deleted."");
    lgraph::CheckValidGraphName(graph);
    // remove graph from roles
    auto it = role_tbl_->GetIterator(txn);
    for (it->GotoFirstKey(); it->IsValid(); it->Next()) {
        RoleInfo rinfo = DeserializeFromValue<RoleInfo>(it->GetValue());
        auto& access = rinfo.graph_access;
        auto ait = access.find(graph);
        if (ait == access.end()) continue;
        // role affected, need to update
        access.erase(ait);
        it->SetValue(SerializeToValue(rinfo));
    }
    // remove graph from cache
    for (auto& kv : user_cache_) {
        kv.second.acl.erase(graph);
    }
}

bool lgraph::AclManager::IsAdmin(const std::string& user) const {
    auto it = user_cache_.find(user);
    if (it == user_cache_.end()) return false;
    return it->second.is_admin;
}' metadata={'file_name': 'acl.cpp', 'file_path': 'src/db/acl.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/db/acl.cpp'}","page_content='src/restful/server/rest_server.cpp/ oid RestServer::HandleDeleteGraph(const std::string& user, const std::string& token,
                                   const web::http::http_request& request,
                                   const utility::string_t& relative_path,
                                   const std::vector<utility::string_t>& paths) const {
    if (paths.size() != 2) {
        BEG_AUDIT_LOG(user, """", lgraph::LogApiType::SingleApi, true,
                      ""DELETE "" + _TS(relative_path));
        return RespondBadURI(request);
    }

    LGraphRequest proto_req;
    proto_req.set_is_write_op(true);
    proto_req.set_token(token);

    DeleteGraphRequest* req = proto_req.mutable_graph_request()->mutable_delete_graph_request();
    req->set_name(_TS(paths[1]));
    LGraphResponse proto_resp = ApplyToStateMachine(proto_req);
    if (proto_resp.error_code() == LGraphResponse::SUCCESS) {
        return RespondSuccess(request);
    }
    return RespondRSMError(request, proto_resp, relative_path, ""Graph"");
}

// DELETE /role/{role_name}
// Deletes the specified role
v' metadata={'file_name': 'rest_server.cpp', 'file_path': 'src/restful/server/rest_server.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/restful/server/rest_server.cpp'}","page_content='src/db/galaxy.cpp/ bool lgraph::Galaxy::DeleteGraph(const std::string& curr_user, const std::string& graph) {
    lgraph::CheckValidGraphName(graph);
    _HoldReadLock(acl_lock_);
    if (!acl_->IsAdmin(curr_user)) THROW_CODE(Unauthorized, ""Non-admin cannot create graphs."");
    AutoWriteLock l1(acl_lock_, GetMyThreadId());
    AutoWriteLock l2(graphs_lock_, GetMyThreadId());
    // remove graph from list and then wait till no ref so we can destroy the db
    std::unique_ptr<AclManager> acl_new(new AclManager(*acl_));
    std::unique_ptr<GraphManager> gm_new(new GraphManager(*graphs_));
    auto gref = graphs_->GetGraphRef(graph);
    auto wt = store_->CreateWriteTxn(false);
    auto& txn = *wt;
    acl_new->DelGraph(txn, curr_user, graph);
    auto db = gm_new->DelGraph(txn, graph);
    if (!db) return false;
    txn.Commit();
    acl_ = std::move(acl_new);
    graphs_ = std::move(gm_new);
    // now destroy db asynchronously
    // since the obj has been removed from graphs_, we are now the only manager ref to the obj.
    // so we can delete the db safely as soon as the ref count becomes zero
    db.Assign(nullptr, [](LightningGraph* db) {
        std::string dir = db->GetConfig().dir;
        db->Close();
        fma_common::FileSystem::GetFileSystem(dir).RemoveDir(dir);
        LOG_INFO() << ""GraphDB "" << dir << "" deleted."";
    });
    return true;
}' metadata={'file_name': 'galaxy.cpp', 'file_path': 'src/db/galaxy.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/db/galaxy.cpp'}",空,空,空,空,空,空,空
在初始化每个节点的 PageRank 值时，当节点的出度大于 0，PageRank 值是如何计算的？,"page_content='OlapOnDB API

3. 算法举例

3.2 PageRank算法流程

// 每个节点pagerank值的初始化，和该节点的出度成反比
double delta = graph.ProcessVertexActive<double>(
[&](size_t vi) {
curr[vi] = one_over_n;
if (olapondb.OutDegree(vi) > 0) {
curr[vi] /= olapondb.OutDegree(vi);
}
return one_over_n;
},
all_vertices);

// 总迭代过程
double d = (double)0.85;
for (int ii = 0;ii < num_iterations;ii ++) {
printf(""delta(%d)=%lf\n"", ii, delta);
next.Fill((double)0);

/*
函数用途：计算所有节点的pagerank值' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '3. 算法举例', 'Header 3': '3.2 PageRank算法流程'}","page_content='内置算法

基础算法包

网页排序

网页排序程序实现了常用的Pagerank算法。该算法根据图中边和边权值计算所有点的重要性排名，PageRank值越高，表示该点在图中的重要性越高。计算时以点数量的倒数为各点初始Rank值，然后将点的Rank值按照出边平均传递到相邻点，重复该传递过程直到满足给定的收敛阈值或达到给定迭代轮数。每轮传递结束后，所有点的Rank值会有一定的的比例随机传递到任意点上。算法内容请参考 [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank ""pagerank wiki"")。' metadata={'Header 1': '内置算法', 'Header 2': '基础算法包', 'Header 3': '网页排序'}","page_content='OlapOnDB API

3. 算法举例

3.2 PageRank算法流程

`pagerank`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：  
1. 相关数据结构的初始化
1. 每个节点pagerank值的初始化
1. 每个节点pagerank值的计算，活跃点为所有点（意味着所有点都需要计算pagerank值）
1. 得到每个节点经过`num_iterations`次迭代后的pagerank值  
```C++
void PageRankCore(OlapBase<Empty>& graph, int num_iterations, ParallelVector<double>& curr) {' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '3. 算法举例', 'Header 3': '3.2 PageRank算法流程'}","page_content='内置算法

扩展算法包

个性化网页排序

个性化网页排序程序实现了Personalized PageRank算法。该算法根据给定的源点，基于该源点个性化计算所有点对于源点的重要性排名。Rank值越高，表示该点对于源点越重要。与PageRank不同的是，初始化时源点Rank值为1，其余点Rank值为0；并且每轮传递结束后，Rank值会有一定的比例随即传递回源点。算法内容请参考 [https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf](https://cs.stanford.edu/people/plofgren/Fast-PPR_KDD_Talk.pdf)。' metadata={'Header 1': '内置算法', 'Header 2': '扩展算法包', 'Header 3': '个性化网页排序'}","page_content='OlapOnDB API

3. 算法举例

3.2 PageRank算法流程

// 从邻居中获取当前节点的pagerank值
for (auto & edge : olapondb.InEdges(vi)) {
size_t src = edge.neighbour;
sum += curr[src];
}
next[vi] = sum;

// pagerank值计算核心公式
next[vi] = (1 - d) * one_over_n + d * next[vi];
if (ii == num_iterations - 1) {
return (double)0;
} else {

// 相关中间变量统计
if (olapondb.OutDegree(vi) > 0) {
next[vi] /= olapondb.OutDegree(vi);
return fabs(next[vi] - curr[vi]) * olapondb.OutDegree(vi);
} else {
return fabs(next[vi] - curr[vi]);
}
}
},
all_vertices
);' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '3. 算法举例', 'Header 3': '3.2 PageRank算法流程'}",空,空,空,空,空
TuGraph支持哪些数据导出格式？,"page_content='TuGraph console client

在线数据导出

lgraph_cli 支持流式读取，导出数据只需要把lgraph_cli的输出重定向到文件中即可，导出格式支持csv和json。' metadata={'Header 1': 'TuGraph console client', 'Header 2': '在线数据导出'}","page_content='功能概览

6.生态工具

6.1.TuGraph DataX

![导入导出](../../../images/tugraph-datax.png)  
TuGraph 核心支持 CSV 和 JSON 合适的导入导出，提供空库导入和增量导入的模式。实际中会存在 MySQL、Kafka、Hive 等多数据源导入的需求，TuGraph 通过 DataX 做多数据源的对接。由于关系模型和图模型存在的差异，数据清洗的流程可以使用 SparkSQL 快速处理，TuGraph 本身仅关注 CSV 和 JSON 的简单场景导入可靠性和性能。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.1.TuGraph DataX'}","page_content='功能概览

4.核心功能

4.3.数据导入导出

尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。  
TuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.3.数据导入导出'}","page_content='数据导入

1.简介

在图数据库服务安装成功后，您可以使用`lgraph_import`批量导入工具将现有数据导入 TuGraph。`lgraph_import`支持从 CSV 文件和 JSON 数据源导入数据。  
> CSV 格式  
```
[movies.csv]
id, name, year, rating
tt0188766,King of Comedy,1999,7.3
tt0286112,Shaolin Soccer,2001,7.3
tt4701660,The Mermaid,2016,6.3
```  
> jsonline 格式  
```json
[""tt0188766"",""King of Comedy"",1999,7.3]
[""tt0286112"",""Shaolin Soccer"",2001,7.3]
[""tt4701660"",""The Mermaid"",2016,6.3]
```  
TuGraph 支持两种导入模式：  
- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。' metadata={'Header 1': '数据导入', 'Header 2': '1.简介'}","page_content='数据导出

1.简介

TuGraph 可以通过 `lgraph_export` 工具来对已经存放在TuGraph的图数据进行数据导出。 `lgraph_export` 工具可以将指定 TuGraph 数据库的数据以 `csv` 或者 `json` 文件形式导出到指定目录，同时导出这些数据进行再导入时需要的配置文件 `import.config` ，详细描述可参见[配置文件](1.data-import.md)。' metadata={'Header 1': '数据导出', 'Header 2': '1.简介'}",空,空,空,空,空
"我在启动TuGraph时遇到一个错误，错误信息如下：0x00007f7e5f272900 FATAL include/fma-common/binary_buffer.h:289] CHECK(gpos_ + size <= ppos_) failed reading beyond the array: required size=4, actual size=2。请问这个问题该如何解决？","page_content='src/client/python/TuGraphClient/TuGraphRestClient.py/ def import_data(self, graph, schema, delimiter, continue_on_error, skip_packages, task_id, flag):
        data = {""graph"" : graph, ""schema"" : schema, ""delimiter"" : delimiter,
                ""continueOnError"" : continue_on_error, ""skipPackages"" : skip_packages,
                ""taskId"" : task_id, ""flag"" : flag}
        r = self._sync(partial(self.__post__, 'import_data', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""taskId""]

    def import_schema(self, graph, schema):
        data = {""graph"":graph, ""description"":schema}
        r = self._sync(partial(self.__post__, 'import_schema', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""result""]

    def check_file_with_size(self, file_name, size):
        data = {""fileName"" : file_name, ""flag"" : ""2"" , ""fileSize"" : str(size)}
        r = self._sync(partial(self.__post__, 'check_file', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""pass""]

    def import_progress(self, task_id):
        data = {""taskId"" : task_id}
        r = self._sync(partial(self.__post__, 'import_progress', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""]' metadata={'file_name': 'TuGraphRestClient.py', 'file_path': 'src/client/python/TuGraphClient/TuGraphRestClient.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/TuGraphClient/TuGraphRestClient.py'}","page_content='数据库运行

3.服务操作

3.3.重启服务

用户也可以通过`lgraph_server -d restart`来重启 TuGraph 服务：  
```bash
$ ./lgraph_server -d restart
Stopping lgraph...
Process stopped.
Starting lgraph...
The service process is started at pid 20899.
```' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.3.重启服务'}","page_content='忘记'admin'密码

2.重启服务

用户需要以正常模式重新启动服务端，然后使用默认账号密码进行登录，登录后重新设置密码即可正常使用。
重新启动TuGraph服务的命令如下：  
```bash
lgraph_server -c /usr/local/etc/lgraph.json -d start
```' metadata={'Header 1': ""忘记'admin'密码"", 'Header 2': '2.重启服务'}","page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

1. 拉取镜像
```shell
docker pull tugraph/tugraph-runtime-centos7:${VERSION}
```  
2. 启动docker  
```shell
docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \
--name tugraph_demo ${REPOSITORY}:${VERSION}' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}","page_content='部署高可用模式

8.docker部署高可用集群

8.1.安装镜像

使用如下命令下载TuGraph的编译docker镜像环境
```shell
docker pull tugraph/tugraph-compile-centos7
```
然后拉取TuGraph源码并编译安装' metadata={'Header 1': '部署高可用模式', 'Header 2': '8.docker部署高可用集群', 'Header 3': '8.1.安装镜像'}",空,空,空,空,空
在FrontierTraversal中，如果开启了TRAVERSAL_PARALLEL标志，事务必须遵循怎样的要求？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

bool parallel = false
);
```  
该方法可用于从指定点集（frontier）中（通过 extract 方法）抽取（类型为 VertexData 的）属性，当 parallel 为 true 时会并行该抽取过程。  
FrontierTraversal 适用于只关注遍历扩展到的点集的情况；当用户在遍历过程或是结果中需要访问路径上的信息（路径上的点/边）时，则需要使用 PathTraversal。
两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。
选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。  
```c
void SetFrontier(size_t root_vid);' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}",空,空,空,空,空,空,空,空,空
如何在使用 CSV 文件导入数据时，将文件中的栏位与 TuGraph 的配置文件中的 columns 进行对应？,"page_content='数据导入

3.配置文件

3.2.配置文件示例

还描述了三个数据文件，两个点的数据文件`actors.csv`和`movies.csv`，一个边的数据文件`roles.csv`。每个部分都描述了：文件的路径（path）、数据类型（format）、信息头占开头几行（header）、是哪个 label 的数据（label）、文件中每行数据中的每个列对应的字段是哪个。  
对于上述配置文件，import 工具在执行的过程中会先在 TuGraph 中创建`actor`、`movie`、`role`这三个 label，然后再执行三个文件的数据导入。' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.2.配置文件示例'}","page_content='数据导入

1.简介

在图数据库服务安装成功后，您可以使用`lgraph_import`批量导入工具将现有数据导入 TuGraph。`lgraph_import`支持从 CSV 文件和 JSON 数据源导入数据。  
> CSV 格式  
```
[movies.csv]
id, name, year, rating
tt0188766,King of Comedy,1999,7.3
tt0286112,Shaolin Soccer,2001,7.3
tt4701660,The Mermaid,2016,6.3
```  
> jsonline 格式  
```json
[""tt0188766"",""King of Comedy"",1999,7.3]
[""tt0286112"",""Shaolin Soccer"",2001,7.3]
[""tt4701660"",""The Mermaid"",2016,6.3]
```  
TuGraph 支持两种导入模式：  
- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。' metadata={'Header 1': '数据导入', 'Header 2': '1.简介'}","page_content='数据导出

1.简介

TuGraph 可以通过 `lgraph_export` 工具来对已经存放在TuGraph的图数据进行数据导出。 `lgraph_export` 工具可以将指定 TuGraph 数据库的数据以 `csv` 或者 `json` 文件形式导出到指定目录，同时导出这些数据进行再导入时需要的配置文件 `import.config` ，详细描述可参见[配置文件](1.data-import.md)。' metadata={'Header 1': '数据导出', 'Header 2': '1.简介'}","page_content='数据导入

4.离线全量导入

4.1.离线导入示例

""columns"": [""aid"", ""name""]
},
{
""path"": ""movies.csv"",
""header"": 2,
""format"": ""CSV"",
""label"": ""movie"",
""columns"": [""mid"", ""name"", ""year"", ""rate""]
},
{
""path"": ""roles.csv"",
""header"": 2,
""format"": ""CSV"",
""label"": ""play_in"",
""SRC_ID"": ""actor"",
""DST_ID"": ""movie"",
""columns"": [""SRC_ID"", ""role"", ""DST_ID""]
}
]
}
```  
使用导入配置文件，我们现在可以使用以下命令导入数据：  
```shell
$ ./lgraph_import
-c import.conf             # 从import.conf读取配置信息
--dir /data/lgraph_db      # 将数据存放在/data/lgraph_db' metadata={'Header 1': '数据导入', 'Header 2': '4.离线全量导入', 'Header 3': '4.1.离线导入示例'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

- path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）
- header（可选，数字，头信息占文件起始的几行，没有就是 0）
- format（必须选，只能是 JSON 或者 CSV）
- label（必选，字符串）
- columns（数组形式）
- SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)
- DST_ID (特殊字符串，仅边有，代表这列是目的点数据)
- SKIP  (特殊字符串，代表跳过这列数据)
- [property]
- SRC_ID (仅边配置，值是起始点标签)
- DST_ID (仅边配置，值是目的点标签)  
#### 3.1.2.索引长度
因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。
##### 3.1.2.1.unique索引' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}",空,空,空,空,空
在创建一个顶点标签时，需要指定哪些参数？,空,空,空,空,空,空,空,空,空,空
TuGraph Browser 的默认端口号是什么？,"page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
5. 前端访问  
访问tugraph-db-browser: `http://x.x.x.x:7070`，数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。
首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='可视化操作手册

2.操作指南

2.1.访问

当用户完成图数据库的安装后，可以通过浏览器访问Browser。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7070。  
- 例如：127.0.0.1:7070。
- 推荐使用Chrome。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.1.访问'}","page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}","page_content='可视化操作手册（旧版）

操作详情

1.连接数据库

当用户完成图数据库的安装后，可以通过浏览器进行访问，TuGraph Browser 工具。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7090。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '1.连接数据库'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
**方式二**  
```shell
docker run -dt -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}",空,空,空,空,空
如何配置用于计算图表中显示的值的方法？,空,空,空,空,空,空,空,空,空,空
TuGraph是由华为团队开发的。,"page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='TuGraph由LDBC认定全球领先

基本介绍

TuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。  
**随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品**。  
开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。  
图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。  
蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。' metadata={'Header 1': 'TuGraph由LDBC认定全球领先', 'Header 2': '基本介绍'}",空,空,空,空,空
图学习系统主要解决的问题是什么？,"page_content='名词解释

2.图产品

> __图计算系统__：一般包括图数据库、图分析系统、图学习系统，有时也特指图分析系统。  
> __图数据库__：侧重于对图数据的增删改查、事务性操作等，如TuGraph DB、Neo4j、JanusGraph等。  
> __图分析系统__：解决图分析问题，可以细分为流水图分析、离线图分析，如TuGraph Analytics、GraphX等。  
> __图学习系统__：解决图学习问题，比如TuGraph Learn、DGL等。' metadata={'Header 1': '名词解释', 'Header 2': '2.图产品'}",空,空,空,空,空,空,空,空,空
如何使用GetVertexByUniqueCompositeIndex函数，并需要提供哪些参数？,"page_content='src/lgraph_api/lgraph_txn.cpp/ VertexIterator Transaction::GetVertexByUniqueIndex(const std::string& label_name,
                                                   const std::string& field_name,
                                                   const std::string& field_value_string) {
    ThrowIfInvalid();
    lgraph::VertexIndexIterator iit = txn_->GetVertexIndexIterator(
        label_name, field_name, field_value_string, field_value_string);
    if (!iit.IsValid()) throw std::runtime_error(""No vertex found with specified index value."");
    return VertexIterator(txn_->GetVertexIterator(iit.GetVid()), txn_);
}

VertexIterator Transaction::GetVertexByUniqueCompositeIndex(const std::string& label_name,
                            const std::vector<std::string>& field_name,
                            const std::vector<std::string>& field_value_string) {
    ThrowIfInvalid();
    lgraph::CompositeIndexIterator iit = txn_->GetVertexCompositeIndexIterator(
        label_name, field_name, field_value_string, field_value_string);
    if (!iit.IsValid())
        throw std::runtime_error(""No vertex found with specified composite index value."");
    return VertexIterator(txn_->GetVertexIterator(iit.GetVid()), txn_);
}' metadata={'file_name': 'lgraph_txn.cpp', 'file_path': 'src/lgraph_api/lgraph_txn.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_txn.cpp'}","page_content='src/lgraph_api/lgraph_txn.cpp/ VertexIterator Transaction::GetVertexByUniqueCompositeIndex(const std::string& label_name,
                            const std::vector<std::string>& field_name,
                            const std::vector<FieldData>& field_value) {
    ThrowIfInvalid();
    lgraph::CompositeIndexIterator iit = txn_->GetVertexCompositeIndexIterator(
        label_name, field_name, field_value, field_value);
    if (!iit.IsValid())
        throw std::runtime_error(""No vertex found with specified composite index value."");
    return VertexIterator(txn_->GetVertexIterator(iit.GetVid()), txn_);
}

OutEdgeIterator Transaction::GetEdgeByUniqueIndex(const std::string& label_name,
                                                  const std::string& field_name,
                                                  const std::string& field_value_string) {
    ThrowIfInvalid();
    lgraph::EdgeIndexIterator eit =
        txn_->GetEdgeIndexIterator(label_name, field_name, field_value_string, field_value_string);
    if (!eit.IsValid()) throw std::runtime_error(""No Edge found with specified index value."");
    EdgeUid euid;
    euid = eit.GetUid();
    return GetOutEdgeIterator(euid, false);
}' metadata={'file_name': 'lgraph_txn.cpp', 'file_path': 'src/lgraph_api/lgraph_txn.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_txn.cpp'}","page_content='src/lgraph_api/lgraph_txn.cpp/ VertexIterator Transaction::GetVertexByUniqueIndex(size_t label_id, size_t field_id,
                                                   const FieldData& field_value) {
    ThrowIfInvalid();
    lgraph::VertexIndexIterator iit =
        txn_->GetVertexIndexIterator(label_id, field_id, field_value, field_value);
    if (!iit.IsValid()) throw std::runtime_error(""No vertex found with specified index value."");

    return VertexIterator(txn_->GetVertexIterator(iit.GetVid()), txn_);
}

VertexIterator Transaction::GetVertexByUniqueCompositeIndex(size_t label_id,
                                                  const std::vector<size_t>& field_id,
                                                  const std::vector<FieldData>& field_value) {
    ThrowIfInvalid();
    lgraph::CompositeIndexIterator iit = txn_->GetVertexCompositeIndexIterator(
        label_id, field_id, field_value, field_value);
    if (!iit.IsValid())
        throw std::runtime_error(""No vertex found with specified composite index value."");
    return VertexIterator(txn_->GetVertexIterator(iit.GetVid()), txn_);
}' metadata={'file_name': 'lgraph_txn.cpp', 'file_path': 'src/lgraph_api/lgraph_txn.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_txn.cpp'}","page_content='src/core/transaction.cpp/ CompositeIndexIterator Transaction::GetVertexCompositeIndexIterator(const std::string& label,
                                    const std::vector<std::string>& fields,
                                    const std::vector<std::string>& key_start,
                                    const std::vector<std::string>& key_end) {
    std::string fields_name = curr_schema_->v_schema_manager.GetSchema(label)
                                  ->GetCompositeIndexMapKey(fields);
    CompositeIndex* index = GetVertexCompositeIndex(label, fields);
    if (!index || !index->IsReady()) {
        THROW_CODE(InputError, ""VertexIndex is not created for {}:{}"", label, fields_name);
    }
    std::vector<Value> key_start_values, key_end_values;
    int num = fields.size();
    if (!key_start.empty()) {
        for (int i = 0; i < num; ++i) {
            key_start_values.push_back(field_data_helper::ParseStringToValueOfFieldType(
                key_start[i], index->key_types[i]));
        }
    }
    if (!key_end.empty()) {
        for (int i = 0; i < num; ++i) {
            key_end_values.push_back(field_data_helper::ParseStringToValueOfFieldType(
                key_end[i], index->key_types[i]));
        }
    }
    return index->GetIterator(this,
                  composite_index_helper::GenerateCompositeIndexKey(key_start_values),
                  composite_index_helper::GenerateCompositeIndexKey(key_end_values));
}' metadata={'file_name': 'transaction.cpp', 'file_path': 'src/core/transaction.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/transaction.cpp'}","page_content='src/core/composite_index.cpp/ void CompositeIndexIterator::RefreshContentIfKvIteratorModified() {
    if (IsValid() && it_->IsValid() && it_->UnderlyingPointerModified()) {
        valid_ = false;
        switch (type_) {
        case CompositeIndexType::UniqueIndex:
            {
                if (!it_->GotoClosestKey(curr_key_)) return;
                if (KeyOutOfRange()) return;
                LoadContentFromIt();
                return;
            }
        case CompositeIndexType::NonUniqueIndex:
            {
                if (!it_->GotoClosestKey(_detail::PatchKeyWithVid(curr_key_, vid_)))
                    return;
                if (KeyOutOfRange()) return;
                // non-unique, need to find correct pos_
                iv_ = VertexIndexValue(it_->GetValue());
                pos_ = iv_.SearchVid(vid_, valid_);
                if (pos_ >= iv_.GetVidCount()) return;
                valid_ = true;
                curr_key_.Copy(GetKey());
                vid_ = iv_.GetNthVid(pos_);
                return;
            }
        }
        // now it_ points to a valid position, but not necessary the right one
    }
}' metadata={'file_name': 'composite_index.cpp', 'file_path': 'src/core/composite_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/composite_index.cpp'}",空,空,空,空,空
如何配置TuGraph中的RPC端口？,"page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.2 与TuGraph建立连接**

当前TuGraph-OGM提供了RPC driver用于连接TuGraph，具体配置如下所示：  
```java
// 配置

String databaseUri = ""list://ip:port"";

String username = ""username"";

String password = ""password"";

//启动driver

Driver driver = new RpcDriver();

Configuration.Builder baseConfigurationBuilder = new Configuration.Builder()

•uri(databaseUri)

• verifyConnection (true)

•credentials (username, password);

driver.configure(baseConfigurationBuilder.build());

// 开启session' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.2 与TuGraph建立连接**'}","page_content='数据库运行

4.服务配置

4.2.服务器配置文件

TuGraph 的配置文件以 JSON 格式存储。建议将大多数配置存储在配置文件中，并且仅在需要时使用命令行选项临时修改某些配置参数。
一个典型的配置文件如下：  
```json
{
""directory"" : ""/var/lib/lgraph/data"",
""host"" : ""0.0.0.0"",
""port"" : 7070,
""rpc_port"" : 9090,
""enable_rpc"" : true,
""bolt_port"": 7687,
""enable_ha"" : false,
""verbose"" : 1,
""log_dir"" : ""/var/log/lgraph_log"",
""disable_auth"" : false,
""ssl_auth"" : false,
""server_key"" : ""/usr/local/etc/lgraph/server-key.pem"",
""server_cert"" : ""/usr/local/etc/lgraph/server-cert.pem"",' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.2.服务器配置文件'}","page_content='部署高可用模式

2.准备工作

要启用高可用模式，用户需要：  
- 三台及以上的 TuGraph 服务器实例。  
- 在启动 lgraph_server 时打开高可用模式，可以使用配置文件或者命令行将`enable_ha`选项设置为`true`。  
- 设置正确的`rpc_port`，可通过配置文件或者命令行设置。' metadata={'Header 1': '部署高可用模式', 'Header 2': '2.准备工作'}","page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}","page_content='demo/TuGraph-Demo.md/ # TuGraph 示例

## 1 简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph是TuGraph的曾用名。

主要功能特征包括：

- 支持属性图模型
- 原生图存储及处理
- 完全的ACID事务支持
- 支持OpenCypher图查询语言
- 支持原生的Core API和Traversal API
- 支持REST和RPC接口
- 支持CSV、JSON、MySQL等多数据源导入导出
- 支持可视化图交互
- 支持命令行交互
- 内置用户权限控制、操作审计
- 支持任务和日志的监控管理
- 原生适配PandaGraph图分析引擎
- 集成DGL图神经网络系统

性能及可扩展性特征包括：

- 支持TB级大容量
- 吞吐率高达千万顶点每秒
- 面向读优化的存储引擎
- 支持高可用模式
- 支持离线备份恢复
- 在线热备份
- 高性能批量导入导出

## 2 快速上手

见QuickStart文档。

## 3 基本功能

### 3.1 RPC Client
#### 3.1.1 概述
RPC Client是对cpp语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.1.2 编译
在代码目录demo/CppRpcClientDemo目录下,执行下列命令 ,成功后将会看到可执行文件clientdemo
```bash
mkdir build && cd build && cmake ../ && make
```
#### 3.1.3 运行
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
        -h             show this usage
        -i --ip        ip for graph server
        -p --port      port for graph server
        -g --graph     graph name
        -u --user      user name
        --password     user password
        -c --cypher    cypher to query
举例如下
```bash
./clientdemo -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
### 3.2 Python RPC Client
#### 3.2.1 概述
Python RPC Client是对python语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.2.2 运行
需要依赖编译生成的python_client.so库，将python_client.so与client_python.py放在同一目录下
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
-h             show this usage
-i --ip        ip for graph server
-p --port      port for graph server
-g --graph     graph name
-u --user      user name
--password     user password
-c --cypher    cypher to query
举例如下
```bash
python3 client_python.py -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
## 4 集成工具

### 4.1 DataX 导入导出工具
#### 4.1.1 概述
DataX 支持 TuGraph 和 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源的数据导入导出。
#### 4.' metadata={'file_name': 'TuGraph-Demo.md', 'file_path': 'demo/TuGraph-Demo.md', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/TuGraph-Demo.md'}",空,空,空,空,空
图数据库在处理关联关系时，相比于关系型数据库有什么优势？,"page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.1. 性能

在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.1. 性能'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.2. 兼容性

现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.2. 兼容性'}","page_content='什么是图数据库

3. 图数据库与关系型数据库对比

| 分类         | 模型   | 优势                                   | 劣势                                     | 举例           |
| ------------ | ------ | -------------------------------------- | ---------------------------------------- | -------------- |
| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |
| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |' metadata={'Header 1': '什么是图数据库', 'Header 2': '3. 图数据库与关系型数据库对比'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.3. 直观性

使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.3. 直观性'}","page_content='什么是图数据库

3. 图数据库与关系型数据库对比

| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |
| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |  
总之，面对海量数据的存储和处理问题，传统的关系数据库已经无法满足大部分的日常数据存储需求。图数据库技术可以将关系信息存储为实体，灵活拓展数据模型。由于提供了对关联数据最直接的表达方式和图模型对异构数据的天然包容性，图数据库技术必将成为未来最热点的技术之一，为企业提供存储和分析大规模图数据的有力支持。' metadata={'Header 1': '什么是图数据库', 'Header 2': '3. 图数据库与关系型数据库对比'}",空,空,空,空,空
使用TuGraph Browser时，默认的登录密码是什么？,"page_content='可视化操作手册

2.操作指南

2.2.登录

![login](../../../images/browser/login.png)  
- 浏览器成功访问Browser后，首先进入的是登录页面（如上图所示），用户需要填写账号和密码进行登录。
- 数据库地址格式为：ip:bolt_port。
- 默认账号：admin。
- 默认密码：73@TuGraph。
- 用户首次登录后，会跳转至修改密码页面，密码修改成功后，使用新密码重新登录即可使用。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.2.登录'}","page_content='可视化操作手册（旧版）

操作详情

2.登录数据库

![alt 登录](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/1.tugraph-browser-lpgin.png)  
- 页面打开成功会，首先进图的是登录页面，用户需要填写账号和密码进行登录。
- 默认账号：admin
- 默认密码：73@TuGraph
- 建议用户登录后，及时修改初始化的密码' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '2.登录数据库'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
5. 前端访问  
访问tugraph-db-browser: `http://x.x.x.x:7070`，数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。
首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='忘记'admin'密码

1.重置密码

首先，需要停止TuGraph服务端。如果是容器内部署，需要进入容器中执行如下命令：  
```bash
lgraph_server -c /usr/local/etc/lgraph.json -d stop
```  
再次启动TuGraph服务端时，需要添加如下参数：  
```bash
--reset_admin_password 1
```  
如下所示：
```bash
lgraph_server -c /usr/local/etc/lgraph.json --reset_admin_password 1 --log_dir """"
```  
这一操作可以使得TuGraph服务端在启动时，重置管理者`admin`的密码为默认密码：`73@TuGraph`。
密码重置成功会给出相关信息“Reset admin password successfully”并关闭当前服务端进程。' metadata={'Header 1': ""忘记'admin'密码"", 'Header 2': '1.重置密码'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| reset_admin_password         | 布尔值                   | 是否重置管理者密码。 默认值为 false。 为 true 时，密码重置为`73@TuGraph`。                                                                                                                                |
| enable_fulltext_index        | 布尔值                   | 是否启用全文索引功能，默认值为 false。                                                                                                                                                            |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}",空,空,空,空,空
SetFields函数的第一个版本中，field_value_strings参数的数据类型是什么？,"page_content='src/python/python_api.cpp/ ""SetFields"",
            [](VertexIterator& vit, const pybind11::dict& value_dict) {
                std::vector<std::string> fnames;
                std::vector<FieldData> fdata;
                PyDictToVectors(value_dict, fnames, fdata);
                return vit.SetFields(fnames, fdata);
            },
            ""Sets the fields with values as specified in value_dict.\n""
            ""value_dict specifies the field_name:value dict."",
            pybind11::arg(""value_dict""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetFields"",
            [](InEdgeIterator& vit, const pybind11::dict& value_dict) {
                std::vector<std::string> fnames;
                std::vector<FieldData> fdata;
                PyDictToVectors(value_dict, fnames, fdata);
                return vit.SetFields(fnames, fdata);
            },
            ""Sets the fields with values as specified in value_dict.\n""
            ""value_dict specifies the field_name:value dict."",
            pybind11::arg(""value_dict""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetFields"",
            [](VertexIterator& vit, const std::vector<std::string>& field_names,
               const std::vector<std::string>& field_value_strings) {
                return vit.SetFields(field_names, field_value_strings);
            },
            ""Sets the fields specified by field_names with field values in ""
            ""string representation.\n""
            ""field_names specifies the names of the fields to set.\n""
            ""field_value_strings are the field values in string representation."",
            pybind11::arg(""field_names""), pybind11::arg(""field_value_strings""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetFields"",
            [](OutEdgeIterator& eit, const std::vector<std::string>& field_names,
               const std::vector<std::string>& field_value_strings) {
                return eit.SetFields(field_names, field_value_strings);
            },
            ""Sets the fields specified by field_names with field values in ""
            ""string representation.\n""
            ""field_names specifies the names of the fields to set.\n""
            ""field_value_strings are the field values in string representation."",
            pybind11::arg(""field_names""), pybind11::arg(""field_value_strings""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetFields"",
            [](InEdgeIterator& eit, const std::vector<std::string>& field_names,
               const std::vector<std::string>& field_value_strings) {
                return eit.SetFields(field_names, field_value_strings);
            },
            ""Sets the fields specified by field_names with field values in ""
            ""string representation.\n""
            ""field_names specifies the names of the fields to set.\n""
            ""field_value_strings are the field values in string representation."",
            pybind11::arg(""field_names""), pybind11::arg(""field_value_strings""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}",空,空,空,空,空
DB和TuGraph Analytics是独立运行的吗？,"page_content='数据库运行

1.前置条件

TuGraph 运行的前置条件为 TuGraph 正确安装，参考[安装流程](1.environment.md)。  
TuGraph 运行需要保证库文件 liblgraph.so 的文件位置在环境变量 LD_LIBRARY_PATH。  
运行 TuGraph 进程的用户不需要超级权限，但需要对配置文件（一般为lgraph.json）及文件中涉及的文件有读权限，并且对数据文件夹、日志文件夹等有写权限。' metadata={'Header 1': '数据库运行', 'Header 2': '1.前置条件'}","page_content='数据库运行

2.运行模式

TuGraph 可以作为前台普通进程启动，也可以作为后台守护进程启动。
当作为普通进程运行时，TuGraph 可以直接将日志打印到终端，这在调试服务器配置时非常方便。但是，由于前台进程在终端退出后被终止，因此用户须确保在 TuGraph 服务器处于运行状态时，终端保持打开状态。另一方面，在守护进程模式下，即使启动它的终端退出，TuGraph 服务器也可以继续运行。因此，在长时间运行的服务器下推荐以守护进程模式启动 TuGraph 服务器。' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式'}","page_content='图算法介绍

3\. 系统设计

| 动态代理 | 部署分发难度大 |
| 支持复杂类型 | 版本难兼容 |
| API使用简易 | 运行时环境依赖复杂 |  
4.Web服务化  
Web服务化是一种将机器学习模型部署成网络服务，调用者通过相应的api获取模型推理结果。  
| **优点** | **缺点** |
| --- | --- |
| 扩展性好 | 性能差 |
| 简易且轻量 | 不适合计算密集型场景 |
| 社区支持 | 无状态管理 |
| 机器学习类库易集成 | 并发连接有限 |  
在TuGraph Analytics模型推理系统的架构设计中，核心部分是通过C++原生语言建立起来的一座桥梁，实现Python环境和Java虚拟机之间高效的数据交互和操作指令的传递。通过使用C++作为媒介语言，我们不仅能够利用其接近硬件的执行效率，确保数据交互的性能，还能够保证在两个虚拟环境之间数据交换的计算精度和稳定性。基于共享内存的设计允许Python和JVM进程各自独立运行，既保证了运行环境的安全隔离，又能实现数据的高效共享。' metadata={'Header 1': '图算法介绍', 'Header 2': '3\\. 系统设计'}","page_content='试用体验：TuGraph — 简单高效的图数据库

配套的可视化试用工具

TuGraph提供了一款配套的可视化试用工具，使得对图数据库的操作更加直观和方便。我可以通过可视化工具轻松浏览图数据、执行查询和分析结果。这对我理解数据结构和发现潜在关联非常有帮助。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '配套的可视化试用工具'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。  
TuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法。涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}",空,空,空,空,空
RpcClient 构造函数需要什么参数才能用于用户登录？,"page_content='RPC API

3.登录

登录请求信息包含以下参数：
- user: 必要参数，用户名
- pass: 必要参数，密码
以C++为例，用户使用构建好的服务存根发送登录请求：
```C++
auto* req = request.mutable_acl_request();
auto* auth = req->mutable_auth_request()->mutable_login();
auth->set_user(user);
auth->set_password(pass);
// send data
cntl->Reset();
cntl->request_attachment().append(FLAGS_attachment);
req->set_client_version(server_version);
req->set_token(token);
LGraphRPCService_Stub stub(channel.get());
LGraphResponse res;' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='src/client/python/rpc/client.cpp/ {
    // define lgraph::RpcClient class
    py::class_<LGraphPythonClient> c(m, ""client"", ""this is a python rpc client"");
    // define the constructor
    c.def(pybind11::init<const std::string &, const std::string &,
          const std::string &>(),
          ""Client Login\n""
          ""url        Login address.\n""
          ""user       The username.\n""
          ""password   The password.\n"",
          pybind11::arg(""url""), pybind11::arg(""user""),
          pybind11::arg(""password""));

    c.def(pybind11::init<std::vector<std::string> &, const std::string &,
                  const std::string &>(),
          ""Client Login\n""
          ""urls       Login address.\n""
          ""user       The username.\n""
          ""password   The password.\n"",
          pybind11::arg(""urls""), pybind11::arg(""user""),
          pybind11::arg(""password""));

    // define other function' metadata={'file_name': 'client.cpp', 'file_path': 'src/client/python/rpc/client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/rpc/client.cpp'}","page_content='RPC API

3.登录

if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
token = res.acl_response().auth_response().token();
```
登录响应信息包含以下参数：
- token: 必要参数，登录成功会收到带有签名的令牌，即 Json Web Token，客户端储存该令牌，并且用于以后的每次发送请求。
如果登录失败会收到“Authentication failed”错误。' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='RPC API

3.登录

LGraphRPCService_Stub stub(channel.get());
LGraphResponse res;
stub.HandleRequest(cntl.get(), req, &resp, nullptr);
if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
server_version = std::max(server_version, res.server_version());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
token = res.acl_response().auth_response().token();
```
登录响应信息包含以下参数：
- token: 必要参数，登录成功会收到带有签名的令牌，即 Json Web Token，客户端储存该令牌，并且用于以后的每次发送请求。' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='C++客户端

2.使用示例

2.1.实例化client对象

```
```
RpcClient(std::vector<std::string>& urls, std::string user, std::string password)
@param urls: tugraph host list
@param user: login user name
@param password: login password
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.1.实例化client对象'}",空,空,空,空,空
如何使用lgraph_cypher工具在命令行中以单命令模式提交一条Cypher查询，并将结果保存？,"page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ std::string RpcClient::RpcSingleClient::SingleElementExtractor(const CypherResult cypher)' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/cypher/execution_plan/scheduler.cpp/ ctx->result_info_ = std::make_unique<ResultInfo>();
            ctx->result_ = std::make_unique<lgraph::Result>();
            std::string header, data;
            if (plan->CommandType() == parser::CmdType::EXPLAIN) {
                header = ""@plan"";
                data = plan->DumpPlan(0, false);
            } else {
                header = ""@profile"";
                data = plan->DumpGraph();
            }
            ctx->result_->ResetHeader({{header, lgraph_api::LGraphType::STRING}});
            auto r = ctx->result_->MutableRecord();
            r->Insert(header, lgraph::FieldData(data));' metadata={'file_name': 'scheduler.cpp', 'file_path': 'src/cypher/execution_plan/scheduler.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/scheduler.cpp'}","page_content='src/python/FMA_shell/pkg/setup.py/ from setuptools import setup

setup(
    name=""lgraph_cypher"",
    description='cypher quarry command line tool for TuGraph',
    install_requires=[
        'click==7.0',
        'prompt_toolkit==2.0.9',
        'prettytable==0.7.2',
        'requests==2.22.0',
    ],
    packages=['lgraph_shell'],
    entry_points={
        'console_scripts': [
            'lgraph_cypher = lgraph_shell.lgraph_cypher:start'
        ]
    }
)' metadata={'file_name': 'setup.py', 'file_path': 'src/python/FMA_shell/pkg/setup.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/FMA_shell/pkg/setup.py'}","page_content='src/cypher/execution_plan/scheduler.cpp/ ctx->result_info_ = std::make_unique<cypher::ResultInfo>();
            ctx->result_ = std::make_unique<lgraph::Result>();
            std::string header, data;
            if (visitor.CommandType() == parser::CmdType::EXPLAIN) {
                header = ""@plan"";
                data = plan->DumpPlan(0, false);
            } else {
                header = ""@profile"";
                data = plan->DumpGraph();
            }
            ctx->result_->ResetHeader({{header, lgraph_api::LGraphType::STRING}});
            auto r = ctx->result_->MutableRecord();
            r->Insert(header, lgraph::FieldData(data));
            LOG_DEBUG() << ""--- execution_plan_v2 dump ---"";
            LOG_DEBUG() << ctx->result_->Dump(false);' metadata={'file_name': 'scheduler.cpp', 'file_path': 'src/cypher/execution_plan/scheduler.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/scheduler.cpp'}","page_content='src/python/FMA_shell/setup.py/ from setuptools import setup

setup(
    name=""lgraph_cypher"",
    description='cypher quarry command line tool for TuGraph',
    install_requires=[
        'click==7.0',
        'prompt_toolkit==2.0.9',
        'prettytable==0.7.2',
        'requests==2.32.2',
    ],
    packages=['lgraph_shell'],
    entry_points={
        'console_scripts': [
            'lgraph_cypher = lgraph_shell.lgraph_cypher:start'
        ]
    }
)' metadata={'file_name': 'setup.py', 'file_path': 'src/python/FMA_shell/setup.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/FMA_shell/setup.py'}",空,空,空,空,空
数据和日志目录的持久化位置在哪里？,"page_content='快速上手

2.安装

2.1.通过docker快速体验

# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
**方式二**  
```shell
docker run -dt -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \
--name tugraph_demo ${REPOSITORY}:${VERSION} /bin/bash' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
**方式二**  
```shell
docker run -dt -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| directory                    | 字符串                   | 数据文件所在目录。如果目录不存在 ，则自动创建。默认目录为 /var/lib/lgraph/data。                                                                                                                               |
| durable                      | 布尔值                   | 是否开启实时持久化。关闭持久化可以减少写入时的磁盘 IO 开销，但是在机器断电等极端情况下可能丢失数据。默认值为 `true`。                                                                                                                  |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}",空,空,空,空,空,空,空
TuGraph 的 Traversal API 中对于设置遍历的起始点有哪些三种方式？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

```c
void SetFrontier(size_t root_vid);
void SetFrontier(ParallelVector<size_t> & root_vids);
void SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter);
```  
两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。  
两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。
选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。  
```c
void SetFrontier(size_t root_vid);
void SetFrontier(ParallelVector<size_t> & root_vids);
void SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter);
```  
两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

);
void ExpandEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,
std::function<bool(InEdgeIterator &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
```  
上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。  
```c' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
```  
上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。  
```c
ParallelVector<size_t> & GetFrontier();
```  
当前点集合的扩展结束后，新的点集合可以通过上述方法取得。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &, Path &, IteratorHelper &)> out_edge_filter = nullptr,' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter = nullptr
);
```  
PathTraversal 的三种遍历方式与 FrontierTraversal 类似，只是用户自定义的过滤函数中增加了两个参数，其中：Path 包含了到新扩展的这条边之前的路径，IteratorHelper 可用于将路径中的点/边转为数据库中对应的迭代器，相关文档可参考对应的 C++ API 文档。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}",空,空,空,空,空
`SetField` 方法的目的是什么？,"page_content='src/python/python_api.cpp/ ""SetField"",
            [](VertexIterator& vit, const std::string& field_name,
               const pybind11::object& field_value_object) {
                FieldData field_value = ObjectToFieldData(field_value_object);
                return vit.SetField(field_name, field_value);
            },
            ""Sets the specified field"", pybind11::arg(""field_name""),
            pybind11::arg(""field_value_object""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetField"",
            [](OutEdgeIterator& eit, const std::string& field_name,
               const pybind11::object& field_value_object) {
                FieldData field_value = ObjectToFieldData(field_value_object);
                return eit.SetField(field_name, field_value);
            },
            ""Sets the specified field"", pybind11::arg(""field_name""),
            pybind11::arg(""field_value_object""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetField"",
            [](InEdgeIterator& eit, const std::string& field_name,
               const pybind11::object& field_value_object) {
                FieldData field_value = ObjectToFieldData(field_value_object);
                return eit.SetField(field_name, field_value);
            },
            ""Sets the specified field"", pybind11::arg(""field_name""),
            pybind11::arg(""field_value_object""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetFields"",
            [](VertexIterator& vit, const std::vector<std::string>& field_names,
               const std::vector<FieldData>& field_values) {
                return vit.SetFields(field_names, field_values);
            },
            ""Sets the fields specified by field_names with new values.\n""
            ""field_names specifies the names of the fields to set.\n""
            ""field_values are the FieldData containing field values."",
            pybind11::arg(""field_names""), pybind11::arg(""field_values""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""SetFields"",
            [](InEdgeIterator& vit, const std::vector<std::string>& field_names,
               const std::vector<FieldData>& field_values) {
                return vit.SetFields(field_names, field_values);
            },
            ""Sets the fields specified by field_names with new values.\n""
            ""field_names specifies the names of the fields to set.\n""
            ""field_values are the FieldData containing field values."",
            pybind11::arg(""field_names""), pybind11::arg(""field_values""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}",空,空,空,空,空
TuGraph-DB图数据库是由哪个团队研发的？,"page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='TuGraph由LDBC认定全球领先

基本介绍

TuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。  
**随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品**。  
开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。  
图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。  
蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。' metadata={'Header 1': 'TuGraph由LDBC认定全球领先', 'Header 2': '基本介绍'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='云部署

1.简介

TuGraph（tugraph.antgroup.com）是蚂蚁集团研发的高性能图数据库（Graph Database）。TuGraph在计算巢上提供了社区版服务，您无需自行购置云主机，即可在计算巢上快速部署TuGraph服务、实现运维监控，从而搭建您自己的图应用。本文向您介绍如何开通计算巢上的TuGraph社区版服务，以及部署流程和使用说明。' metadata={'Header 1': '云部署', 'Header 2': '1.简介'}",空,空,空,空,空
TuGraph的精简运行环境需要哪些系统库？,"page_content='环境分类

2.依赖系统库

针对三种环境，除去TuGraph的运行包，所需要的系统库如下：
* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。
* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。
* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='环境分类

1.分类

根据环境所承载功能的不同，区分为编译环境，运行环境，以及精简运行环境。
* 编译环境，具备TuGraph编译的所有依赖库，包含运行环境的所有依赖，并且能够编译TuGraph源码，但不包含预编译好的TuGraph可执行文件和库文件，供开发者编译源码使用。
* 运行环境，具备GCC/Java/Python环境，能够运行TuGraph的所有功能，并且能承载全文索引，java client，c++源码上传为plugin，以及python plugin的完整功能，内置TuGraph预编译好的可执行文件和库文件，供客户直接安装使用，无需编译源码。
* 精简运行环境，约等于裸系统加预编译TuGraph，仅能运行TuGraph的基本功能，无C++ plugin编译运行，仅so上传，无全文索引，无python plugin，供快速搭建试用。  
TuGraph编译后，会把所有的依赖库以.a的形式打包在一起，因此原则上运行不需要的其他的依赖库。但TuGraph支持存储过程，即在服务端编译C++代码，因此在环境中依然需要涉及的编译器。' metadata={'Header 1': '环境分类', 'Header 2': '1.分类'}","page_content='环境和版本选择

2. 环境能力选择

用户可以根据实际使用场景，来选择不同的环境。编译环境的能力最完备，所需的第三方软件也越多。与其相对应的，精简运行环境几乎不需要安装任何依赖库，能运行TuGraph除存储过程外的基础功能。  
| 环境     | 用途             | 备注        |
|--------|----------------|-----------|
| 编译环境   | 从源码编译TuGraph   | 适用于开发人员   |
| 运行环境   | 运行TuGraph安装包   | 适用于大部分用户  |
| 精简运行环境 | 运行精简TuGraph安装包 | 对系运行统依赖较小 |  
不同环境的具体介绍参见 [链接](../5.installation&running/2.environment-mode.md)。' metadata={'Header 1': '环境和版本选择', 'Header 2': '2. 环境能力选择'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='本地包部署

1. 环境准备

TuGraph本地包部署需要对应的环境，快速验证可以使用精简安装包，几乎不需要任何第三方库。  
如果您需要使用完整的TuGraph功能，请参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile，该脚本包含完整的环境构建流程。' metadata={'Header 1': '本地包部署', 'Header 2': '1. 环境准备'}",空,空,空,空,空
函数 SetFrontier(std::function<bool(VertexIterator&)> root_vertex_filter 是如何使用参数 root_vertex_filter 的？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

```c
void SetFrontier(size_t root_vid);
void SetFrontier(ParallelVector<size_t> & root_vids);
void SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter);
```  
两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。  
两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='src/lgraph_api/lgraph_traversal.cpp/ void FrontierTraversal::SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter) {' metadata={'file_name': 'lgraph_traversal.cpp', 'file_path': 'src/lgraph_api/lgraph_traversal.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_traversal.cpp'}","page_content='src/lgraph_api/lgraph_traversal.cpp/ void PathTraversal::SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter) {' metadata={'file_name': 'lgraph_traversal.cpp', 'file_path': 'src/lgraph_api/lgraph_traversal.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_traversal.cpp'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

两类 Traversal 的构造函数均有四个参数，分别为数据库句柄 db、事务句柄 txn、选项 flags 和 初始化数组容量 capacity。
选项的可选值包括以下的组合：TRAVERSAL_PARALLEL 表示遍历时使用多个线程并行；TRAVERSAL_ALLOW_REVISITS 表示遍历时允许重复地访问点（PathTraversal 隐含了该选项）。capacity 表示初始化时路径集合的容量。  
```c
void SetFrontier(size_t root_vid);
void SetFrontier(ParallelVector<size_t> & root_vids);
void SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter);
```  
两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}",空,空,空,空,空,空
rpm包中是否包含新版前端页面资源？,空,空,空,空,空,空,空,空,空,空
请问镜像 tugraph-runtime-centos7 启动大概需要多少资源？,"page_content='快速上手

2.安装

2.1.通过docker快速体验

1. 本地安装 docker 环境  
参考 docker 官方文档：https://docs.docker.com/get-started/  
2. 拉取镜像
```shell
docker pull tugraph/tugraph-runtime-centos7
```  
3. 启动docker  
启动 TuGraph 服务可以通过两种方式来实现。第一种方式将镜像拉取与服务启动整合在一起，用户只需执行运行容器的操作，即可同时启动 TuGraph 服务。第二种方式则是在创建 TuGraph 容器后，手动进入容器内部以触发服务启动。尽管这种方法初期步骤稍显繁琐，但在如忘记密码的情况下，它提供了更灵活的密码重置选项。  
**方式一**  
```shell
docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='QA汇总

安装部署QA

使用Docker

- 如果使用 docker pull 下载的镜像则不用导入镜像。如果使用官网下载的压缩包，则要使用`docker load -i ./tugraph_x.y.z.tar`**[注：x.y.z 是版本号的代替符，具体数值根据自己下载的版本进行改写]**
- 启动 docker 容器`docker run -d -p 7070:7070 -p 9090:9090 --name tugraph_demo tugraph/tugraph-runtime-centos7 lgraph_server`**[注：具体的镜像名称 tugraph/tugraph-runtime-centos7 要以本地实际镜像名称为准，可用过 docker images 命令查看]**' metadata={'Header 1': 'QA汇总', 'Header 2': '安装部署QA', 'Header 3': '使用Docker'}","page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

1. 拉取镜像
```shell
docker pull tugraph/tugraph-runtime-centos7:${VERSION}
```  
2. 启动docker  
```shell
docker run -d -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \
--name tugraph_demo ${REPOSITORY}:${VERSION}' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}","page_content='部署高可用模式

8.docker部署高可用集群

8.1.安装镜像

使用如下命令下载TuGraph的编译docker镜像环境
```shell
docker pull tugraph/tugraph-compile-centos7
```
然后拉取TuGraph源码并编译安装' metadata={'Header 1': '部署高可用模式', 'Header 2': '8.docker部署高可用集群', 'Header 3': '8.1.安装镜像'}","page_content='Docker部署

2.现有Docker Image

2.3.常见Docker操作

修改镜像名称
```bash
docker tag ${image_name}:${image_tag} tugraph/tugraph-runtime-centos7:3.3.0
```  
上传镜像
```bash
docker push tugraph/tugraph-compile-centos7:1.2.0 .
```  
获取镜像
```bash
docker pull tugraph/tugraph-compile-centos7:1.2.0
```  
导出镜像
```bash
docker save ${image_name}:${image_tag} | gzip > lgraph_latest.tar.gz
```  
导入镜像
```bash
docker load --input lgraph_latest.tar.gz
```  
其他Docker操作请参考[docker官方文档](https://docs.docker.com/engine/reference/commandline/cli )' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.3.常见Docker操作'}",空,空,空,空,空
在创建组合索引时，需要提供哪些参数？,"page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）
2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节  
##### 1.3.2.1 唯一索引  
和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，
在同一个图中，相同label的点的该组属性不会存在相同的值。
由于底层存储设计，组合索引key需要保存属性的长度，因此，' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

1. 建立组合索引的属性个数在2到16个之间（含）
2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节  
##### 1.3.2.1 唯一索引  
和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，
在同一个图中，相同label的点的该组属性不会存在相同的值。
由于底层存储设计，组合索引key需要保存属性的长度，因此，
组合唯一索引key的最大长度是480-2*(属性个数-1) bytes，**超过的属性不能建立唯一索引**。  
##### 1.3.2.2 非唯一索引  
和点的普通非唯一索引类似，点的非唯一索引指的是非全局唯一的索引，即若一组属性设置了非唯一索引，
在同一个图中，相同label的点的该组属性可以存在相同的值。
由于非唯一索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}",空,空,空,空,空,空,空
`SetField` 函数抛出的异常之一是什么？,空,空,空,空,空,空,空,空,空,空
TuGraphClient是什么？,"page_content='TuGraph Java Client

特性

- Java中的RPC客户端
- OGM，即对象图映射，支持将图中的实体和关系映射到Java对象，从而加速Java开发过程。' metadata={'Header 1': 'TuGraph Java Client', 'Header 2': '特性'}","page_content='demo/TuGraph-Demo.md/ # TuGraph 示例

## 1 简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph是TuGraph的曾用名。

主要功能特征包括：

- 支持属性图模型
- 原生图存储及处理
- 完全的ACID事务支持
- 支持OpenCypher图查询语言
- 支持原生的Core API和Traversal API
- 支持REST和RPC接口
- 支持CSV、JSON、MySQL等多数据源导入导出
- 支持可视化图交互
- 支持命令行交互
- 内置用户权限控制、操作审计
- 支持任务和日志的监控管理
- 原生适配PandaGraph图分析引擎
- 集成DGL图神经网络系统

性能及可扩展性特征包括：

- 支持TB级大容量
- 吞吐率高达千万顶点每秒
- 面向读优化的存储引擎
- 支持高可用模式
- 支持离线备份恢复
- 在线热备份
- 高性能批量导入导出

## 2 快速上手

见QuickStart文档。

## 3 基本功能

### 3.1 RPC Client
#### 3.1.1 概述
RPC Client是对cpp语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.1.2 编译
在代码目录demo/CppRpcClientDemo目录下,执行下列命令 ,成功后将会看到可执行文件clientdemo
```bash
mkdir build && cd build && cmake ../ && make
```
#### 3.1.3 运行
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
        -h             show this usage
        -i --ip        ip for graph server
        -p --port      port for graph server
        -g --graph     graph name
        -u --user      user name
        --password     user password
        -c --cypher    cypher to query
举例如下
```bash
./clientdemo -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
### 3.2 Python RPC Client
#### 3.2.1 概述
Python RPC Client是对python语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.2.2 运行
需要依赖编译生成的python_client.so库，将python_client.so与client_python.py放在同一目录下
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
-h             show this usage
-i --ip        ip for graph server
-p --port      port for graph server
-g --graph     graph name
-u --user      user name
--password     user password
-c --cypher    cypher to query
举例如下
```bash
python3 client_python.py -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
## 4 集成工具

### 4.1 DataX 导入导出工具
#### 4.1.1 概述
DataX 支持 TuGraph 和 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源的数据导入导出。
#### 4.' metadata={'file_name': 'TuGraph-Demo.md', 'file_path': 'demo/TuGraph-Demo.md', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/TuGraph-Demo.md'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='TuGraph console client

在线数据导出

lgraph_cli 支持流式读取，导出数据只需要把lgraph_cli的输出重定向到文件中即可，导出格式支持csv和json。' metadata={'Header 1': 'TuGraph console client', 'Header 2': '在线数据导出'}","page_content='TuGraph console client

`lgraph_cli`使用

TuGraph>
```  
非交互式
```powershell' metadata={'Header 1': 'TuGraph console client', 'Header 2': '`lgraph_cli`使用'}",空,空,空,空,空
TuGraph 支持哪些类型的硬件平台？,"page_content='环境准备

1.硬件环境

1.1. CPU

TuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的硬件平台，测试认证过的硬件平台包括 Intel、AMD、Kunpeng、Hygon、飞腾等。' metadata={'Header 1': '环境准备', 'Header 2': '1.硬件环境', 'Header 3': '1.1. CPU'}","page_content='快速上手

1.简介

1.1.支持的平台

TuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的的平台。' metadata={'Header 1': '快速上手', 'Header 2': '1.简介', 'Header 3': '1.1.支持的平台'}","page_content='环境准备

2.软件环境

2.1. 操作系统

TuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。  
其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。' metadata={'Header 1': '环境准备', 'Header 2': '2.软件环境', 'Header 3': '2.1. 操作系统'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='TuGraph与ARM架构

内容：

TuGraph作为蚂蚁集团开源的高性能图数据库，近期在完成多平台认证的基础上，在ARM架构上发挥出极致的性能，获得了国际权威图数据库基准测试LDBC SNB的官方认证，并基于ARM架构打破了官方记录。  
**本次测试，验证了TuGraph对于ARM架构的兼容性，成为对x86和ARM架构均完整适配的图数据库；同时充分发挥出了新硬件的功能和性能优势，性能数据****较上一次官方纪录提升了31%，云端机器开销降低40%****。**  
评测流程和相关文件已同步发布在Github（https://github.com/TuGraph-family/tugraph-snb-interactive），开发者可参照来复现评测结果，**也可以通过阿里云轻松一键部署，以可视化方式试用TuGraph丰富的功能（****https://aliyun-computenest.github.io/quickstart-tugraph/****）。**该测试流程也适用于x86等其他软硬件环境。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：'}",空,空,空,空,空
我想问一下，字节流导入点边数据的API中，前两个参数`personDesc`和`person`的格式是否与执行导入脚本时的格式相同？,"page_content='Java客户端

2.使用示例

2.12.从字节流中导入点边数据

```java
boolean ret = client.importDataFromContent(personDesc, person, "","", true, 16, ""default"", 1000);
log.info(""importDataFromContent : "" + ret);
```
```
@param desc: data format description
@param data: the data to be imported
@param delimiter: data separator
@param continueOnError: whether to continue when importing data fails
@param threadNums: maximum number of threads
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='Python客户端

3.RPC Client

3.12.从字节流中导入点边数据

```python
ret, res = client.importDataFromContent(personDesc, person, "","", true, 16, ""default"", 1000)
```
```
importDataFromContent(self: liblgraph_client_python.client, desc: str, data: str, delimiter: str, continue_on_error: bool, thread_nums: int, graph: str, json_format: bool, timeout: float) -> (bool, str)
```
本接口支持在单机模式和HA模式下使用。其中，由于导入点边数据是写请求，HA模式下的client只能向leader发送导入点边数据请求。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.12.从字节流中导入点边数据'}",空,空,空,空,空,空,空,空
在OGM中，如何使用标签和属性来表示类的映射为一个边类型？,"page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

0 映射原理

TuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。  
以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员Alice在1990年和2019年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是Frank Darabont。  
以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示，将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。  
但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '0 映射原理'}","page_content='TuGraph-OGM

1.简介

> TuGraph-OGM 项目在其他仓库开源。  
TuGraph-OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。同时 TuGraph-OGM 兼容 Neo4j-OGM，Neo4j 生态用户可以无缝迁移到 TuGraph 数据库上。' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '1.简介'}","page_content='TuGraph-OGM

简介

TuGraph-OGM(Object Graph Mapping), 源自 `Neo4j-OGM` 项目，TuGraph-OGM
支持将JAVA对象（POJO）映射到TuGraph中，JAVA中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此JAVA开发人员可以在熟悉的生态中轻松地使用TuGraph数据库。同时TuGraph-OGM兼容Neo4j-OGM，Neo4j生态用户可以无缝迁移到TuGraph数据库上。' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '简介'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

###### c.数据映射  
文件上传成功后，需要在`数据导入`页面设置`数据对应表`，将数据文件中的数据列和目标点/边、对应属性建立映射关系。  
- 数据对应表：展示已经上传的数据问题。
- 文件名称：上传的数据文件名称。
- 文件大小：上传的数据文件大小。
- 读取结果：数据文件上传结果，success为读取成功。
- 删除：在页面中删除，不会删除本地文件。
- 数据文件映射：每个已上传的数据文件都需要配置映射关系。
- 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。
- 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。
- 属性映射：下拉选择数据列对应的属性字段。
- 数据预览：系统会预读数据文件的前5行。  
![数据导入-数据映射](../../../images/browser/graphbuild-import-datamapping.png)  
文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.1 构建图对象**

首先需要通过注解标明图中的实体。  
@NodeEntity：该注解标明的类为节点类。  
@Relationship：用于标明边，同时@Relationship中可指定label与边的指向。  
@Id：用于标明identity，是OGM中数据的唯一标识。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.1 构建图对象**'}",空,空,空,空,空
在对 DateTime 对象使用 operator+= 或 operator-= 运算时，如果发生溢出，那么通常会导致程序抛出异常或者返回一个特定的值，具体行为取决于实现的细节和编程语言。请您说明具体使用的编程语言或框架，以便提供更准确的答案。,"page_content='src/core/lgraph_date_time.cpp/ DateTime DateTime::operator-(int64_t n_microseconds) const {
    return DateTime(microseconds_since_epoch_ - n_microseconds);
}

DateTime& DateTime::operator-=(int64_t n_microseconds) {
    auto tmp = microseconds_since_epoch_ - n_microseconds;
    CheckDateTimeOverflow(tmp);
    microseconds_since_epoch_ = tmp;
    return *this;
}

bool DateTime::operator<(const DateTime& rhs) const noexcept {
    return microseconds_since_epoch_ < rhs.microseconds_since_epoch_;
}

bool DateTime::operator<=(const DateTime& rhs) const noexcept {
    return microseconds_since_epoch_ <= rhs.microseconds_since_epoch_;
}

bool DateTime::operator>(const DateTime& rhs) const noexcept {
    return microseconds_since_epoch_ > rhs.microseconds_since_epoch_;
}

bool DateTime::operator>=(const DateTime& rhs) const noexcept {
    return microseconds_since_epoch_ >= rhs.microseconds_since_epoch_;
}

bool DateTime::operator==(const DateTime& rhs) const noexcept {
    return microseconds_since_epoch_ == rhs.microseconds_since_epoch_;
}

bool DateTime::operator!=(const DateTime& rhs) const noexcept {
    return microseconds_since_epoch_ != rhs.microseconds_since_epoch_;
}

int64_t DateTime::MicroSecondsSinceEpoch() const noexcept { return microseconds_since_epoch_; }

int64_t DateTime::GetStorage() const noexcept { return microseconds_since_epoch_; }

DateTime::operator int64_t() const noexcept { return microseconds_since_epoch_; }' metadata={'file_name': 'lgraph_date_time.cpp', 'file_path': 'src/core/lgraph_date_time.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/lgraph_date_time.cpp'}",空,空,空,空,空,空,空,空,空
AlterEdgeLabelAddFields函数成功执行的条件是什么？,"page_content='src/lgraph_api/lgraph_db.cpp/ bool GraphDB::AddEdgeLabel(const std::string& label, const std::vector<FieldSpec>& fds,
                           const EdgeOptions& options) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AddLabel(false, label, fds, options);
}

bool GraphDB::DeleteEdgeLabel(const std::string& label, size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->DeleteLabel(false, label, n_modified);
}

bool GraphDB::AlterEdgeLabelDelFields(const std::string& label,
                                      const std::vector<std::string>& del_fields,
                                      size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelDelFields(label, del_fields, false, n_modified);
}

bool GraphDB::AlterEdgeLabelAddFields(const std::string& label,
                                      const std::vector<FieldSpec>& add_fields,
                                      const std::vector<FieldData>& default_values,
                                      size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelAddFields(label, add_fields, default_values, false, n_modified);
}

bool GraphDB::AlterEdgeLabelModFields(const std::string& label,
                                      const std::vector<FieldSpec>& mod_fields,
                                      size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelModFields(label, mod_fields, false, n_modified);
}' metadata={'file_name': 'lgraph_db.cpp', 'file_path': 'src/lgraph_api/lgraph_db.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_db.cpp'}","page_content='src/python/python_api.cpp/ ""AlterEdgeLabelAddFields"",
            [](GraphDB& db, const std::string& label, const std::vector<FieldSpec>& add_fields,
               const std::vector<FieldData>& default_values) {
                size_t n;
                if (db.AlterEdgeLabelAddFields(label, add_fields, default_values, &n)) return n;
                THROW_CODE(InputError, ""No such label."");
            },
            ""Add fields to an edge label\n""
            ""label: name of the label\n""
            ""add_fields: list of FieldSpec for the newly added fields\n""
            ""default_values: default values of the added fields"",
            pybind11::arg(""label""), pybind11::arg(""add_fields""), pybind11::arg(""default_values""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/cypher/procedure/procedure.cpp/ using namespace parser;
    CYPHER_DB_PROCEDURE_GRAPH_CHECK();
    CheckProcedureYieldItem(""db.alterLabelAddFields"", yield_items);
    /* close the previous txn first, in case of nested transaction */
    if (ctx->txn_) ctx->txn_->Abort();
    if (args.size() < 3)
        THROW_CODE(InputError, ""Too few arguments. This function takes 3 or more arguments."");
    bool is_vertex = ParseIsVertex(args[0].constant.scalar.AsString());
    std::string label = ParseStringArg(args[1], ""label_name"");
    // get field_spec_value
    std::vector<lgraph::FieldSpec> fields;
    std::vector<lgraph::FieldData> values;
    for (size_t i = 2; i < args.size(); i++) {
        CYPHER_ARG_CHECK(
            args[i].IsArray() && args[i].constant.array->size() == 4,
            ""Each FieldSpec must be a list of ('name', 'type', default_value, 'optional')"");
        const auto &list = *args[i].constant.array;
        CYPHER_ARG_CHECK(list[0].IsString() && list[1].IsString() && list[3].IsBool(),
                         ""Each FieldSpec must be a list of (name, type, default_value ,optional)"");
        const std::string &name = list[0].AsString();
        lgraph::FieldType ft;
        if (!lgraph::field_data_helper::TryGetFieldType(list[1].AsString(), ft))
            THROW_CODE(InputError, ""Illegal field type:{}"", list[1]);
        lgraph::FieldData default_value = list[2].scalar;
        fields.emplace_back(name, ft, list[3].AsBool());
        values.emplace_back(std::move(default_value));
    }
    /' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}","page_content='src/lgraph_api/lgraph_db.cpp/ bool GraphDB::AlterLabelModEdgeConstraints(
    const std::string& label, const std::vector<std::pair<std::string, std::string>>& constraints) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelModEdgeConstraints(label, constraints);
}

bool GraphDB::AlterVertexLabelDelFields(const std::string& label,
                                        const std::vector<std::string>& del_fields,
                                        size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelDelFields(label, del_fields, true, n_modified);
}

bool GraphDB::AlterVertexLabelAddFields(const std::string& label,
                                        const std::vector<FieldSpec>& add_fields,
                                        const std::vector<FieldData>& default_values,
                                        size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelAddFields(label, add_fields, default_values, true, n_modified);
}

bool GraphDB::AlterVertexLabelModFields(const std::string& label,
                                        const std::vector<FieldSpec>& mod_fields,
                                        size_t* n_modified) {
    THROW_IF_INVALID();
    THROW_IF_RO();
    return db_->AlterLabelModFields(label, mod_fields, true, n_modified);
}' metadata={'file_name': 'lgraph_db.cpp', 'file_path': 'src/lgraph_api/lgraph_db.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_db.cpp'}",空,空,空,空,空,空
带权图的边权重可以是哪种类型的数值？,空,空,空,空,空,空,空,空,空,空
RPC 是一种什么样的通信协议，它是如何工作的？,"page_content='RPC API

1.简介

TuGraph 提供丰富的 RPC API，以供开发者通过 RPC 请求远程调用 TuGraph 提供的服务。  
RPC（远程过程调用）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
相比REST，RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景，且性能更高。
brpc是用c++语言编写的工业级RPC框架，基于brpc，TuGraph 提供了丰富的RPC API，本文档描述
TuGraph 的 RPC API 使用方式。' metadata={'Header 1': 'RPC API', 'Header 2': '1.简介'}",空,空,空,空,空,空,空,空,空
TuGraph中主键的作用是什么？,"page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='功能概览

2.存储层

在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。  
在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。  
存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。' metadata={'Header 1': '功能概览', 'Header 2': '2.存储层'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.3 通过OGM进行增操作**

OGM支持对TuGraph的实体执行CRUD 操作，同时支持发送任意TuGraph支持的Cypher语句，包括通过CALL调用存储过程。  
**CREATE**  
在完成图对象的构建后，即可通过类的实例化创建节点，当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边，最后使用session.save方法将数据存入数据库。  
注意：TuGraph数据库为强schema类型数据库，在创建实体前需要该数据的label已经存在，且新建过程中需要提供唯一的主键。  
```
Movie jokes = new Movie（""Jokes""，1990）； // 新建Movie节点jokes session.save(jokes); // 将jokes存储在TuGraph中

Movie speed = new Movie(""Speed"", 2019);

Actor alice = new Actor(""Alice Neeves"");

alice.actsIn(speed);

session.save(speed);' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.3 通过OGM进行增操作**'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。  
###### 1.3.1.1.2 non_unique索引  
点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的点的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}",空,空,空,空,空
RpcException是什么类型的异常，具体包含哪些信息和使用场景是什么？,"page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ std::shared_ptr<lgraph::RpcClient::RpcSingleClient>
    RpcClient::GetClient(lgraph::GraphQueryType type, const std::string &cypher,
                         const std::string &graph) {
    return GetClient(IsReadQuery(type, cypher, graph));
}

std::shared_ptr<lgraph::RpcClient::RpcSingleClient> RpcClient::GetClient(bool isReadQuery) {
    if (isReadQuery) {
        LoadBalanceClientPool();
        if (client_pool.empty())
            throw RpcException(""all instance is down, refuse req!"");
        return *client_pool.rbegin();
    } else {
        if (leader_client == nullptr)
            throw RpcException(""master instance is down, refuse req!"");
        return leader_client;
    }
}

std::shared_ptr<lgraph::RpcClient::RpcSingleClient> RpcClient::GetClientByNode(
    const std::string &url) {
    for (auto &c : client_pool) {
        if (c->GetUrl() == url)
            return c;
    }
    throw RpcException(""do not exit "" + url +"" client"");
}

void RpcClient::RefreshConnection() {
    try {
        RefreshClientPool();
        RefreshUserDefinedProcedure();
        RefreshBuiltInProcedure();
    } catch (std::exception &e) {
        LOG_ERROR() << ""[RpcClient] RpcClient Connection Exception, ""
                                   ""please connect again!"";
    }
}

void RpcClient::LoadBalanceClientPool() {
    if (!client_pool.empty()) {
        client_pool.push_back(client_pool.front());
        client_pool.pop_front();
    }
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/client/cpp/rpc/rpc_exception.h/ ﻿/**
 * Copyright 2022 AntGroup CO., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */

#pragma once

#include <exception>
#include <string>

#include ""core/data_type.h""

namespace lgraph {
class RpcException : public std::exception {
    std::string err_;

 public:
    explicit RpcException(const std::string& err) : err_(""rpc exception: "" + err) {}

    const char* what() const noexcept override { return err_.c_str(); }
};

class RpcStatusException : public RpcException {
 public:
    explicit RpcStatusException(const std::string& code)
        : RpcException(""Server returned error: "" + code) {}
};

class RpcConnectionException : public RpcException {
 public:
    explicit RpcConnectionException(const std::string& msg)
        : RpcException(""Connection failed: "" + msg) {}
};
}  // namespace lgraph
' metadata={'file_name': 'rpc_exception.h', 'file_path': 'src/client/cpp/rpc/rpc_exception.h', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/rpc_exception.h'}",空,空,空,空,空,空,空,空
在TuGraph中，match语句是否支持同时设置多个属性？,"page_content='TuGraph console client

`lgraph_cli`使用

TuGraph>
```  
语句可以中间换行，多行输入。  
```powershell
TuGraph> match(n)
-> return n
-> limit 1;
+-------------------------------------------------------------------------------------------------------------------------------------+
| n                                                                                                                                   |' metadata={'Header 1': 'TuGraph console client', 'Header 2': '`lgraph_cli`使用'}","page_content='src/cypher/execution_plan/pattern_graph_maker.cpp/ std::any PatternGraphMaker::visit(geax::frontend::CompositeQueryStatement* node) {
    auto head = node->head();
    ACCEPT_AND_CHECK_WITH_ERROR_MSG(head);
    for (auto statement : node->body()) {
        cur_pattern_graph_ += 1;
        ACCEPT_AND_CHECK_WITH_ERROR_MSG(std::get<1>(statement));
    }
    return geax::frontend::GEAXErrorCode::GEAX_SUCCEED;
}

std::any PatternGraphMaker::visit(geax::frontend::AmbientLinearQueryStatement* node) {
    auto& query_stmts = node->queryStatements();
    int match_count = 0;
    for (auto &stat : query_stmts) {
        if (stat->type() == geax::frontend::AstNodeType::kMatchStatement) {
            match_count++;
        }
    }
    if (match_count > 1) {
        THROW_CODE(CypherException, ""Not support more than one (optional) match clause."");
    }
    for (auto query_stmt : query_stmts) {
        ACCEPT_AND_CHECK_WITH_ERROR_MSG(query_stmt);
    }
    auto projection = node->resultStatement();
    ACCEPT_AND_CHECK_WITH_ERROR_MSG(projection);
    return geax::frontend::GEAXErrorCode::GEAX_SUCCEED;
}

std::any PatternGraphMaker::visit(geax::frontend::SelectStatement* node) { NOT_SUPPORT(); }

std::any PatternGraphMaker::visit(geax::frontend::FocusedQueryStatement* node) { NOT_SUPPORT(); }

std::any PatternGraphMaker::visit(geax::frontend::FocusedResultStatement* node) { NOT_SUPPORT(); }' metadata={'file_name': 'pattern_graph_maker.cpp', 'file_path': 'src/cypher/execution_plan/pattern_graph_maker.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/pattern_graph_maker.cpp'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）
2. 唯一组合索引的属性长度之和不能超过480-2*(属性个数-1)字节，非唯一组合索引的属性长度之和不能超过475-2*(属性个数-1)字节  
##### 1.3.2.1 唯一索引  
和点的普通唯一索引类似，点的组合唯一索引指的是全局唯一的索引，即若一组属性设置了unique索引，
在同一个图中，相同label的点的该组属性不会存在相同的值。
由于底层存储设计，组合索引key需要保存属性的长度，因此，' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

2. 图项目、点、边、属性命名规则和建议

2.2 使用限制

|**描述**|**最大个数**|
|-------- |--------- |
|用户数、角色数|65536|
|图项目的个数|4096|
|每个图项目的点和边类型数量之和|4096|
|每个点或边类型的属性数量|1024|  
注：
1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；  
示例： ```match (`match`:match) return `match`.id limit 1```  
2、大小写敏感性：TuGraph大小写敏感；  
3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；  
4、属性名字保留关键字：SRC_ID / DST_ID / SKIP' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '2. 图项目、点、边、属性命名规则和建议', 'Header 3': '2.2 使用限制'}",空,空,空,空,空
TuGraph DB在Antlr4方面改进了哪些性能？,"page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

贡献和成果

对Antlr4的优化的效果十分显著，32 线程的并发性能提升超过 18 倍 。考虑到实际生产服务器性能远高于测试机型，实际的性能提升效果将比测试结果更高， 优化后 GQL 解析能力已能完全满足企业业务的需要。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '贡献和成果'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

当 TuGraph 遇见 Antlr4

ISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4 作为一种强大的解析器生成器，成为了蚂蚁图数据库 TuGraph 生成 GQL 解释器的理想选择。Antlr4 能够帮助团队更快、更准确地构建图数据库的查询语言，从而提高产品性能和用户体验。  
然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target 的并发性能不足以支持所需的超高并发 GQL 请求。经过调研并与 Antlr 开源社区讨论，我们发现\*\*并发性能这个问题普遍存在，并且在过去 5 年中持续困扰着 C++生态的开发者。\*\*我们决定解决这个问题。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '当 TuGraph 遇见 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。  
关于程序正确性的保证，我们通过双重验证来保证。首先在设计之初我们已经从源代码角度，推断出共享数据仍然是安全的，其次我们也设计了实验对此进行了验证，验证结果与我们的分析一致' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

关于 Antlr4

Antlr4 是一款备受欢迎的开源解析器生成器，能够根据语法规则快速生成自定义解析器。其支持 LL(\*)解析，拥有更强大的错误处理能力和更快的解析速度。不仅如此，Antlr4 还支持 Java、Python、C++、JavaScript、Go 等 10 种目标语言，广泛应用于多种开发语言生态中。简单易用的 API 和文档使得开发人员能够快速上手。无论是编程语言、数据格式、编译器还是解释器等领域，Antlr4 都发挥着重要作用。  
著名的开源项目如 Apache Spark、Eclipse IDE 和 MongoDB 等都选择了 Antlr4。 对于语言工具开发者而言，Antlr4 是不可或缺的工具，能大幅提高开发效率和代码质量。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '关于 Antlr4'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

TuGraph做了哪些工作

进一步地，我们通过分析程序中的并发访问情况，找到了可能引发数据竞争的所有代码段和共享变量（主要为 DFA、ATN 等结构），拼接出了数据竞争的完整链路。  
（4）破解数据竞争问题  
数据竞争问题是多线程程序中常见而又复杂的问题，可以考虑通过破解多种竞争条件来解决。就本文问题来说，也存在多种破解方案选择，如何制定最优的解决方案是一项极具挑战的工作，主要难点有两个：  
（i）保证修改后程序的正确性/稳定性  
（ii）保证方案的有效性（低成本）  
反复推演后，我们选择了提交给社区的优化方案，即通过改变关键数据的 ownership 接触对锁的依赖。针对上述两个难点的分析如下：  
经过源码分析并与开源社区讨论，我们确认关键数据结构的初始化构建是非常耗时的，但可以通过“只调用一次”（`call_once`）手段将成本均摊，而后续的增量构建相对开销较低，并且也可均摊。因此该优化方案的低时间成本是可以保证的。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': 'TuGraph做了哪些工作'}",空,空,空,空,空
TuGraph和OpenCypher在处理节点和关系的标签数量上有什么不同？,"page_content='Cypher API

4.附录1. 语法扩充及不同

TuGraph查询语言与OpenCypher的不同点如下：  
- Label数量
- TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.
- OpenCypher: One node/relationship may have 0 to many labels.
- Schema.
- TuGraph: TuGraph has strong schema
- OpenCypher: schema-less' metadata={'Header 1': 'Cypher API', 'Header 2': '4.附录1. 语法扩充及不同'}","page_content='Cypher API

3.Functions

3.6.Mathematical functions

TuGraph 查询语言与 OpenCypher 的不同点如下：  
- Label 数量
- TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.
- OpenCypher: One node/relationship may have 0 to many labels.
- Schema.
- TuGraph: TuGraph has strong schema
- OpenCypher: schema-less' metadata={'Header 1': 'Cypher API', 'Header 2': '3.Functions', 'Header 3': '3.6.Mathematical functions'}","page_content='Cypher API

3.Functions

3.6.Mathematical functions

**Scope:** whole instance.
**Example input:**  
```
RETURN sign(-17), sign(0.1)
```  
**Example output:**  
| sign(-17) | sign(0.1) |
| --------- | --------- |
| -1        | 1         |  
TuGraph 查询语言与 OpenCypher 的不同点如下：  
- Label 数量
- TuGraph: Each node/relationship must have one and only one label. So error occurs when there is no label, and the 1st label will be picked as the label if there are more than one label.' metadata={'Header 1': 'Cypher API', 'Header 2': '3.Functions', 'Header 3': '3.6.Mathematical functions'}","page_content='src/cypher/README.adoc/ = Lcypher: Cypher for TuGraph

== openCypher
The Cypher Query Language Reference, Grammar specification, etc. we use are derived from openCypher. To learn more, please visit:

* http://www.opencypher.org[openCypher official]
* https://github.com/opencypher/openCypher.git[openCypher github]

The version we use is openCypher v1.0.0-M09 (now May 2018).

== Grammer
=== Difference between Lcypher & Cypher
* Label Number.
+
Lcypher: Each node/relationship must has one and only one label. So error occurs when there is no label, and
the 1st label will be picked as the label if there are more than one labels. +
Cypher: One node/relationship may have 0 to many labels.
* Label in NodePattern.
+
Lcypher: Label is necessary in NodePattern. e.g.
+
[source, cypher]
----
  MATCH (tom:Person {name: ""Tom Hanks""}) RETURN tom
----
+
Cypher: Label(s) are not necessary. e.g.
+
[source, cypher]
----
  MATCH (tom {name: ""Tom Hanks""}) RETURN tom
----
* Schema.
+
Lcypher: TuGraph has strong schema (for now, May 2018) +
Cypher: Neo4j is schema-less

=== Difference between Lcypher.g4 & https://s3.amazonaws.com/artifacts.opencypher.org/Cypher.g4[Cypher.g4]
* Rename lexer rule 'NULL' to 'NULL_'.
+
While it's ok when generating Java target, the C++ target goes wrong
with 'NULL' (for NULL is a keyword of C/C++)
* Hints
+
Lcypher extends oC_Hint to OpenCypher.
* [Note] ""call"" in ""match""
+
The following queries will cause parse exception while they *should not*:
+
[source, cypher]
----
MATCH (v:call) RETURN v
MATCH (v1)-[:call]->(v2) RETURN v2
----
+
`adaptivePredict` in `LcypherParser::oC_SingleQuery` throws exception.

== Implementation
=== Difference between TuGraph & Neo4j
* Contain Self.
+
TuGraph: In the following example, results contain _tom_ itself.
+
[source, cypher]
----
MATCH (tom:Person {name:""Tom Hanks""})-[:ACTED_IN]->(m)<-[:ACTED_IN]-(coActors) RETURN coActors.name
----
+
Neo4j: Not so.
* Return Object.
+
When answering return objects(like 'RETURN tom'), Neo4j returns the whole data of the object, while TuGr' metadata={'file_name': 'README.adoc', 'file_path': 'src/cypher/README.adoc', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/README.adoc'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}",空,空,空,空,空
函数DeleteVertexIndex成功执行时返回什么值？,"page_content='src/client/cpp/restful/rest_client.cpp/ void RestClient::DeleteIndex(const std::string& db, const std::string& label,
                             const std::string& field) {
    DoGraphDelete(db, FMA_FMT(""/index/{}/{}"", label, field), false);
    LOG_DEBUG() << ""[RestClient] DeleteVertexIndex ("" << label << "":"" << field
                            << "") succeeded"";
}

std::vector<int64_t> RestClient::GetVidsByIndex(const std::string& db, const std::string& label,
                                                const std::string& field,
                                                const std::string& value) {
    // index/{label}/?key={field}&value={value}
    auto response =
        DoGraphGet(db, FMA_FMT(""/index/{}/?field={}&value={}"", label, field, value), true);
    auto resp = response.as_array();
    std::vector<int64_t> vids;
    int64_t vid = -1;
    for (auto& v : resp) {
        JsonToType(v, vid);
        vids.push_back(vid);
    }
    LOG_DEBUG() << ""[RestClient] GetVidsByIndex ("" << label << "","" << field << "",""
                            << value << "") succeeded"";
    return vids;
}' metadata={'file_name': 'rest_client.cpp', 'file_path': 'src/client/cpp/restful/rest_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/restful/rest_client.cpp'}","page_content='src/core/vertex_index.cpp/ bool VertexIndex::Delete(KvTransaction& txn, const Value& k, int64_t vid) {
    Value key = type_ == IndexType::GlobalUniqueIndex ? k : CutKeyIfLongOnlyForNonUniqueIndex(k);
    VertexIndexIterator it = GetUnmanagedIterator(txn, key, key, vid);
    if (!it.IsValid() || it.KeyOutOfRange()) {
        // no such key_vid
        return false;
    }
    switch (type_) {
    case IndexType::GlobalUniqueIndex:
        {
            it.it_->DeleteKey();
            return true;
        }
    case IndexType::NonuniqueIndex:
        {
            uint8_t ret = it.iv_.DeleteVidIfExist(vid);
            if (ret == 1) {
                // the key does not change after deletion
                it.it_->SetValue(it.iv_.GetBuf());
            } else if (ret == 2) {
                // the key changes after deletion
                it.it_->DeleteKey();
                if (it.iv_.GetVidCount()) {
                    bool r = it.it_->AddKeyValue(it.iv_.CreateKey(key), it.iv_.GetBuf());
                    FMA_DBG_ASSERT(r);
                }
            } else {
                // no such vid
                return false;
            }
            return true;
        }
    case IndexType::PairUniqueIndex:
        {
            THROW_CODE(InputError, ""vertex index do not support pair-unique attributes"");
        }
    }
    return false;
}' metadata={'file_name': 'vertex_index.cpp', 'file_path': 'src/core/vertex_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/vertex_index.cpp'}","page_content='src/core/schema.cpp/ {

void Schema::DeleteEdgeFullTextIndex(EdgeUid euid, std::vector<FTIndexEntry>& buffers) {
    if (fulltext_fields_.empty()) {
        return;
    }
    FTIndexEntry entry;
    entry.type = FTIndexEntryType::DELETE_EDGE;
    entry.vid1 = euid.src;
    entry.vid2 = euid.dst;
    entry.lid = euid.lid;
    entry.eid = euid.eid;
    buffers.emplace_back(std::move(entry));
}

void Schema::DeleteVertexFullTextIndex(VertexId vid, std::vector<FTIndexEntry>& buffers) {
    if (fulltext_fields_.empty()) {
        return;
    }
    FTIndexEntry entry;
    entry.type = FTIndexEntryType::DELETE_VERTEX;
    entry.vid1 = vid;
    buffers.emplace_back(std::move(entry));
}

void Schema::DeleteVertexIndex(KvTransaction& txn, VertexId vid, const Value& record) {
    for (auto& idx : indexed_fields_) {
        auto& fe = fields_[idx];
        if (fe.GetIsNull(record)) continue;
        if (fe.Type() != FieldType::FLOAT_VECTOR) {
            VertexIndex* index = fe.GetVertexIndex();
            FMA_ASSERT(index);
            // update field index
            if (!index->Delete(txn, fe.GetConstRef(record), vid)) {
                THROW_CODE(InputError, ""Failed to un-index vertex [{}] with field ""
                                                    ""value [{}:{}]: index value does not exist."",
                                                    vid, fe.Name(), fe.FieldToString(record));
            }
        }
    }
}' metadata={'file_name': 'schema.cpp', 'file_path': 'src/core/schema.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/schema.cpp'}","page_content='src/core/index_manager.cpp/ bool IndexManager::DeleteVertexIndex(KvTransaction& txn, const std::string& label,
                                     const std::string& field) {
    std::string table_name = GetVertexIndexTableName(label, field);
    // delete the entry from index list table
    if (!index_list_table_->DeleteKey(txn, Value::ConstRef(table_name)))
        return false;  // does not exist
                       // now delete the index table
    bool r = db_->GetStore().DeleteTable(txn, table_name);
    FMA_DBG_ASSERT(r);
    return true;
}

bool IndexManager::DeleteEdgeIndex(KvTransaction& txn, const std::string& label,
                                   const std::string& field) {
    std::string table_name = GetEdgeIndexTableName(label, field);
    // delete the entry from index list table
    if (!index_list_table_->DeleteKey(txn, Value::ConstRef(table_name)))
        return false;  // does not exist
    // now delete the index table
    bool r = db_->GetStore().DeleteTable(txn, table_name);
    FMA_DBG_ASSERT(r);
    return true;
}' metadata={'file_name': 'index_manager.cpp', 'file_path': 'src/core/index_manager.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/index_manager.cpp'}","page_content='src/core/vertex_index.cpp/ uint8_t VertexIndexValue::InsertVid(int64_t vid) {
    bool exists;
    int pos = SearchVid(vid, exists);
    if (exists) {
        return 0;
    }
    bool tail = (pos == GetVidCount());
    InsertVidAtNthPos(pos, vid);
    return !tail ? 1 : 2;
}

void VertexIndexValue::InsertVidAtNthPos(int pos, int64_t vid) {
    // insert the vid
    size_t bytes_after_p = v_.Size() - (1 + _detail::VID_SIZE * pos);
    v_.Resize(v_.Size() + _detail::VID_SIZE);
    char* ptr = v_.Data() + 1 + _detail::VID_SIZE * pos;
    memmove(ptr + _detail::VID_SIZE, ptr, bytes_after_p);
    _detail::WriteVid(ptr, vid);
    (*(uint8_t*)v_.Data())++;
}

uint8_t VertexIndexValue::DeleteVidIfExist(int64_t vid) {
    bool exists;
    int pos = SearchVid(vid, exists);
    if (!exists) {
        return 0;
    }
    bool tail = (pos == GetVidCount() - 1);
    DeleteNthVid(pos);
    return !tail ? 1 : 2;
}

void VertexIndexValue::DeleteNthVid(int pos) {
    v_.Resize(v_.Size());
    char* ptr = v_.Data() + 1 + _detail::VID_SIZE * pos;
    uint8_t n = GetVidCount();
    memmove(ptr, ptr + _detail::VID_SIZE, (n - pos - 1) * _detail::VID_SIZE);
    v_.Resize(v_.Size() - _detail::VID_SIZE);
    *(uint8_t*)v_.Data() = n - 1;
}' metadata={'file_name': 'vertex_index.cpp', 'file_path': 'src/core/vertex_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/vertex_index.cpp'}",空,空,空,空,空
TuGraph-Analytics 目前是否支持窗口函数？,"page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

1. 启动 GeaFlow 流图作业和 Socket 服务

参考 [快速开始](https://github.com/TuGraph-family/tugraph-analytics/blob/master/docs/docs-cn/quick_start.md)  
⚠️ 注意在 `启动SocketServer` 步骤使用下列命令代替  
```bash
bin/socket.sh 9003 GI
```  
输出下列内容时，即表示 Tugraph Analytics 准备好建立连接  
<img width=""610"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/a25ed6ba-4fb9-4db1-9325-ee2f26a4337f"">  
> 如启动服务过程中遇到问题，可见 https://github.com/TuGraph-family/tugraph-analytics/issues/1' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '1. 启动 GeaFlow 流图作业和 Socket 服务'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

4. 演示

<img width=""332"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/7ca76607-41a1-4afe-9427-cf7599de6889"">  
同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。  
<img width=""611"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/d8d0d73a-4c07-4ecd-bcac-4633a742933a"">' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '4. 演示'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

5. 结果展示

Tugraph Analytics 完成环路检测计算任务后，会自动返回检测结果。  
<img width=""324"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/ba343acf-812a-4df5-8da4-ff70e0b2531d"">  
右侧画布中会动态显示出本次环路检测结果信息：  
![Jun-12-2023 19-53-35](https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/f8595322-d477-4702-a52e-4f03092b7219)' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '5. 结果展示'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

4. 演示

环路检测 Demo 提供了两种方式来进行交互：  
* 方式一 在输入框中输入点边信息
* 方式二 使用内置数据进行演示  
> 两种方式本质都是调用 Tugraph Analytics 进行实时计算，不过方式二省略了手动输入过程。  
这里我们使用内置数据进行快速演示，点击【选项】，选择`添加点`，画布中出现了 7 个点信息；接着选择`添加边`。我们可以在上方对话框中看到添加记录。  
<img width=""332"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/7ca76607-41a1-4afe-9427-cf7599de6889"">  
同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '4. 演示'}","page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}",空,空,空,空,空
当调用CallProcedure函数时，如果设置json_format参数为false，返回的结果格式是什么？,"page_content='C++客户端

2.使用示例

2.6.调用存储过程

binary format.
@param [in]  url                 (Optional) Node address of calling procedure.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。
其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}","page_content='C++客户端

2.使用示例

2.6.调用存储过程

interrupted.
@param [in]  in_process          (Optional) support in future.
@param [in]  graph               (Optional) the graph to query.
@param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,
binary format.
@param [in]  url                 (Optional) Node address of calling procedure.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}","page_content='Java客户端

2.使用示例

2.7.向leader调用存储过程

@param jsonFormat: (Optional) Return format of calling stored procedure
@return: the result of procedure execution
public String callProcedureToLeader(String procedureType, String procedureName, String param, double procedureTimeOut,
boolean inProcess, String graph)
```
本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.7.向leader调用存储过程'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ bool RpcClient::CallProcedure(std::string &result, const std::string &procedure_type,
                             const std::string &procedure_name, const std::string &param,
                             double procedure_time_out, bool in_process, const std::string &graph,
                             bool json_format, const std::string& url) {
    if (client_type == SINGLE_CONNECTION) {
        return base_client->CallProcedure(result, procedure_type, procedure_name, param,
                                          procedure_time_out, in_process, graph, json_format);
    }
    bool is_read_procedure = false;
    for (auto &op : user_defined_procedures) {
        if (op[""plugins""][""name""] == procedure_name) {
            is_read_procedure = op[""plugins""][""read_only""]; break;
        }
    }
    auto fun = [&]{
        if (!url.empty())
            return GetClientByNode(url)->
                CallProcedure(result, procedure_type, procedure_name, param,
                              procedure_time_out, in_process, graph, json_format);
        return GetClient(is_read_procedure)
            ->CallProcedure(result, procedure_type, procedure_name, param,
                            procedure_time_out, in_process, graph, json_format);
    };
    return DoubleCheckQuery(fun);
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='Java客户端

2.使用示例

2.6.调用存储过程

@param inProcess: Running query or not
@param graph: the graph to query
@param jsonFormat: (Optional) Return format of calling stored procedure
@param url: (Optional) Node address of calling procedure
@return: the result of procedure execution
public String callProcedure(String procedureType, String procedureName, String param, double procedureTimeOut,
boolean inProcess, String graph, String url)
```
本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}",空,空,空,空,空
在 PathTraversal 类中，通过调用哪个函数来设置初始边界并传入过滤器？,"page_content='src/lgraph_api/lgraph_traversal.cpp/ void PathTraversal::SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter) {' metadata={'file_name': 'lgraph_traversal.cpp', 'file_path': 'src/lgraph_api/lgraph_traversal.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_traversal.cpp'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter = nullptr
);
```  
PathTraversal 的三种遍历方式与 FrontierTraversal 类似，只是用户自定义的过滤函数中增加了两个参数，其中：Path 包含了到新扩展的这条边之前的路径，IteratorHelper 可用于将路径中的点/边转为数据库中对应的迭代器，相关文档可参考对应的 C++ API 文档。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='src/lgraph_api/lgraph_traversal.cpp/ void PathTraversal::ExpandInEdges(
    std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter,
    std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter) {' metadata={'file_name': 'lgraph_traversal.cpp', 'file_path': 'src/lgraph_api/lgraph_traversal.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_traversal.cpp'}","page_content='src/lgraph_api/lgraph_traversal.cpp/ void FrontierTraversal::SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter) {' metadata={'file_name': 'lgraph_traversal.cpp', 'file_path': 'src/lgraph_api/lgraph_traversal.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_traversal.cpp'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

```c
void SetFrontier(size_t root_vid);
void SetFrontier(ParallelVector<size_t> & root_vids);
void SetFrontier(std::function<bool(VertexIterator &)> root_vertex_filter);
```  
两类 Traversal 设置遍历的起始点/点集有上述三种方式，前两种通过点 ID 直接指定，最后一种方式则类似于 FindVertices。  
两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}",空,空,空,空,空
GeaBase的主要部署方式需要多长时间？,空,空,空,空,空,空,空,空,空,空
图论中，图的基本元素包括哪些？,空,空,空,空,空,空,空,空,空,空
TuGraph支持哪些编程语言？,"page_content='Procedure API

3.存储过程语言支持

在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。  
注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。' metadata={'Header 1': 'Procedure API', 'Header 2': '3.存储过程语言支持'}","page_content='RPC API

5.存储过程

为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。
用户可以使用RPC请求对存储过程进行增删改查操作。' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程'}","page_content='功能概览

4.核心功能

4.2.存储过程

当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个
处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。  
从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。  
TuGraph 支持 POG (Procedres on Graph Query Languages) 编程和 POG 库，其中“Graph Query Languages”包含 Cypher 以及
制定中的 ISO GQL 等图查询语言。POG 库提供在查询语言中对用户定义的存储过程的访问，打破了查询语言和存储过程之间的界限，扩展了查询
语言的使用范围。  
> 这个文档描述了 [新的 Procedure 编程范式以及 POG](../9.olap&procedure/1.procedure/1.procedure.md)。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.2.存储过程'}","page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}","page_content='功能概览

5.客户端工具

客户端主要分为各种编程语言的SDK，OGM以及命令行工具。  
客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。  
OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。' metadata={'Header 1': '功能概览', 'Header 2': '5.客户端工具'}",空,空,空,空,空
在这段代码中，如何获取存储过程响应的列表？,"page_content='RESTful API Legacy

5.存储过程

5.2.列出所有存储过程

- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`
- **METHOD**: GET
- **RESPONSE**: 存储过程列表，其中每个元素是一个 plugin 的描述，其格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | 存储过程名 | 字符串 |
| description | 存储过程描述 | 字符串 |
| read_only | 存储过程是否只读 | 布尔值 |  
**Example request.**  
```
• GET http://localhost:7070/db/graph1/cpp_plugin
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
Output:
{
[
{
""description"":""adds a vertex label to the db"",' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '5.存储过程', 'Header 3': '5.2.列出所有存储过程'}","page_content='Procedure API

4.2.如何使用存储过程

4.2.2.列出已加载的存储过程

在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')
>>> r.status_code
200
>>> r.text
'{""plugins"":[{""description"":""Custom Page Rank Procedure"", ""name"":""age_10"", ""read_only"":true}]}'
```' metadata={'Header 1': 'Procedure API', 'Header 2': '4.2.如何使用存储过程', 'Header 3': '4.2.2.列出已加载的存储过程'}","page_content='Procedure API

5.Procedure v2接口

5.2.加载存储过程

#### 5.2.1.列出已加载的存储过程  
在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')
>>> r.status_code
200
>>> r.text
'{""plugins"":[{""description"":""Custom Page Rank Procedure"", ""name"":""custom_pagerank"", ""read_only"":true}]}'
```  
#### 5.2.2.获取存储过程详情  
在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')
>>> r.status_code
200
>>> r.text' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.2.加载存储过程'}","page_content='RESTful API Legacy

5.存储过程

5.3.获取存储过程的详细信息

- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin/{plugin_name}`
- **METHOD**: GET
- **RESPONSE**: 存储过程信息，包括代码，其格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | 存储过程名 | 字符串 |
| description | 存储过程描述 | 字符串 |
| read_only | 存储过程是否只读 | 布尔值 |
| code_base64 | 存储过程的代码 | 字符串，使用 base64 编码 |
| code_type | 上传代码的类型，C++类型可选 zip/so/cpp，Python 为 py | 字符串 |  
**Example request.**  
```
• GET http://localhost:7070/db/graph1/cpp_plugin/echo
• Accept: application/json; charset=UTF-8
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '5.存储过程', 'Header 3': '5.3.获取存储过程的详细信息'}","page_content='Procedure API

4.2.如何使用存储过程

4.2.3.获取存储过程详情

在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/age_10')
>>> r.status_code
200
>>> r.text
'{""description"":""Custom Page Rank Procedure"", ""name"":""age_10"", ""read_only"":true, ""code_base64"":<CODE>, ""code_type"":""so""}'
```' metadata={'Header 1': 'Procedure API', 'Header 2': '4.2.如何使用存储过程', 'Header 3': '4.2.3.获取存储过程详情'}",空,空,空,空,空
什么是RPC接口？,"page_content='RPC API

1.简介

TuGraph 提供丰富的 RPC API，以供开发者通过 RPC 请求远程调用 TuGraph 提供的服务。  
RPC（远程过程调用）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
相比REST，RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景，且性能更高。
brpc是用c++语言编写的工业级RPC框架，基于brpc，TuGraph 提供了丰富的RPC API，本文档描述
TuGraph 的 RPC API 使用方式。' metadata={'Header 1': 'RPC API', 'Header 2': '1.简介'}","page_content='Python客户端

3.RPC Client

Python的TuGraph Rpc Client是使用pybind11包装的CPP Client SDK，下表列出了Python和CPP Client SDK的对应关系。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| rpc_port                     | 整型                    | RPC 及 HA 服务所用端口。默认端口为 9090。                                                                                                                                                       |
| bolt_port                    | 整型                    | Bolt 客户端端口。默认端口为 7687。                                                                                                                                                            |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='RPC API

2.请求

2.2.请求类型

服务处理完RPC请求之后发回响应，响应消息中除了包含每个请求的单独响应信息之外，还包含以下参数：
- error_code: 必要参数，标志请求处理状态
- redirect: 可选参数，HA模式下向follower发送写请求时处理失败，设置redirect为请求转发地址，即leader地址
- error: 可选参数，请求错误信息
- server_version: 可选参数，HA模式的请求响应中设置`server_version`以避免client读取数据时发生反向时间旅行问题  
:warning:  **除CypherRequest、PluginRequest、HARequest和AclRequest外，其余RPC接口将逐步废弃，其功能统一至CypherRequest接口。**' metadata={'Header 1': 'RPC API', 'Header 2': '2.请求', 'Header 3': '2.2.请求类型'}","page_content='C++客户端

1.概述

C++ Client 能够使用 RPC 连接lgraph_server，进行数据导入、执行存储过程、调用Cypher等操作。' metadata={'Header 1': 'C++客户端', 'Header 2': '1.概述'}",空,空,空,空,空
在《黑客帝国》这部电影中，The Matrix参与了哪几种类型的关系？,"page_content='Cypher API

2.Clauses

2.2.MATCH

```
MATCH (matrix:movie {title: 'The Matrix'})<-[:acted_in]-(actor)
RETURN actor.name
```  
- ✓ Match on multiple relationship types  
```
MATCH (matrix {title: 'The Matrix'})<-[:acted_in|:directed]-(person)
RETURN person.name
```  
- ✓ Match on relationship type and use a variable  
```
MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)
RETURN r.role
```
- Relationships in depth  
- ❏ Relationship types with uncommon characters  
```' metadata={'Header 1': 'Cypher API', 'Header 2': '2.Clauses', 'Header 3': '2.2.MATCH'}","page_content='Cypher API

2.Clauses

2.2.MATCH

RETURN person.name
```  
- ✓ Match on relationship type and use a variable  
```
MATCH (matrix {title: 'The Matrix'})<-[r:acted_in]-(actor)
RETURN r.role
```
- Relationships in depth  
- ❏ Relationship types with uncommon characters  
```
MATCH (n {name: 'Rob Reiner'})-[r:`TYPE WITH SPACE`]->()
RETURN type(r)
```  
- ✓ Multiple relationships  
```
MATCH (laurence {name: 'Laurence Fishburne'})-[:acted_in]->(movie)<-[:directed]-(director)
RETURN movie.title, director.name' metadata={'Header 1': 'Cypher API', 'Header 2': '2.Clauses', 'Header 3': '2.2.MATCH'}",空,空,空,空,空,空,空,空
如何使用什么命令启动 TuGraph 服务器？,"page_content='数据库运行

3.服务操作

3.1.启动服务

TuGraph 需要通过 `lgraph_server -d start` 命令行启动，启动命令示例如下：  
```bash
$ ./lgraph_server -d start -c lgraph.json
Starting lgraph...
The service process is started at pid 12109.
```  
此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.1.启动服务'}","page_content='数据库运行

2.运行模式

2.2.运行进程守护模式

启动命令：  
```shell
$ ./lgraph_server -d start -c lgraph.json
```  
守护模式的运行输出示例：  
```shell
Starting lgraph...
The service process is started at pid 12109.
```  
此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.2.运行进程守护模式'}","page_content='部署高可用模式

3.启动初始备份组

3.1.初始数据一致

当启动时所有服务器中的数据相同或没有数据时，用户可以通过指定`--ha_conf host1:port1,host2:port2`启动服务器。
这种方式可以将准备好的所有TuGraph实例一次性加入初始备份组，由备份组中的所有服务器根据raft协议选举出`leader`，并将其他服务器以`follower`的角色加入备份组。  
启动初始备份组的命令示例如下所示：  
```bash
$ ./lgraph_server -c lgraph.json --rpc_port 9090 --enable_ha true --ha_conf 172.22.224.15:9090,172.22.224.16:9090,172.22.224.17:9090
```' metadata={'Header 1': '部署高可用模式', 'Header 2': '3.启动初始备份组', 'Header 3': '3.1.初始数据一致'}","page_content='数据库运行

2.运行模式

2.1.运行普通进程

`lgraph_server -d run`命令可以将 TuGraph 作为普通进程运行。普通进程依赖命令行终端，因此终端结束时，TuGraph 进程也会自动终止。普通进程模式配合`--log_dir """"`可以将进程日志直接输出到终端，因此更方便调试。注：当不使用`-d run`命令时，将默认运行普通进程。  
lgraph_server的默认路径为：/usr/local/bin/lgraph_server 。  
lgraph.json的默认路径为：/usr/local/etc/lgraph.json 。  
启动命令：  
```shell
$ ./lgraph_server -d run -c lgraph.json --log_dir """"
```
或者：
```shell
$ ./lgraph_server -c lgraph.json --log_dir """"
```  
普通模式的运行输出示例：  
```shell' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.1.运行普通进程'}","page_content='TuGraph Management

使用

TuGraph Management使用Maven进行管理，请运行如下命令启动TuGraph Management  
`mvn spring-boot:run`  
TuGraph Management 使用了sofastack框架，并使用brpc与TuGraph进行通信，sofastack默认端口为`6071`，brpc默认端口为`6091`，如需修改服务端口，请修改`./src/main/resources/application.properties`文件中的对应配置项。' metadata={'Header 1': 'TuGraph Management', 'Header 2': '使用'}",空,空,空,空,空
如果在向TuGraph中添加顶点时存在相同的unique_id，会发生什么情况？,"page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，
索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。
因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。  
###### 1.3.1.2.3 non_unique索引  
和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。  
###### 1.3.1.2.2 pair_unique索引  
pair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，
相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，
索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。
因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。  
###### 1.3.1.2.3 non_unique索引  
和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

###### 1.3.1.1.2 non_unique索引  
点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的点的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。
但是，不同于unique索引，超过475bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
##### 1.3.1.2 边索引  
###### 1.3.1.2.1 unique索引' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。  
###### 1.3.1.1.2 non_unique索引  
点的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的点的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组vid的最大值。
每个vid是5bytes长度，因此non_unique索引key最大长度是475bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}",空,空,空,空,空
TuGraph 支持哪些硬件架构？,"page_content='环境准备

1.硬件环境

1.1. CPU

TuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的硬件平台，测试认证过的硬件平台包括 Intel、AMD、Kunpeng、Hygon、飞腾等。' metadata={'Header 1': '环境准备', 'Header 2': '1.硬件环境', 'Header 3': '1.1. CPU'}","page_content='快速上手

1.简介

1.1.支持的平台

TuGraph 无论是物理、虚拟还是容器化环境，均支持 X86_64 和 ARM64 架构的的平台。' metadata={'Header 1': '快速上手', 'Header 2': '1.简介', 'Header 3': '1.1.支持的平台'}","page_content='TuGraph与ARM架构

摘要：

- TuGraph适配国产ARM架构处理器，又双叒叕打破了LDBC SNB世界纪录，较之前纪录提升31%，云端机器开销降低了40%，大大提升了资源能效。  
- 验证了TuGraph对于ARM架构的兼容性，成为对X86和ARM架构均完整适配的图数据库，也使得TuGraph继麒麟、鲲鹏、海光等国产操作系统和处理器之后，**实现了对国产软硬件的全面支持，为用户的机器选型提供更多选择**。  
- 我们还测试了数据量大于内存的情况，结果显示，性能只下降了20%左右，显示了TuGraph在大规模数据下的适用性。  
TuGraph图数据库GitHub仓库：https://github.com/tugraph-family/tugraph-db' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '摘要：'}","page_content='TuGraph与ARM架构

内容：

TuGraph作为蚂蚁集团开源的高性能图数据库，近期在完成多平台认证的基础上，在ARM架构上发挥出极致的性能，获得了国际权威图数据库基准测试LDBC SNB的官方认证，并基于ARM架构打破了官方记录。  
**本次测试，验证了TuGraph对于ARM架构的兼容性，成为对x86和ARM架构均完整适配的图数据库；同时充分发挥出了新硬件的功能和性能优势，性能数据****较上一次官方纪录提升了31%，云端机器开销降低40%****。**  
评测流程和相关文件已同步发布在Github（https://github.com/TuGraph-family/tugraph-snb-interactive），开发者可参照来复现评测结果，**也可以通过阿里云轻松一键部署，以可视化方式试用TuGraph丰富的功能（****https://aliyun-computenest.github.io/quickstart-tugraph/****）。**该测试流程也适用于x86等其他软硬件环境。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：'}","page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}",空,空,空,空,空
TuGraph-OGM项目如何支持Java开发人员进行图对象映射，以便能够更好地与TuGraph数据库进行交互？,"page_content='TuGraph-OGM

1.简介

> TuGraph-OGM 项目在其他仓库开源。  
TuGraph-OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。同时 TuGraph-OGM 兼容 Neo4j-OGM，Neo4j 生态用户可以无缝迁移到 TuGraph 数据库上。' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '1.简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

0 映射原理

TuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。  
以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员Alice在1990年和2019年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是Frank Darabont。  
以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示，将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。  
但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '0 映射原理'}","page_content='TuGraph-OGM

简介

TuGraph-OGM(Object Graph Mapping), 源自 `Neo4j-OGM` 项目，TuGraph-OGM
支持将JAVA对象（POJO）映射到TuGraph中，JAVA中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此JAVA开发人员可以在熟悉的生态中轻松地使用TuGraph数据库。同时TuGraph-OGM兼容Neo4j-OGM，Neo4j生态用户可以无缝迁移到TuGraph数据库上。' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

简介

TuGraph 图数据库提供了 JAVA、C++、Python 等多种语言的 SDK 支持，方便客户在各种场景下使用。用户使用 SDK 向TuGraph服务器发送Cypher请求，服务器则以 JSON形式返回数据。近日，TuGraph 推出了一款面向 JAVA 客户端用户的开发工具 TuGraph-OGM (Object Graph Mapping)，为用户提供了对象操作接口，相较 Cypher/JSON 接口应用起来更加便捷。  
OGM 类似于关系数据库中的 ORM（Object Relational Model），可以将数据库返回的数据自动映射成 JAVA 中的对象，方便用户读取，而用户对这些对象的更新操作也可以被自动翻译成 Cypher 语句发送给服务器。这样即便是完全不懂 Cypher 的用户，也可以通过操作对象与数据库进行交互，大大降低了图数据库的使用门槛。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '简介'}","page_content='功能概览

5.客户端工具

OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。  
命令行工具`lgraph_cypher`是查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。' metadata={'Header 1': '功能概览', 'Header 2': '5.客户端工具'}",空,空,空,空,空
OPTIONAL MATCH在GQL中有什么作用？,"page_content='ISO GQL

2.Clauses

2.2.OPTIONAL MATCH

`OPTIONAL MATCH`匹配图模式，如果未命中，则返回`null`。  
#### 查询命中  
```
OPTIONAL MATCH (n:Person{name:'Michael Redgrave'})
RETURN n.birthyear
```  
返回结果
```JSON
[{""n.birthyear"":1908}]
```  
#### 查询未命中  
```
OPTIONAL MATCH (n:Person{name:'Redgrave Michael'})
RETURN n.birthyear
```  
返回结果  
```JSON
[{""n.birthyear"":null}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.2.OPTIONAL MATCH'}","page_content='ISO GQL

2.Clauses

2.1.MATCH

`MATCH`子句式是GQL最基础的子句，几乎所有查询都是通过 `MATCH`展开。  
`MATCH`子句用于指定在图中搜索的匹配模式，用来匹配满足一定条件的点或者路径。  
#### 点查询  
##### 查询所有点  
```
MATCH (n)
RETURN n
```  
##### 查询特定标签的点  
```
MATCH (n:Person)
RETURN n
```  
##### 通过属性匹配点  
```
MATCH (n:Person{name:'Michael Redgrave'})
RETURN n.birthyear
```  
返回结果
```JSON
[{""n.birthyear"":1908}]
```  
##### 通过过滤条件匹配点  
```
MATCH (n:Person WHERE n.birthyear > 1910)
RETURN n.name LIMIT 2
```  
返回结果
```JSON' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.1.MATCH'}",空,空,空,空,空,空,空,空
在loadProcedure方法中，如何通过参数来控制存储过程的只读性？,"page_content='C++客户端

2.使用示例

2.8.加载存储过程

@param [in]  procedure_name          procedure name.
@param [in]  code_type               code type, currently supported PY, SO, CPP, ZIP.
@param [in]  procedure_description   procedure description.
@param [in]  read_only               procedure is read only or not.
@param [in]  version                 (Optional) the version of procedure.
@param [in]  graph                   (Optional) the graph to query.
@returns True if it succeeds, false if it fails.
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.8.加载存储过程'}","page_content='Java客户端

2.使用示例

2.8.加载存储过程

@param procedureType: the procedure type, currently supported CPP and PY
@param procedureName: procedure name
@param codeType: code type, currently supported PY, SO, CPP, ZIP
@param procedureDescription: procedure description
@param readOnly: procedure is read only or not
@param version: The version of procedure
@param graph: the graph to query.
@return: the result of procedure execution' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.8.加载存储过程'}","page_content='RPC API

5.存储过程

5.1.加载存储过程

加载存储过程的请求包含以下参数：
- name: 必要参数，存储过程名称
- read_only: 必要参数，是否只读
- code: 必要参数，存储过程文件读入生成的ByteString
- desc: 可选参数，存储过程描述
- code_type: 可选参数，存储过程代码类型，PY、SO、CPP、ZIP四者之一  
以C++为例，用户加载存储过程的方式如下所示：
```C++
std::string content;
if (!FieldSpecSerializer::FileReader(source_file, content)) {
std::swap(content, result);
return false;
}
LGraphRequest req;
req.set_is_write_op(true);
lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();
pluginRequest->set_graph(graph);' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.1.加载存储过程'}","page_content='Java客户端

2.使用示例

2.8.加载存储过程

@param procedureDescription: procedure description
@param readOnly: procedure is read only or not
@param version: The version of procedure
@param graph: the graph to query.
@return: the result of procedure execution
public boolean loadProcedure(String sourceFile, String procedureType, String procedureName, String codeType,
String procedureDescription, boolean readOnly, String version, String graph) throws Exception
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.8.加载存储过程'}","page_content='C++客户端

2.使用示例

2.8.加载存储过程

const std::string& procedure_type, const std::string& procedure_name,
const std::string& code_type, const std::string& procedure_description,
bool read_only, const std::string& version = ""v1"",
const std::string& graph = ""default"");
@param [out] result                  The result.
@param [in]  source_file             the source_file contain procedure code.
@param [in]  procedure_type          the procedure type, currently supported CPP and PY.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.8.加载存储过程'}",空,空,空,空,空
在RPC调用中，如果回应的错误码不是成功，则通常会抛出什么类型的异常？,"page_content='RPC API

5.存储过程

5.3.删除存储过程

if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
server_version = std::max(server_version, res.server_version());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
```
删除存储过程的响应不包含参数，如果删除失败则抛出BadInput异常' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.3.删除存储过程'}","page_content='RPC API

5.存储过程

5.1.加载存储过程

LGraphRPCService_Stub stub(channel.get());
LGraphResponse res;
stub.HandleRequest(cntl.get(), &req, &res, nullptr);
if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
server_version = std::max(server_version, res.server_version());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
```
加载存储过程的响应不包含参数，如果加载失败则抛出BadInput异常' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.1.加载存储过程'}","page_content='RPC API

5.存储过程

5.2.调用存储过程

LGraphRPCService_Stub stub(channel.get());
stub.HandleRequest(cntl.get(), &req, &res, nullptr);
if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
server_version = std::max(server_version, res.server_version());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
if (json_format) {
result = res.mutable_plugin_response()->mutable_call_plugin_response()->json_result();
} else {' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.2.调用存储过程'}","page_content='RPC API

3.登录

if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());
token = res.acl_response().auth_response().token();
```
登录响应信息包含以下参数：
- token: 必要参数，登录成功会收到带有签名的令牌，即 Json Web Token，客户端储存该令牌，并且用于以后的每次发送请求。
如果登录失败会收到“Authentication failed”错误。' metadata={'Header 1': 'RPC API', 'Header 2': '3.登录'}","page_content='RPC API

4.查询

req.set_token(token);
lgraph::CypherRequest* cypher_req = req.mutable_cypher_request();
cypher_req->set_graph(graph);
cypher_req->set_query(query);
cypher_req->set_timeout(timeout);
cypher_req->set_result_in_json_format(true);
LGraphRPCService_Stub stub(channel.get());
stub.HandleRequest(cntl.get(), &req, &res, nullptr);
if (cntl->Failed()) throw RpcConnectionException(cntl->ErrorText());
if (res.error_code() != LGraphResponse::SUCCESS) throw RpcStatusException(res.error());' metadata={'Header 1': 'RPC API', 'Header 2': '4.查询'}",空,空,空,空,空
在Transform操作中，swap_id函数的用途是什么？,空,空,空,空,空,空,空,空,空,空
如何通过Cypher语言查询影片'Forrest Gump'的所有演员以及他们所扮演的角色？,"page_content='场景：影视

2.查询示例

2.2.示例二

查询影片 'Forrest Gump' 的所有演员，列出演员在影片中扮演的角色。  
```
MATCH (m:movie {title: 'Forrest Gump'})<-[r:acted_in]-(a:person) RETURN a.name,r.role
```' metadata={'Header 1': '场景：影视', 'Header 2': '2.查询示例', 'Header 3': '2.2.示例二'}","page_content='场景：影视

2.查询示例

2.1.示例一

查询影片 'Forrest Gump' 的所有演员，返回影片和演员构成的子图。  
```
MATCH (m:movie {title: 'Forrest Gump'})<-[:acted_in]-(a:person) RETURN a, m
```' metadata={'Header 1': '场景：影视', 'Header 2': '2.查询示例', 'Header 3': '2.1.示例一'}","page_content='demo/movie/query/e2.cypher/ MATCH (m:movie {title: 'Forrest Gump'})<-[r:acted_in]-(a:person) RETURN a.name,r.role;
' metadata={'file_name': 'e2.cypher', 'file_path': 'demo/movie/query/e2.cypher', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/movie/query/e2.cypher'}","page_content='demo/movie/query/queries.cypher/ # who acted in Forrest Gump
MATCH (m:movie {title: 'Forrest Gump'})<-[:acted_in]-(a:person) RETURN a, m

# who played who in Forrest Gump
MATCH (m:movie {title: 'Forrest Gump'})<-[r:acted_in]-(a:person) RETURN a.name,r.role

# which movies does Michael hate
MATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie) WHERE r.stars < 3 RETURN m.title, r.stars

# who hate the movies I hate
MATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v) WHERE r.stars < 3 AND s.stars < 3 RETURN u, m, v

# what do those with my taste like?
MATCH (u:user {login: 'Michael'})-[r:rate]->(m:movie)<-[s:rate]-(v)-[r2:rate]->(m2:movie) WHERE r.stars < 3 AND s.stars < 3 AND r2.stars > 3 RETURN u, m, v, m2

# what do my friends like?
MATCH (u:user {login: 'Michael'})-[:is_friend]->(v:user)-[r:rate]->(m:movie) WHERE r.stars > 3 RETURN u, v, m

# those who liked Forrest Gump also like...
MATCH (m:movie {title:'Forrest Gump'})<-[r:rate]-(u:user)-[r2:rate]->(m2:movie) WHERE r.stars>3 AND r2.stars>3 RETURN m, u,m2
' metadata={'file_name': 'queries.cypher', 'file_path': 'demo/movie/query/queries.cypher', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/movie/query/queries.cypher'}","page_content='demo/movie/query/e1.cypher/ MATCH (m:movie {title: 'Forrest Gump'})<-[:acted_in]-(a:person) RETURN a, m;
' metadata={'file_name': 'e1.cypher', 'file_path': 'demo/movie/query/e1.cypher', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/movie/query/e1.cypher'}",空,空,空,空,空
TuGraph-DB图数据库社区版内置了多少种基础算法？,"page_content='内置算法

简介

TuGraph目前包含以下6个基础算法28种扩展算法，共34个图算法：' metadata={'Header 1': '内置算法', 'Header 2': '简介'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。  
TuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法。涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='技术规划

2. 已完成功能

| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}","page_content='技术规划

2. 已完成功能

| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}",空,空,空,空,空
TuGraph-DB支持的三种空间数据类型是什么？,"page_content='空间数据类型在TuGraph-DB中的实现

定义空间数据类型

TuGraph-DB当前已经支持Point、Linestring与Polygon三种类型  
-   • Point：点，创建方式例如POINT(2.0, 2.0, 7203)  
-   • Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)  
-   • Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))  
其中坐标点都是double型' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '定义空间数据类型'}","page_content='地理空间数据类型使用示例

3. 数据类型

目前在TuGraph中，我们已经支持了Point, Linestring与Polygon三种类型:  
- Point：点    point(2.0, 2.0, 7203)
- Linestring：折线 LINESTRING(0 2,1 1,2 0)
- Polygon：多边形  POLYGON((0 0,0 7,4 2,2 0,0 0))  
其中坐标点都是double型，创建图模型和插入数据示例如下：  
**创建标记美食位置的点模型**  
```
CALL db.createVertexLabel('food', 'id', 'id', int64, false, 'name', string, true,'pointTest',point,true)
```  
![image.png](../../../images/spatail/createVertexLabel.png)  
**插入标记美食点的数据**  
```' metadata={'Header 1': '地理空间数据类型使用示例', 'Header 2': '3. 数据类型'}","page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的表示

空间数据类型可以用不同的坐标系来表示，EPSG<sup>[1]</sup>是一个标准化的地理空间参考系统标识符集合， 用于标识不同的地理空间参考系统，包括坐标系统、地理坐标系、投影坐标系等。通常使用EPSG编码表示数据的坐标系。行业内一般采用  
-   •WGS84坐标系（没错，就是GPS系统的坐标系），标识符为EPSG 4326  
-   •Cartesian（笛卡尔）坐标系（没错，就是你高中数学学的直角坐标系），标识符为EPSG 7203  
WGS84是全球定位系统(GPS)的基础，允许全球的GPS接收器确定精确位置。几乎所有现代GPS设备都是基于WGS84坐标系来提供位置信息。在地图制作和GIS（地图制作和地理信息系统）领域，WGS84被广泛用于定义地球上的位置。这包括各种类型的地图创建、空间数据分析和管理等。  
Cartesian（笛卡尔）坐标系，又称直角坐标系，是一种最基本、最广泛应用的坐标系统。它通过两条数轴定义一个平面，三条数轴定义一个空间，这些轴互相垂直，在数学、物理、工程、天文和许多其他领域中有着广泛的应用。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的表示'}","page_content='空间数据类型在TuGraph-DB中的实现

需求分析

结合上述案例，我们可以分析总结出对空间数据类型的需求:  
-   •支持不同坐标系下（包括地球地理坐标系，平面几何坐标系等）不同空间数据类型（包括Point、LineString,、Polygon）的存储与创建  
-   •支持不同坐标系下的常见空间查询操作, 包括Distance、BoundingBox、Disjoint（判断两个数据是否相交）的查询等  
-   •支持空间数据索引（R-Tree）  
-   •支持常见空间数据格式的导入（ESRI Shapefile data / OpenStreetMap）  
-   •支持空间数据的可视化' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '需求分析'}","page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的实现

OGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的实现'}",空,空,空,空,空
请问产品是否支持麒麟操作系统？只有企业版支持这种系统吗？,"page_content='QA汇总

安装部署QA

麒麟操作系统支持

Q：产品是否支持麒麟操作系统？只有企业版支持么？
A：开源和企业版都支持' metadata={'Header 1': 'QA汇总', 'Header 2': '安装部署QA', 'Header 3': '麒麟操作系统支持'}",空,空,空,空,空,空,空,空,空
TuGraph-DB中存储Point类型数据的格式是什么？,"page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的实现

EWKB

EWKB格式数据如下  
-   •第0-1位: 表示编码方式 00表示大端法，01表示小端法  
-   •第2 - 5位: 空间数据类型  
-   •0100: point  
-   •0200: linestring  
-   •0300: polygon  
-   •第6 - 9位: 数据维度  
-   •0020: 二维  
-   •0030: 三维  
-   •第10 - 17位: 坐标系的EPSG编码  
-   •第18 - n位: double类型的坐标对的16进制表示  
**注:**对于POINT类型，其EWKB格式为定长存储，固定长度为50，而对于其他类型，则为不定长。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的实现', 'Header 3': 'EWKB'}","page_content='TuGraph图模型说明

1. 数据模型

1.2. 数据类型

| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |
| POINT        |                     |                     | EWKB格式数据，表示点              |
| LINESTRING   |                     |                     | EWKB格式数据，表示线              |
| POLYGON      |                     |                     | EWKB格式数据，表示面(多边形)       |
| FLOAT_VECTOR |                     |                     | 包含32位浮点数的动态向量               |' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.2. 数据类型'}","page_content='空间数据类型在TuGraph-DB中的实现

定义空间数据类型

TuGraph-DB当前已经支持Point、Linestring与Polygon三种类型  
-   • Point：点，创建方式例如POINT(2.0, 2.0, 7203)  
-   • Linestring：折线，创建方式例如LINESTRING(0 2,1 1,2 0)  
-   • Polygon：多边形，创建方式例如POLYGON((0 0,0 7,4 2,2 0,0 0))  
其中坐标点都是double型' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '定义空间数据类型'}","page_content='空间数据类型在TuGraph-DB中的实现

相关函数介绍

| PointWKT() | 根据WKT与指定SRID创建Point | WKT format(string) , SRID(int) | point |  
查询用相关函数：  
| **函数名** | **描述** | **输入参数** | **返回值类型** |
| --- | --- | --- | --- |
| Distance() | 计算两个空间数据间的距离 |
|
|
| 注：要求坐标系相同 | Spatial data1, Spatial data2 | double |
|
| Disjoint() | 判断两个空间数据是否相交 |
|
|
| 注：开发中 | Spatial data1, Spatial data2 | bool |
|
| WithinBBox() | 判断某个空间数据是否在给定的长方形区域内 |
|
|
| 注：开发中 | Spatial data, Point1 | bool |
|  
使用实例如下：  
```
#创建包含空间数据类型的点模型' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '相关函数介绍'}","page_content='TuGraph图模型说明

1. 数据模型

1.2. 数据类型

| FLOAT        |                     |                     | 32位浮点数                       |
| DOUBLE       |                     |                     | 64位浮点数                       |
| STRING       |                     |                     | 不定长度的字符串                    |
| BLOB         |                     |                     | 二进制数据（在输入输出时使用Base64编码） |
| POINT        |                     |                     | EWKB格式数据，表示点              |' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.2. 数据类型'}",空,空,空,空,空
TuGraph嵌入模式的API允许用户执行哪些具体操作？,"page_content='Procedure API

1.简介

当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个请求并在客户端完成整个处理流程的方式，TuGraph 提供的存储过程是更简洁和高效的选择。  
与传统数据库类似，TuGraph 的存储过程运行在服务器端，用户通过将处理逻辑（即多个操作）封装到一个过程单次调用，并且可以在实现时通过并行处理的方式（例如使用相关的 C++ OLAP 接口以及基于其实现的内置算法）进一步提升性能。  
存储过程中有一类特殊的API来进行数据的并行操作，我们叫 Traversal API，见[文档](2.traversal.md)。' metadata={'Header 1': 'Procedure API', 'Header 2': '1.简介'}","page_content='RPC API

5.存储过程

为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。
用户可以使用RPC请求对存储过程进行增删改查操作。' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程'}","page_content='OlapOnDisk API

1. 简介

TuGraph的Standalone模式可用于加载图数据文件，其中图数据文件来源可包含text文本文件、BINARY_FILE二进制文件和ODPS源。在该模式下，TuGraph可实现多数据来源快速加载成图，然后在该图上运行如BFS、WCC、SSSP等迭代式算法，并输出最终结果至终端。  
在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
TuGraph内置了大量的常见图分析算法和丰富的辅助接口，因此用户几乎不需要自己实现具体的图计算过程，只需要在实现自己的存储过程的时候将相应算法库的头文件(.h)包含到自己的程序中，并在编译阶段链接自己的动态库文件即可。  
该文档主要介绍了Standalone的常用接口，使用到的辅助函数主要包含在OlapOnDB类。同时为帮助用户理解方便，对BFS算法进行举例说明。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '1. 简介'}","page_content='Traversal API

1. 简介

TuGraph 强大的在线分析处理（OLAP）能力是其区别于其它图数据库的一个重要特性。
借助 C++ OLAP API（olap_on_db.h），用户可以快速地导出一个需要进行复杂分析的子图，然后在其上运行诸如 PageRank、连通分量、社区发现等迭代式图计算过程，最后根据结果做出相应决策。
导出和计算的过程都可以通过并行处理的方式进行加速，从而实现几乎实时的分析处理，避免了传统解决方案需要将数据导出、转换、再导入（ETL）到专门的分析系统进行离线处理的冗长步骤。  
TuGraph 内置了大量常用的图分析算法和丰富的辅助接口，因此用户几乎不需要自己来实现具体的图计算过程，只需在实现自己的存储过程时将相应算法库的头文件（.h 文件）包含到自己程序中，并在编译时链接相应的动态库文件（.so）即可。
一般情况下，用户需要自己实现的只有将需要分析的子图抽取出来的过程。  
目前 Traversal API 仅支持 C++。' metadata={'Header 1': 'Traversal API', 'Header 2': '1. 简介'}","page_content='RESTful API

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。' metadata={'Header 1': 'RESTful API', 'Header 2': '1.简介'}",空,空,空,空,空
Date 类的默认构造函数设置的日期是什么？,空,空,空,空,空,空,空,空,空,空
在使用 bool DeleteVertexIndex 函数时，如果给定的 vertex_label 或 field 不存在，会发生什么情况？,"page_content='src/cypher/procedure/procedure.cpp/ VectorFunc::DeleteVertexVectorIndex(RTContext *ctx, const cypher::Record *record,
                       const cypher::VEC_EXPR &args,
                       const cypher::VEC_STR &yield_items,
                       struct std::vector<cypher::Record> *records) {
    CYPHER_DB_PROCEDURE_GRAPH_CHECK();
    CYPHER_ARG_CHECK(args.size() == 2,
                     ""e.g. db.deleteVertexVectorIndex(label_name, field_name);"");
    CYPHER_ARG_CHECK(args[0].IsString(),
                    ""label_name type should be string"");
    CYPHER_ARG_CHECK(args[1].IsString(),
                    ""field_name type should be string"");
    CheckProcedureYieldItem(""db.deleteVertexVectorIndex"", yield_items);
    if (ctx->txn_) ctx->txn_->Abort();
    auto label = args[0].constant.AsString();
    auto field = args[1].constant.AsString();
    bool success = ctx->ac_db_->DeleteVectorIndex(true, label, field);
    if (!success) {
        throw lgraph::IndexNotExistException(label, field);
    }
    FillProcedureYieldItem(""db.deleteVertexVectorIndex"", yield_items, records);
}

void' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}","page_content='src/core/index_manager.cpp/ bool IndexManager::DeleteVertexCompositeIndex(lgraph::KvTransaction& txn,
                                              const std::string& label,
                                              const std::vector<std::string>& fields) {
    std::string table_name = GetVertexCompositeIndexTableName(label, fields);
    // delete the entry from index list table
    if (!index_list_table_->DeleteKey(txn, Value::ConstRef(table_name)))
        return false;  // does not exist
                       // now delete the index table
    bool r = db_->GetStore().DeleteTable(txn, table_name);
    FMA_DBG_ASSERT(r);
    return true;
}

bool IndexManager::DeleteVectorIndex(KvTransaction& txn, const std::string& label,
                                     const std::string& field) {
    auto table_name = GetVertexVectorIndexTableName(label, field);
    if (!index_list_table_->DeleteKey(txn, Value::ConstRef(table_name)))
        return false;  // does not exist
    return true;
}' metadata={'file_name': 'index_manager.cpp', 'file_path': 'src/core/index_manager.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/index_manager.cpp'}","page_content='src/core/lightning_graph.cpp/ bool LightningGraph::DeleteVectorIndex(
    bool is_vertex, const std::string& label, const std::string& field) {
    if (!is_vertex) {
        THROW_CODE(VectorIndexException, ""Only vertex supports vector index"");
    }
    _HoldWriteLock(meta_lock_);
    Transaction txn = CreateWriteTxn(false);
    ScopedRef<SchemaInfo> curr_schema = schema_.GetScopedRef();
    Schema* schema = curr_schema->v_schema_manager.GetSchema(label);
    if (!schema) throw LabelNotExistException(label);
    if (field == schema->GetPrimaryField()) {
        throw PrimaryIndexCannotBeDeletedException(field);
    }
    std::unique_ptr<SchemaInfo> old_schema_backup(new SchemaInfo(*curr_schema.Get()));
    const _detail::FieldExtractor* extractor = schema->GetFieldExtractor(field);
    if (!extractor->GetVectorIndex()) {
        return false;
    }
    std::unique_ptr<SchemaInfo> new_schema(new SchemaInfo(*curr_schema.Get()));
    schema = new_schema->v_schema_manager.GetSchema(label);
    auto deleted = index_manager_->DeleteVectorIndex(txn.GetTxn(), label, field);
    if (deleted) {
        schema->UnVectorIndex(extractor->GetFieldId());
        // install the new schema
        schema_.Assign(new_schema.release());
        AutoCleanupAction revert_assign_new_schema(
            [&]() { schema_.Assign(old_schema_backup.release()); });
        txn.Commit();
        // if success, cancel revert
        revert_assign_new_schema.Cancel();
        return true;
    }
    return false;
}' metadata={'file_name': 'lightning_graph.cpp', 'file_path': 'src/core/lightning_graph.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/lightning_graph.cpp'}","page_content='src/core/index_manager.cpp/ bool IndexManager::DeleteVertexIndex(KvTransaction& txn, const std::string& label,
                                     const std::string& field) {
    std::string table_name = GetVertexIndexTableName(label, field);
    // delete the entry from index list table
    if (!index_list_table_->DeleteKey(txn, Value::ConstRef(table_name)))
        return false;  // does not exist
                       // now delete the index table
    bool r = db_->GetStore().DeleteTable(txn, table_name);
    FMA_DBG_ASSERT(r);
    return true;
}

bool IndexManager::DeleteEdgeIndex(KvTransaction& txn, const std::string& label,
                                   const std::string& field) {
    std::string table_name = GetEdgeIndexTableName(label, field);
    // delete the entry from index list table
    if (!index_list_table_->DeleteKey(txn, Value::ConstRef(table_name)))
        return false;  // does not exist
    // now delete the index table
    bool r = db_->GetStore().DeleteTable(txn, table_name);
    FMA_DBG_ASSERT(r);
    return true;
}' metadata={'file_name': 'index_manager.cpp', 'file_path': 'src/core/index_manager.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/index_manager.cpp'}","page_content='src/cypher/procedure/procedure.cpp/ BuiltinProcedure::DbDeleteIndex(RTContext *ctx, const Record *record,
                                     const VEC_EXPR &args, const VEC_STR &yield_items,
                                     std::vector<Record> *records) {
    CheckProcedureYieldItem(""db.deleteIndex"", yield_items);
    CYPHER_ARG_CHECK(args.size() == 2,
                     ""need two parameters, e.g. db.deleteIndex(label_name, field_name)"")
    CYPHER_ARG_CHECK(args[0].IsString(), ""label_name type should be string"")
    CYPHER_ARG_CHECK(args[1].IsString(), ""field_name type should be string"")
    CYPHER_DB_PROCEDURE_GRAPH_CHECK();
    if (ctx->txn_) ctx->txn_->Abort();
    bool success = ctx->ac_db_->DeleteVertexIndex(args[0].constant.scalar.AsString(),
                                                  args[1].constant.scalar.AsString());
    if (!success) {
        throw lgraph::IndexNotExistException(args[0].constant.scalar.AsString(),
                                             args[1].constant.scalar.AsString());
    }
    FillProcedureYieldItem(""db.deleteIndex"", yield_items, records);
}

void' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}",空,空,空,空,空
如何在单命令模式下使用 lgraph_cypher 通过命令行参数执行一条 Cypher 查询并将结果显示为表格格式？,"page_content='src/cypher/execution_plan/execution_plan.cpp/ auto &e = std::get<0>(item);
            auto &alias = std::get<1>(item);
            bool isHidden = std::get<2>(item);
            if (isHidden) {
                continue;
            }
            ArithExprNode ae(e, stmt.symbol_table);
            bool aggregate = ae.ContainsAggregation();
            if (aggregate) result_info.aggregated = true;
            auto name = e.ToString(false);
            auto it = stmt.symbol_table.symbols.find(name);
            auto type = SymbolNode::CONSTANT;
            if (it == stmt.symbol_table.symbols.end()) {
                if (e.type == Expression::VARIABLE) {
                    throw lgraph::CypherException(""Unknown variable: "" + name);
                }
            } else {
                type = it->second.type;
            }' metadata={'file_name': 'execution_plan.cpp', 'file_path': 'src/cypher/execution_plan/execution_plan.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/execution_plan.cpp'}","page_content='src/cypher/procedure/procedure.cpp/ BuiltinProcedure::DbTaskTerminateTask(RTContext *ctx, const Record *record,
                                           const VEC_EXPR &args, const VEC_STR &yield_items,
                                           std::vector<cypher::Record> *records) {
    CheckProcedureYieldItem(""dbms.task.terminateTask"", yield_items);
    if (!ctx->galaxy_->IsAdmin(ctx->user_))
        THROW_CODE(Unauthorized, ""Admin access right required."");
    CYPHER_ARG_CHECK(args.size() == 1, ""need one parameters, e.g. dbms.task.terminateTask(task_id)"")
    CYPHER_ARG_CHECK(args[0].IsString(), ""task_id type should be string"")
    lgraph::TaskTracker::TaskId task_id = lgraph::TaskTracker::TaskId();
    task_id.FromString(args[0].constant.scalar.AsString());
    auto r = lgraph::TaskTracker::GetInstance().KillTask(task_id);
    switch (r) {
    case lgraph::TaskTracker::SUCCESS:
        return;
    case lgraph::TaskTracker::NOTFOUND:
        throw lgraph::TaskNotExistException(args[0].constant.scalar.AsString());
    case lgraph::TaskTracker::FAIL_TO_KILL:
        throw lgraph::TaskKilledFailedException(args[0].constant.scalar.AsString());
    default:
        return;
    }
    FillProcedureYieldItem(""dbms.task.terminateTask"", yield_items, records);
}

void' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}","page_content='src/cypher/execution_plan/scheduler.cpp/ void Scheduler::Eval(RTContext *ctx, const lgraph_api::GraphQueryType &type,
                     const std::string &script, ElapsedTime &elapsed) {
    if (type == lgraph_api::GraphQueryType::CYPHER) {
        if (ctx->is_cypher_v2_) {
            EvalCypher2(ctx, script, elapsed);
        } else {
            EvalCypher(ctx, script, elapsed);
        }
    } else {
        EvalGql(ctx, script, elapsed);
    }
}

bool Scheduler::DetermineReadOnly(cypher::RTContext *ctx,
                                  const lgraph_api::GraphQueryType &query_type,
                                  const std::string &script, std::string &name, std::string &type) {
    if (query_type == lgraph_api::GraphQueryType::CYPHER) {
        return DetermineCypherReadOnly(ctx, script, name, type);
    } else {
        return DetermineGqlReadOnly(ctx, script, name, type);
    }
}' metadata={'file_name': 'scheduler.cpp', 'file_path': 'src/cypher/execution_plan/scheduler.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/scheduler.cpp'}","page_content='src/cypher/execution_plan/scheduler.cpp/ ctx->result_info_ = std::make_unique<cypher::ResultInfo>();
            ctx->result_ = std::make_unique<lgraph::Result>();
            std::string header, data;
            if (visitor.CommandType() == parser::CmdType::EXPLAIN) {
                header = ""@plan"";
                data = plan->DumpPlan(0, false);
            } else {
                header = ""@profile"";
                data = plan->DumpGraph();
            }
            ctx->result_->ResetHeader({{header, lgraph_api::LGraphType::STRING}});
            auto r = ctx->result_->MutableRecord();
            r->Insert(header, lgraph::FieldData(data));
            LOG_DEBUG() << ""--- execution_plan_v2 dump ---"";
            LOG_DEBUG() << ctx->result_->Dump(false);' metadata={'file_name': 'scheduler.cpp', 'file_path': 'src/cypher/execution_plan/scheduler.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/scheduler.cpp'}","page_content='src/cypher/execution_plan/scheduler.cpp/ ctx->result_info_ = std::make_unique<ResultInfo>();
            ctx->result_ = std::make_unique<lgraph::Result>();
            std::string header, data;
            if (plan->CommandType() == parser::CmdType::EXPLAIN) {
                header = ""@plan"";
                data = plan->DumpPlan(0, false);
            } else {
                header = ""@profile"";
                data = plan->DumpGraph();
            }
            ctx->result_->ResetHeader({{header, lgraph_api::LGraphType::STRING}});
            auto r = ctx->result_->MutableRecord();
            r->Insert(header, lgraph::FieldData(data));' metadata={'file_name': 'scheduler.cpp', 'file_path': 'src/cypher/execution_plan/scheduler.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/scheduler.cpp'}",空,空,空,空,空
reduce_plus函数是如何处理它的两个参数的？,"page_content='OlapBase API

7. 图类OlapBase

7.4 批处理操作

TuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程。分别是：  
```c++
/*
函数名称:ReducedSum ProcessVertexInRange(std::function<ReducedSum(size_t)> work, size_t lower, size_t upper,
ReducedSum zero = 0,std::function<ReducedSum(ReducedSum, ReducedSum)> reduce =reduce_plus<ReducedSum>)

函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；
第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。
具体实现请参考include/lgraph/olap_base.h中具体代码

使用示例:统计数组parent数组中有出边的点个数
*/' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.4 批处理操作'}","page_content='Python Olap API

4. Olap API

图类OlapBase

#           active: ParallelBitset,
#           algo: Algorithm,
#           zero: ReducedSum = 0,
#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])
#
#   函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；
#   第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。
#   具体实现请参考/include/lgraph/olap_base.h中具体代码
#
# 使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}","page_content='Python Olap API

4. Olap API

图类OlapBase

#           zero: ReducedSum = 0,
#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])
#
#     函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；
#     第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。
#     具体实现请参考include/lgraph/olap_base.h中具体代码
#
#     使用示例:统计数组parent数组中有出边的点个数' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}","page_content='Python Olap API

4. Olap API

图类OlapBase

```python
# 函数名称:ProcessVertexInRange[ReducedSum, Algorithm](
#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,
#           lower: size_t, upper: size_t,
#           algo: Algorithm,
#           zero: ReducedSum = 0,
#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])
#
#     函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；
#     第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}",空,空,空,空,空,空
TuGraph是否支持无向边？,"page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。
- 指定边的起/终点类型：可限制边的起点和终点点类型，支持同类型边的起点和终点的点类型不同，如个人转账给公司、公司转账给公司；当指定边的起/终点类型后，可增加多组起/终点类型，不可删除已限制的起/终点类型。
- 无限制模式：支持不指定边的起点和终点的点类型，任意两个点类型间均可创建该类型的边数据。注：当指定边的起/终点类型后无法再采用无限制模式。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}","page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='什么是TuGraph

3. TuGraph特性

TuGraph是支持大数据量、低延迟查找和快速图分析功能的高效图数据库。TuGraph也是基于磁盘的数据库，支持存储多达数十TB的数据。TuGraph提供多种API，使用户能够轻松构建应用程序，并使其易于扩展和优化。  
它具有如下功能特征：  
- 属性图模型
- 实时增删查改
- 多重图（点间允许多重边）
- 多图（大图与多个子图）
- 完善的ACID事务处理，隔离级别为可串行化（serializable）
- 点边索引
- 混合事务和分析处理（HTAP），支持图查询、图分析、图学习
- 主流图查询语言（OpenCypher、ISO GQL等）
- 支持OLAP API，内置30多种图分析算法
- 基于C++/Python的存储过程，含事务内并行Traversal API
- 提供图可视化工具  
在性能和可扩展性方面的支持：  
- 千万点/秒的高吞吐率
- TB级大容量
- 高可用性支持
- 高性能批量导入
- 在线/离线的备份恢复' metadata={'Header 1': '什么是TuGraph', 'Header 2': '3. TuGraph特性'}",空,空,空,空,空
FieldData类中提供了哪些构造函数用于初始化不同类型的数据？,空,空,空,空,空,空,空,空,空,空
TuGraph-DB是如何帮助用户解决在旅行时选择路线的烦恼的？,"page_content='Round The World Demo

示例

查询示例

在左下角的城市列表中选择不超过8个城市，点击查询可返回推荐的航班规划，在满足前后航班间隔在2-6小时的要求下，返回费用最低和飞行时间最短的10条路径规划。  
![data](../../../../images/round-the-world/search_example.jpg)  
详细使用说明见 [Round The World Demo](https://github.com/TuGraph-family/tugraph-db-demo/tree/main/round_the_world) 文档。' metadata={'Header 1': 'Round The World Demo', 'Header 2': '示例', 'Header 3': '查询示例'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

一、高可用架构介绍

4.TuGraph-DB高可用架构—Raft 共识算法

-   有了一致性的保证后，安全性也就有了保证，当超过半数的节点达成一致之后，才应用日志，这样就能解决网络分区延迟、丢包、冗余和乱序的错误。
-   基于一致性和安全性，它的可用性也就得到了保证，只要少于半数的节点宕机，即使主机宕机，也可以快速恢复应用，通过一次选举的时间就可以重新选出一个leader对外提供服务。  
国标对于高可用系统的指标评估，RTO 和 RPO 分别是恢复时间指标和恢复点目标，有 6 个等级，TuGraph-DB 已经达到了最高等级。当少量节点故障时，RPO 是 0，也就是没有数据损失，数据恢复时间点指标是小于 15 秒。即使是在部署的时候，无论是在同城的两中心、三中心，还是多地的多中心，都可以达成 RTO 小于 15 秒的标准。  
Raft算法优点:  
• 易用性：状态简单，强Leader  
• 一致性：日志逐个复制，超过半数节点达成一致才提交，不存在日志空洞  
• 安全性：超半数节点达成一致才应用日志，能解决网络延迟、分区、丢包、冗余和乱序等错误' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '一、高可用架构介绍', 'Header 3': '4.TuGraph-DB高可用架构—Raft 共识算法'}","page_content='技术规划

2. 已完成功能

| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}","page_content='技术规划

2. 已完成功能

| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}",空,空,空,空,空
exists()函数用于检查在TuGraph中是否存在满足特定条件的记录或元素吗？,"page_content='src/cypher/procedure/procedure.cpp/ BuiltinProcedure::DbMonitorTuGraphInfo(RTContext *ctx, const Record *record,
                                            const VEC_EXPR &args,
                                            const VEC_STR &yield_items,
                                            std::vector<Record> *records) {
    CheckProcedureYieldItem(""db.monitor.tuGraphInfo"", yield_items);
    CYPHER_ARG_CHECK(args.empty(), FMA_FMT(""Function requires 0 arguments, but {} are ""
                                           ""given. Usage: db.monitor.tuGraphInfo()"",
                                           args.size()))
    if (!ctx) CYPHER_INTL_ERR();
    Record r;
    r.AddConstant(lgraph::FieldData(ValueToJson(ctx->sm_->GetStats()).serialize()));
    records->emplace_back(r.Snapshot());
    FillProcedureYieldItem(""db.monitor.tuGraphInfo"", yield_items, records);
}

void' metadata={'file_name': 'procedure.cpp', 'file_path': 'src/cypher/procedure/procedure.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/procedure/procedure.cpp'}",空,空,空,空,空,空,空,空,空
TuGraph的最低和建议CPU配置分别是多少个核心？,"page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='TuGraph与ARM架构

内容：

**背景介绍：**

在高速信息化的21世纪，计算机软硬件均经历着翻天覆地的变化，从Intel和AMD的x86 CPU架构到ARM RISC精简指令CPU，内存也演进出超高带宽内存HBM、非易失内存NVM。近年来基于ARM架构的CPU越来越普遍，在手机中ARM芯片已占90%以上份额，个人PC中苹果M1/M2均采用ARM架构，在服务器领域华为鲲鹏、飞腾等ARM架构CPU也逐步被接纳。本次测试使用的倚天710，是阿里基于ARMv9架构自研的CPU，已在阿里云服务中大规模部署，成为中国首个云上大规模应用的自研CPU。  
数据库作为底层系统软件，面对CPU的更新换代也迎来了更多的挑战和机遇。在ARM架构中，CPU通常拥有更多的核数、更低的能耗、更高的性价比。作为拥抱开源的图数据库产品，TuGraph不仅需要兼容新型硬件，更需要充分发挥出新硬件的功能和性能优势。适配和测试工作包括超多线程的支持、更加细致的负载均衡策略、并发读写性能优化等。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**背景介绍：**'}","page_content='TuGraph与ARM架构

内容：

**背景介绍：**

数据库作为底层系统软件，面对CPU的更新换代也迎来了更多的挑战和机遇。在ARM架构中，CPU通常拥有更多的核数、更低的能耗、更高的性价比。作为拥抱开源的图数据库产品，TuGraph不仅需要兼容新型硬件，更需要充分发挥出新硬件的功能和性能优势。适配和测试工作包括超多线程的支持、更加细致的负载均衡策略、并发读写性能优化等。  
**本次测试机构国际关联数据基准委员会LDBC是由高校、研究所、企业联合组成的非盈利组织，其中企业成员包括Intel、Oracle、Neo4j、蚂蚁集团等国内外知名图数据厂商，致力于推进图数据的规范标准化。**本次测试使用的图数据来自LDBC的社交网络运营场景SNB（Social Network Benchmark），LDBC SNB的图数据是一个包含14类顶点和20类边的属性图，用户可以指定scale factor生成不同规模的数据。LDBC SNB的交互式工作负载由14个复杂的只读查询、7个简单的只读查询和8个事务型更新查询组成。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**背景介绍：**'}","page_content='demo/TuGraph-Demo.md/ # TuGraph 示例

## 1 简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph是TuGraph的曾用名。

主要功能特征包括：

- 支持属性图模型
- 原生图存储及处理
- 完全的ACID事务支持
- 支持OpenCypher图查询语言
- 支持原生的Core API和Traversal API
- 支持REST和RPC接口
- 支持CSV、JSON、MySQL等多数据源导入导出
- 支持可视化图交互
- 支持命令行交互
- 内置用户权限控制、操作审计
- 支持任务和日志的监控管理
- 原生适配PandaGraph图分析引擎
- 集成DGL图神经网络系统

性能及可扩展性特征包括：

- 支持TB级大容量
- 吞吐率高达千万顶点每秒
- 面向读优化的存储引擎
- 支持高可用模式
- 支持离线备份恢复
- 在线热备份
- 高性能批量导入导出

## 2 快速上手

见QuickStart文档。

## 3 基本功能

### 3.1 RPC Client
#### 3.1.1 概述
RPC Client是对cpp语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.1.2 编译
在代码目录demo/CppRpcClientDemo目录下,执行下列命令 ,成功后将会看到可执行文件clientdemo
```bash
mkdir build && cd build && cmake ../ && make
```
#### 3.1.3 运行
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
        -h             show this usage
        -i --ip        ip for graph server
        -p --port      port for graph server
        -g --graph     graph name
        -u --user      user name
        --password     user password
        -c --cypher    cypher to query
举例如下
```bash
./clientdemo -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
### 3.2 Python RPC Client
#### 3.2.1 概述
Python RPC Client是对python语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.2.2 运行
需要依赖编译生成的python_client.so库，将python_client.so与client_python.py放在同一目录下
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
-h             show this usage
-i --ip        ip for graph server
-p --port      port for graph server
-g --graph     graph name
-u --user      user name
--password     user password
-c --cypher    cypher to query
举例如下
```bash
python3 client_python.py -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
## 4 集成工具

### 4.1 DataX 导入导出工具
#### 4.1.1 概述
DataX 支持 TuGraph 和 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源的数据导入导出。
#### 4.' metadata={'file_name': 'TuGraph-Demo.md', 'file_path': 'demo/TuGraph-Demo.md', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/TuGraph-Demo.md'}","page_content='云部署

2.实例说明

TuGraph部署的为社区开源版本，源码参考Github Repo，目前可以选择的实例规格如下：  
| 规格族         | vCPU与内存                 | 系统盘              | 公网带宽      |
|----------------|-------------------------|-------------------|-----------|
| ecs.r7a.xlarge | AMD 内存型 r7a，4vCPU 32GiB | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |
| ecs.r6.xlarge  | 内存型r6，4vCPU 32GiB       | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |  
预估费用在创建实例时可实时看到（目前为免费）。 如需更多规格、其他服务（如集群高可用性要求、企业级支持服务等），请联系我们 tugraph@service.alipay.com。' metadata={'Header 1': '云部署', 'Header 2': '2.实例说明'}",空,空,空,空,空
MappedVid 函数的用途是什么？,"page_content='OlapOnDB API

4. 其他常用函数功能描述

4.9 获取OlapOnDB中节点对应TuGraph的节点编号

```C++
size_t MappedVid(size_t original_vid)
```' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '4. 其他常用函数功能描述', 'Header 3': '4.9 获取OlapOnDB中节点对应TuGraph的节点编号'}",空,空,空,空,空,空,空,空,空
当我尝试更新一个存在的边，但该边的标签与我指定的标签不符时，会发生什么情况？,空,空,空,空,空,空,空,空,空,空
"批量在线导入数据的方式是通过使用“CREATE (n), (m)”命令吗？",空,空,空,空,空,空,空,空,空,空
lgraph_backup工具的主要功能是什么？,空,空,空,空,空,空,空,空,空,空
如何通过什么方法和URI获取某个节点的所有属性？,"page_content='RESTful API Legacy

6.Deprecated

6.7.点操作

| --- | --- | --- |
| in | 被删掉的点的入边数量 | 整数值 |
| out | 被删掉的点的出边数量 | 整数值 |  
**Example request.**  
```
• DELETE http://localhost:7070/db/{graph_name}/node/4
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""in"": 0,
""out"": 0
}
```  
#### 6.7.6.获取点所有属性  
- **URI**: `/db/{graph_name}/node/{vertex_id}/property`
- **METHOD**: GET
- **RESPONSE**: Node 所有属性（字典）  
**Example request.**  
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.7.点操作'}","page_content='RESTful API Legacy

6.Deprecated

6.7.点操作

• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""in"": 0,
""out"": 0
}
```  
#### 6.7.6.获取点所有属性  
- **URI**: `/db/{graph_name}/node/{vertex_id}/property`
- **METHOD**: GET
- **RESPONSE**: Node 所有属性（字典）  
**Example request.**  
```
• GET http://localhost:7070/db/{graph_name}/node/5/property
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""birthyear"": 1963,' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.7.点操作'}","page_content='RESTful API Legacy

6.Deprecated

6.7.点操作

**Example request.**  
```
• GET http://localhost:7070/db/{graph_name}/node/5/property
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""birthyear"": 1963,
""name"": ""Natasha Richardson""
}
```  
#### 6.7.7.获取点属性  
- **URI**: `/db/{graph_name}/node/{vertex_id}/property/{field}`
- **METHOD**: GET
- **RESPONSE**: Node 某一属性  
**Example request.**  
```' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.7.点操作'}",空,空,空,空,空,空,空
知识图谱的基本元素包括哪些？,空,空,空,空,空,空,空,空,空,空
TuGraph-DB是否支持存储过程？如果支持，那具体支持哪些编程语言的存储过程？,"page_content='RPC API

5.存储过程

为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。
用户可以使用RPC请求对存储过程进行增删改查操作。' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程'}","page_content='Procedure API

3.存储过程语言支持

在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。  
注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。' metadata={'Header 1': 'Procedure API', 'Header 2': '3.存储过程语言支持'}","page_content='功能概览

4.核心功能

4.2.存储过程

当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个
处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。  
从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。  
TuGraph 支持 POG (Procedres on Graph Query Languages) 编程和 POG 库，其中“Graph Query Languages”包含 Cypher 以及
制定中的 ISO GQL 等图查询语言。POG 库提供在查询语言中对用户定义的存储过程的访问，打破了查询语言和存储过程之间的界限，扩展了查询
语言的使用范围。  
> 这个文档描述了 [新的 Procedure 编程范式以及 POG](../9.olap&procedure/1.procedure/1.procedure.md)。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.2.存储过程'}","page_content='试用体验：TuGraph — 简单高效的图数据库

开放存储过程的使用

TuGraph支持存储过程的使用，让我感到非常满意。存储过程允许我在数据库中定义自己的逻辑和操作，以更高效地处理数据。我可以根据需求编写存储过程，并直接在图数据库中调用，这大大简化了我的开发流程。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '开放存储过程的使用'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}",空,空,空,空,空
GetEdgeProp操作的目的是什么？,空,空,空,空,空,空,空,空,空,空
TuGraph-DB的主要功能是什么？,"page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}","page_content='可视化操作手册（旧版）

作用

TuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '作用'}","page_content='功能概览

4.核心功能

4.5 数据预热

TuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.5 数据预热'}","page_content='功能概览

4.核心功能

4.4.备份恢复

TUGraph的备份在功能上可分为主动/定时、离线/在线、全量/增量备份，用尽量小的存储和计算代价来完成备份。恢复功能可以恢复到最新的状态，或者历史标注的时间点，需要保证数据库是一致的状态。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.4.备份恢复'}",空,空,空,空,空
当Cypher请求的响应不包含正确的结果时，会抛出什么异常？,"page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ std::string RpcClient::RpcSingleClient::GraphQueryResponseExtractor(const GraphQueryResponse&
                                                                    cypher) {
    switch (cypher.Result_case()) {
    case GraphQueryResponse::kJsonResult:
        {
            return cypher.json_result();
        }
    case GraphQueryResponse::kBinaryResult:
        {
#ifdef BINARY_RESULT_BUG_TO_BE_SOLVE
            return CypherResultExtractor(cypher.binary_result());
#endif
        }
    case GraphQueryResponse::RESULT_NOT_SET:
        LOG_ERROR() << ""GraphQueryResponse::RESULT_NOT_SET"";
        break;
    }
    //  Just to pass the compilation
    return """";
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='src/cypher/arithmetic/arithmetic_expression.cpp/ cypher::FieldData BuiltinFunction::ToInteger(RTContext *ctx, const Record &record,
                                             const std::vector<cypher::ArithExprNode> &args) {
    if (args.size() != 2) CYPHER_ARGUMENT_ERROR();
    auto operand = args[1];
    auto r = operand.Evaluate(ctx, record);
    switch (r.type) {
    case Entry::CONSTANT:
        if (r.constant.IsInteger()) {
            return r.constant;
        }
        if (r.constant.IsReal()) {
            return cypher::FieldData(
                lgraph::FieldData(static_cast<int64_t>(r.constant.scalar.real())));
        }
        if (r.constant.IsString()) {
            try {
                return cypher::FieldData(lgraph::FieldData(
                    static_cast<int64_t>(std::stoll(r.constant.scalar.string()))));
            } catch (std::exception &e) {
                LOG_WARN() << e.what();
                break;
            }
        }
    default:
        break;
    }
    CYPHER_ARGUMENT_ERROR();
}' metadata={'file_name': 'arithmetic_expression.cpp', 'file_path': 'src/cypher/arithmetic/arithmetic_expression.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/arithmetic_expression.cpp'}",空,空,空,空,空,空,空,空
2024年度功能更新预计何时推出对HA支持Witness角色和管理工具的功能？,"page_content='技术规划

3. 2024年功能更新

在2024年度，我们计划的功能更新包括：  
| 版本号   | 功能                 | 计划时间    |
|-------|--------------------|---------|
| 4.2.x | HA支持Witness角色和管理工具 | 2024.3  |
| 4.2.x | Bolt支持流处理和参数化查询    | 2024.3  |
| x.x.x | GeaX支持Cypher       | 2024.6  |
| x.x.x | 支持组合索引             | 2024.6  |
| x.x.x | 数据导入功能优化           | 2024.6  |
| x.x.x | 【社区功能】支持地理数据类型使用   | 2024.6  |
| x.x.x | Cypher能力提升         | 2024.9  |
| x.x.x | 支持Schema快速变更       | 2024.9  |
| x.x.x | 向量化支持              | 2024.12 |' metadata={'Header 1': '技术规划', 'Header 2': '3. 2024年功能更新'}",空,空,空,空,空,空,空,空,空
TuGraph-DB使用CMake作为编译工具，这意味着它支持C++17标准吗？,"page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='OlapBase API

2. 配置要求

如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：  
- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。
- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。' metadata={'Header 1': 'OlapBase API', 'Header 2': '2. 配置要求'}","page_content='TuGraph-db

3. 从源代码编译

建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile]  
以下是编译TuGraph的步骤：  
1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤
2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`
3. `make`
4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build' metadata={'Header 1': 'TuGraph-db', 'Header 2': '3. 从源代码编译'}","page_content='Python Olap API

2. 配置要求

如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：  
- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。
- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。
- Cython，版本要求3.0.0以上，已测试可运行版本为3.0.0a11' metadata={'Header 1': 'Python Olap API', 'Header 2': '2. 配置要求'}","page_content='Traversal API

1. 简介

TuGraph 强大的在线分析处理（OLAP）能力是其区别于其它图数据库的一个重要特性。
借助 C++ OLAP API（olap_on_db.h），用户可以快速地导出一个需要进行复杂分析的子图，然后在其上运行诸如 PageRank、连通分量、社区发现等迭代式图计算过程，最后根据结果做出相应决策。
导出和计算的过程都可以通过并行处理的方式进行加速，从而实现几乎实时的分析处理，避免了传统解决方案需要将数据导出、转换、再导入（ETL）到专门的分析系统进行离线处理的冗长步骤。  
TuGraph 内置了大量常用的图分析算法和丰富的辅助接口，因此用户几乎不需要自己来实现具体的图计算过程，只需在实现自己的存储过程时将相应算法库的头文件（.h 文件）包含到自己程序中，并在编译时链接相应的动态库文件（.so）即可。
一般情况下，用户需要自己实现的只有将需要分析的子图抽取出来的过程。  
目前 Traversal API 仅支持 C++。' metadata={'Header 1': 'Traversal API', 'Header 2': '1. 简介'}",空,空,空,空,空
Cython.cimports.libcpp.unordered_map是什么，它的具体用途是什么？,"page_content='procedures/algo_cython/lpa_standalone.py/ # cython: language_level=3, cpp_locals=True, boundscheck=False, wraparound=False, initializedcheck=False
# distutils: language = c++

import cython
from cython.cimports.olap_base import *
from cython.cimports.olap_on_disk import *
from cython.cimports.libc.stdio import printf
from cython.cimports.libcpp.unordered_map import unordered_map
from cython.operator import dereference as deref
from cython.operator import preincrement as inc
import time
import lgraph_db_python
import json' metadata={'file_name': 'lpa_standalone.py', 'file_path': 'procedures/algo_cython/lpa_standalone.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/procedures/algo_cython/lpa_standalone.py'}","page_content='Python Olap API

6. 算法插件示例

import json

import cython
from cython.cimports.olap_base import *
from cython.cimports.lgraph_db import *
# 从procedures/algo_cython/ 中cimportolap_base.pxd与lgraph_db.pxd, 类似C++中#include ""xxx.h""

from cython.cimports.libc.stdio import printf
# 类似C++中#include <stdio.h>
# 其他常见的还有cython.cimports.libcpp.unordered_map等

import time' metadata={'Header 1': 'Python Olap API', 'Header 2': '6. 算法插件示例'}","page_content='src/cypher/execution_plan/execution_plan.cpp/ ExecutionPlan::PreValidate(
    cypher::RTContext *ctx,
    const std::unordered_map<std::string, std::set<std::string>>& node,
    const std::unordered_map<std::string, std::set<std::string>>& edge) {
    if (node.empty() && edge.empty()) {
        return;
    }
    if (ctx->graph_.empty()) {
        return;
    }
    auto graph = ctx->galaxy_->OpenGraph(ctx->user_, ctx->graph_);
    auto txn = graph.CreateReadTxn();
    const auto& si = txn.GetSchemaInfo();
    for (const auto& pair : node) {
        auto s = si.v_schema_manager.GetSchema(pair.first);
        if (!s) {
            THROW_CODE(CypherException, ""No such vertex label: {}"", pair.first);
        }
        for (const auto& name : pair.second) {
            size_t fid;
            if (!s->TryGetFieldId(name, fid)) {
                THROW_CODE(CypherException, ""No such vertex property: {}.{}"", pair.first, name);
            }
        }
    }
    for (const auto& pair : edge) {
        auto s = si.e_schema_manager.GetSchema(pair.first);
        if (!s) {
            THROW_CODE(CypherException, ""No such edge label: {}"", pair.first);
        }
        for (const auto& name : pair.second) {
            size_t fid;
            if (!s->TryGetFieldId(name, fid)) {
                THROW_CODE(CypherException, ""No such edge property: {}.{}"", pair.first, name);
            }
        }
    }
    txn.Abort();
}

void' metadata={'file_name': 'execution_plan.cpp', 'file_path': 'src/cypher/execution_plan/execution_plan.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/execution_plan.cpp'}","page_content='demo/MultithreadClient/client.cpp/ #include ""client.h""
#include ""load_plugin.h""
#include ""cypher_sender.h""
#include ""plugin_sender.h""
#include ""delete_plugin.h""
#include <functional>
#include <unordered_map>

static const std::unordered_map<std::string, std::function<void(multithread_client::Client*)>> sRouter = {
        {""callcypher"", std::bind(&multithread_client::Client::call_cypher, std::placeholders::_1)},
        {""loadplugin"", std::bind(&multithread_client::Client::load_plugin, std::placeholders::_1)},
        {""callplugin"", std::bind(&multithread_client::Client::call_plugin, std::placeholders::_1)},
        {""deleteplugin"", std::bind(&multithread_client::Client::delete_plugin, std::placeholders::_1)},
};

namespace multithread_client {

    void Client::call_cypher() {
        std::shared_ptr<CypherSender> cs = std::make_shared<CypherSender>(config);
        cs->process();
    }

    void Client::load_plugin() {
        std::shared_ptr<LoadPlugin> lp = std::make_shared<LoadPlugin>(config);
        lp->process();
    }

    void Client::call_plugin() {
        std::shared_ptr<PluginSender> ps = std::make_shared<PluginSender>(config);
        ps->process();
    }

    void Client::delete_plugin() {
        std::shared_ptr<DeletePlugin> ds = std::make_shared<DeletePlugin>(config);
        ds->process();
    }

    void Client::process() {
        auto it = sRouter.find(config.mode);
        if (it == sRouter.end()) return;
        auto func = it->second;
        func(this);
    }

}' metadata={'file_name': 'client.cpp', 'file_path': 'demo/MultithreadClient/client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/MultithreadClient/client.cpp'}","page_content='src/bolt/hydrator.cpp/ {
const char* containsSystemUpdatesKey = ""contains-system-updates"";
const char* containsUpdatesKey = ""contains-updates"";

std::unordered_map<std::string, int>  ExtractIntCounters(
    std::unordered_map<std::string, std::any> counters) {
    std::unordered_map<std::string, int> result;
    for (auto& pair : counters) {
        if (pair.first != containsSystemUpdatesKey && pair.first != containsUpdatesKey) {
            result[pair.first] = std::any_cast<int>(pair.second);
        }
    }
    return result;
}
std::optional<bool> ExtractBoolPointer(std::unordered_map<std::string, std::any> counters,
                                       const std::string& key) {
    auto iter = counters.find(key);
    if (iter == counters.end()) {
        return std::nullopt;
    }
    return std::any_cast<std::optional<bool>>(iter->second);
}

void Hydrator::SetErr(const std::string& err) {
    if (!err_) {
        err_ = err;
    }
}

void Hydrator::ClearErr() {
    err_.reset();
}

void Hydrator::UseUtc(bool use) {
    useUtc_ = use;
}

const std::optional<std::string>& Hydrator::GetErr() {
    if (unp_->Err()) {
        return unp_->Err();
    }
    return err_;
}

void Hydrator::AssertLength(const std::string& structType, uint32_t expected, uint32_t actual) {
    if (expected != actual) {
        SetErr(FMA_FMT(""Invalid length of struct, expected {} but was {}"", expected, actual));
    }
}

// Hydrate hydrates a top-level struct message' metadata={'file_name': 'hydrator.cpp', 'file_path': 'src/bolt/hydrator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/bolt/hydrator.cpp'}",空,空,空,空,空
TuGraph 数据预热命令需要指定哪两个选项？,"page_content='数据预热

1.数据预热命令

数据预热可以通过工具 `lgraph_warmup` 来进行。它的使用示例如下：  
```bash
$ lgraph_warmup -d {directory} -g {graph_list}
```  
其中：  
- `-d {db_dir}` 选项指定了 TuGraph 服务器的数据目录  
- `-g {graph_list}` 选项指定需要进行数据预热的图名称，用逗号分隔  
根据数据大小和所使用的磁盘类型不同，预热过程运行时间也不同。机械磁盘上预热一个大数据库可能耗时较长，请耐心等待。' metadata={'Header 1': '数据预热', 'Header 2': '1.数据预热命令'}","page_content='数据库运行

4.服务配置

TuGraph 服务器在启动时从配置文件和命令行选项加载配置，如果在配置文件和命令行中同一选项指定了不同的值，将优先使用命令行中指定的值。' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置'}","page_content='数据导入

4.离线全量导入

离线模式只能在离线状态的服务器使用。离线导入会创建一张新图，因此更适合新安装的 TuGraph 服务器上的第一次数据导入。
要在离线模式下使用`lgraph_import`工具，可以指定`lgraph_import --online false`选项。要了解可用的命令行选项，请使用`lgraph_import --online false --help`：  
```shell
$ ./lgraph_import --online false -help
Available command line options:
--log               Log file to use, empty means stderr. Default="""".
-v, --verbose       Verbose level to use, higher means more verbose.
Default=1.
...
-h, --help          Print this help message. Default=0.
```' metadata={'Header 1': '数据导入', 'Header 2': '4.离线全量导入'}","page_content='功能概览

4.核心功能

4.5 数据预热

TuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.5 数据预热'}",空,空,空,空,空,空
TuGraph是否支持GQL语句？,"page_content='ISO GQL

1.GQL简介

Graph Query Language(GQL, 图查询语言)是一种国际标准语言，用于属性图查询，该语言建立在SQL的基础上，并整合了现有的[openCypher、PGQL、GSQL和G-CORE](https://gql.today/comparing-cypher-pgql-and-g-core/)语言的成熟思想。目前该标准仍然处于草稿阶段。  
TuGraph基于[ISO GQL (ISO/IEC 39075) Antlr4 语法文件](https://github.com/TuGraph-family/gql-grammar)实现了GQL，并做了一些扩展与改造。目前并未完全支持所有的GQL语法，我们会在未来逐步完善。' metadata={'Header 1': 'ISO GQL', 'Header 2': '1.GQL简介'}","page_content='Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！

当 TuGraph 遇见 Antlr4

ISO GQL（ISO/IEC 39075）是一种标准化的图数据库查询语言，蚂蚁集团是其主要贡献者之一。因此，Antlr4 作为一种强大的解析器生成器，成为了蚂蚁图数据库 TuGraph 生成 GQL 解释器的理想选择。Antlr4 能够帮助团队更快、更准确地构建图数据库的查询语言，从而提高产品性能和用户体验。  
然而，当我们从开发场景来到生产场景，超高的并发量带来一个严重问题：Antlr4 C++ target 的并发性能不足以支持所需的超高并发 GQL 请求。经过调研并与 Antlr 开源社区讨论，我们发现\*\*并发性能这个问题普遍存在，并且在过去 5 年中持续困扰着 C++生态的开发者。\*\*我们决定解决这个问题。' metadata={'Header 1': 'Antlr4 社区重大贡献：TuGraph 优化 C++ Target 并发性能提升 10 倍！', 'Header 2': '当 TuGraph 遇见 Antlr4'}","page_content='功能概览

4.核心功能

4.2.存储过程

当用户需要表达的查询/更新逻辑较为复杂（例如 Cypher 无法描述，或是对性能要求较高）时，相比调用多个 REST 请求并在客户端完成整个
处理流程的方式，TuGraph 提供的存储过程（Procedure）是更简洁和高效的选择。  
从 3.5 版本开始，TuGraph 重新设计了新的存储过程编程范式，支持定义标准的签名和结果，支持POG编程。  
TuGraph 支持 POG (Procedres on Graph Query Languages) 编程和 POG 库，其中“Graph Query Languages”包含 Cypher 以及
制定中的 ISO GQL 等图查询语言。POG 库提供在查询语言中对用户定义的存储过程的访问，打破了查询语言和存储过程之间的界限，扩展了查询
语言的使用范围。  
> 这个文档描述了 [新的 Procedure 编程范式以及 POG](../9.olap&procedure/1.procedure/1.procedure.md)。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.2.存储过程'}","page_content='技术规划

2. 已完成功能

| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}","page_content='技术规划

2. 已完成功能

| 3.4.0 | 支持OLAP Python API, 离线导入升级        | 2023.3.11  |
| 3.5.0 | 支持POG，前端升级，文档梳理                  | 2023.6.5   |
| 3.5.1 | 图学习引擎，Procedure Rust API，存储属性分离  | 2023.7.14  |
| 3.6.0 | 高可用开源，日志系统升级                     | 2023.8.11  |
| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}",空,空,空,空,空
“log4j-core”和“guava”的版本号分别是多少？,空,空,空,空,空,空,空,空,空,空
类liblgraph_python_api.Galaxy的方法SetUserGraphAccess主要用于什么功能？,"page_content='src/python/python_api.cpp/ SetUserGraphAccess"", &Galaxy::SetUserGraphAccess,
             ""Set the access level of the specified user on the graph.\n""
             ""user: name of the user\n""
             ""graph: name of the graph\n""
             ""access: access level of the user on that graph"",
             pybind11::arg(""user""), pybind11::arg(""graph""), pybind11::arg(""access""),
             pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/lgraph_api/c.cpp/ bool lgraph_api_galaxy_set_user_graph_access(lgraph_api_galaxy_t* galaxy, const char* user,
                                             const char* graph, int access, char** errptr) {
    try {
        return galaxy->repr.SetUserGraphAccess(user, graph, static_cast<AccessLevel>(access));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_galaxy_disable_user(lgraph_api_galaxy_t* galaxy, const char* user, char** errptr) {
    try {
        return galaxy->repr.DisableUser(user);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_galaxy_enable_user(lgraph_api_galaxy_t* galaxy, const char* user, char** errptr) {
    try {
        return galaxy->repr.EnableUser(user);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/lgraph_galaxy.cpp/ bool lgraph_api::Galaxy::SetRoleAccessRightsIncremental(
    const std::string& role, const std::map<std::string, AccessLevel>& graph_access) {
    CHECK_DB_AND_USER();
    lgraph::ModRoleRequest req;
    req.set_role(role);
    auto* access = req.mutable_set_diff_graph_access()->mutable_values();
    for (auto& kv : graph_access)
        (*access)[kv.first] = static_cast<lgraph::ProtoAccessLevel>(kv.second);
    return db_->ModRole(user_, req);
}

static inline lgraph_api::RoleInfo Convert(const lgraph::AclManager::RoleInfo& info) {
    lgraph_api::RoleInfo ret;
    ret.desc = info.desc;
    ret.disabled = info.disabled;
    ret.graph_access.insert(info.graph_access.begin(), info.graph_access.end());
    return ret;
}

lgraph_api::RoleInfo lgraph_api::Galaxy::GetRoleInfo(const std::string& role) const {
    CHECK_DB_AND_USER();
    return Convert(db_->GetRoleInfo(user_, role));
}

std::map<std::string, lgraph_api::RoleInfo> lgraph_api::Galaxy::ListRoles() const {
    CHECK_DB_AND_USER();
    auto roles = db_->ListRoles(user_);
    std::map<std::string, lgraph_api::RoleInfo> ret;
    for (auto& kv : roles) {
        ret.emplace_hint(ret.end(), kv.first, Convert(kv.second));
    }
    return ret;
}

lgraph_api::AccessLevel lgraph_api::Galaxy::GetAccessLevel(const std::string& user,
                                                           const std::string& graph) const {
    CHECK_DB_AND_USER();
    return db_->GetAcl(user_, user, graph);
}' metadata={'file_name': 'lgraph_galaxy.cpp', 'file_path': 'src/lgraph_api/lgraph_galaxy.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_galaxy.cpp'}","page_content='src/lgraph_api/lgraph_galaxy.cpp/ bool lgraph_api::Galaxy::SetPassword(const std::string& name, const std::string& old_password,
                                     const std::string& new_password) {
    CHECK_DB_AND_USER();
    lgraph::ModUserRequest req;
    req.set_user(name);
    auto* mod_pass = req.mutable_set_password();
    mod_pass->set_old_pass(old_password);
    mod_pass->set_new_pass(new_password);
    return db_->ModUser(user_, req);
}

bool lgraph_api::Galaxy::SetUserDesc(const std::string& user, const std::string& desc) {
    CHECK_DB_AND_USER();
    lgraph::ModUserRequest req;
    req.set_user(user);
    req.set_set_desc(desc);
    return db_->ModUser(user_, req);
}

bool lgraph_api::Galaxy::SetUserRoles(const std::string& name,
                                      const std::vector<std::string>& roles) {
    CHECK_DB_AND_USER();
    lgraph::ModUserRequest req;
    req.set_user(name);
    auto* set_roles = req.mutable_set_roles()->mutable_values();
    for (auto& r : roles) set_roles->Add()->assign(r);
    return db_->ModUser(user_, req);
}

bool lgraph_api::Galaxy::SetUserGraphAccess(const std::string& user, const std::string& graph,
                                            const AccessLevel& access) {
    CHECK_DB_AND_USER();
    lgraph::ModRoleRequest req;
    req.set_role(user);
    (*req.mutable_set_diff_graph_access()->mutable_values())[graph] =
        static_cast<lgraph::ProtoAccessLevel>(access);
    return db_->ModRole(user_, req);
}' metadata={'file_name': 'lgraph_galaxy.cpp', 'file_path': 'src/lgraph_api/lgraph_galaxy.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_galaxy.cpp'}","page_content='src/python/python_api.cpp/ galaxy.def(""SetUser"", &Galaxy::SetUser,
               ""Validate the given user and set current user given in the user."",
               pybind11::arg(""user""),
               pybind11::call_guard<SignalsGuard>());' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}",空,空,空,空,空
如何在运行单元测试的过程中在TuGraph-DB中输出日志？,"page_content='数据库运行

2.运行模式

2.1.运行普通进程

`lgraph_server -d run`命令可以将 TuGraph 作为普通进程运行。普通进程依赖命令行终端，因此终端结束时，TuGraph 进程也会自动终止。普通进程模式配合`--log_dir """"`可以将进程日志直接输出到终端，因此更方便调试。注：当不使用`-d run`命令时，将默认运行普通进程。  
lgraph_server的默认路径为：/usr/local/bin/lgraph_server 。  
lgraph.json的默认路径为：/usr/local/etc/lgraph.json 。  
启动命令：  
```shell
$ ./lgraph_server -d run -c lgraph.json --log_dir """"
```
或者：
```shell
$ ./lgraph_server -c lgraph.json --log_dir """"
```  
普通模式的运行输出示例：  
```shell' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.1.运行普通进程'}","page_content='日志信息

2.服务器日志

2.3.存储过程日志

extern ""C"" bool Process(GraphDB& db, const std::string& request, std::string& response) {
response = ""TuGraph log demo"";
LogExample();
return true;
}
```
将以上示例代码作为存储过程插入数据库并运行后，可以在日志文件中看到相应的日志条目。  
#### 2.3.1.python存储过程
请使用python自带的print输出调试信息，调试信息会在存储过程运行结束后合并为一条WARN等级的日志条目输出至日志文件中。' metadata={'Header 1': '日志信息', 'Header 2': '2.服务器日志', 'Header 3': '2.3.存储过程日志'}","page_content='数据库运行

2.运行模式

2.2.运行进程守护模式

启动命令：  
```shell
$ ./lgraph_server -d start -c lgraph.json
```  
守护模式的运行输出示例：  
```shell
Starting lgraph...
The service process is started at pid 12109.
```  
此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.2.运行进程守护模式'}","page_content='数据库运行

2.运行模式

2.1.运行普通进程

lgraph.json的默认路径为：/usr/local/etc/lgraph.json 。  
启动命令：  
```shell
$ ./lgraph_server -d run -c lgraph.json --log_dir """"
```
或者：
```shell
$ ./lgraph_server -c lgraph.json --log_dir """"
```  
普通模式的运行输出示例：  
```shell
**********************************************************************
*                  TuGraph Graph Database v4.3.2                     *
*                                                                    *' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.1.运行普通进程'}","page_content='数据库运行

3.服务操作

3.1.启动服务

TuGraph 需要通过 `lgraph_server -d start` 命令行启动，启动命令示例如下：  
```bash
$ ./lgraph_server -d start -c lgraph.json
Starting lgraph...
The service process is started at pid 12109.
```  
此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.1.启动服务'}",空,空,空,空,空
"在GeaBase查询中，使用""Nav""语句的一种情况是什么？",空,空,空,空,空,空,空,空,空,空
如何通过pair unique索引快速定位到两个顶点间的某条关系边，并使用该索引更新对应的边数据？,"page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

但是，不同于unique索引，超过475bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前475bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前475bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
##### 1.3.1.2 边索引  
###### 1.3.1.2.1 unique索引  
和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。  
###### 1.3.1.2.2 pair_unique索引  
pair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的边的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。  
###### 1.3.1.2.2 pair_unique索引  
pair_unique索引指的是两点间的唯一索引，即若一个属性设置了unique索引，在同一个图的同一组起点和终点之间，
相同label的边的该属性不会存在相同的值。为了保证pair_unique索引key在同一组起点和终点之间不重复，
索引在用户指定的key后面加上了起点和终点的vid，每个vid是5bytes长度。
因此最大key的长度是470bytes，**超过470bytes的属性不能建立pair_unique索引**。  
###### 1.3.1.2.3 non_unique索引  
和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

unique索引是全局唯一的，该索引key的最大长度是480bytes。primary作为特殊的unique索引，因此最大key的长度也是480bytes，超过无法建立索引。
##### 3.1.2.2.pair_unique索引
pair_unique索引是指两点间唯一的索引，这种类型的索引只能创建于边的schema中，这种索引在用户指定的key后面加上了源点和目标点的vid，每个vid是5bytes长度。因此最大key的长度是470bytes，超过无法建立索引。
##### 3.1.2.3.非唯一索引
非唯一索引是指既没有设置unique为1，也没有设置pair_unique为1的索引，在TuGraph的实现中，此类索引一个key可能映射到多个值，为了加速查找和写入，在用户指定的key后面加上了一组vid或euid中的最大值。其中对于创建于点中的非唯一索引，key后面跟着vid，每个vid是5bytes长度，因此最大长度是475bytes。' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

- [property]
- SRC_ID (仅边配置，值是起始点标签)
- DST_ID (仅边配置，值是目的点标签)  
#### 3.1.2.索引长度
因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。
##### 3.1.2.1.unique索引
unique索引是全局唯一的，该索引key的最大长度是480bytes。primary作为特殊的unique索引，因此最大key的长度也是480bytes，超过无法建立索引。
##### 3.1.2.2.pair_unique索引
pair_unique索引是指两点间唯一的索引，这种类型的索引只能创建于边的schema中，这种索引在用户指定的key后面加上了源点和目标点的vid，每个vid是5bytes长度。因此最大key的长度是470bytes，超过无法建立索引。' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}",空,空,空,空,空,空
TuGraph Explorer 的功能现在可以在哪里找到？,"page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.4.2 权限管理  
- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/18.tugraph-browser-auth.png)  
##### 3.4.3 实时状态  
- 这里展示了数据库实时状态，包括：CPU 使用率、内存用率、磁盘使用率、数据请求次数、磁盘 IO
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/19.tugraph-browser-status.png)  
##### 3.4.4 任务管理  
- 在这里用户可以看到在正在执行中的任务，可以在此进行停止任务的操作' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.3.6 帮助  
- 其中记录了 TuGraph-browser 的使用方式
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)  
#### 3.4 控制台  
##### 3.4.1 数据库基础信息  
- 展示数据库相关的基础配置信息
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/17.tugraph-browser-config.png)  
##### 3.4.2 权限管理  
- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}","page_content='功能概览

6.生态工具

6.2.可视化交互

TuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.2.可视化交互'}","page_content='可视化操作手册（旧版）

作用

TuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '作用'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.3.5 插件  
- 存储过程的使用  
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/15.tugraph-browser-plugin.png)  
- 用户可以上传本地编写的 Plugin 程序，并在可视化页面进行执行，并查看执行结果
- 用户可以在可视化对插件进行、卸载、执行、下载等操作  
##### 3.3.6 帮助  
- 其中记录了 TuGraph-browser 的使用方式
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)  
#### 3.4 控制台  
##### 3.4.1 数据库基础信息  
- 展示数据库相关的基础配置信息' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}",空,空,空,空,空
SybilRank算法的执行过程中主要采用什么数学或计算方法来进行节点的评分计算？,空,空,空,空,空,空,空,空,空,空
节点和边的属性在知识图谱中有什么作用？,"page_content='Heterogeneous Graph

1. 异质图简介

异质图（Heterogeneous Graph）是指由不同类型的节点和边构成的图结构。在异质图中，节点和边可以具有多样化的属性和关系，代表了不同实体以及它们之间的复杂关联。  
在异质图中，节点类型可以代表不同的实体，如用户、商品、话题等，而边类型表示不同实体之间的关系，如用户之间的关注关系、用户与商品之间的购买关系等。节点和边可以具有不同的属性。  
异质图提供了一种强大的图模型，能够更好地表达和分析具有多种类型实体和复杂关系的现实世界系统。在不同领域的数据分析和应用中，异质图具有广泛的应用前景和研究价值。' metadata={'Header 1': 'Heterogeneous Graph', 'Header 2': '1. 异质图简介'}",空,空,空,空,空,空,空,空,空
在TuGraph项目中，为什么在提交代码之前需要先提交一个issue？,"page_content='如何贡献

4. 贡献代码流程

4.1. 提交issue

不论您是修复 TuGraph 的 bug 还是新增 TuGraph 的功能，在您提交代码之前，请在 TuGraph 的 GitHub 上提交一个 issue，描述您要修复的问题或者要增加的功能。这么做有几个好处:  
- 不会与其它开发者或是他们对这个项目的计划发生冲突，产生重复工作。
- TuGraph 的维护人员会对您提的 bug 或者新增功能进行相关讨论，确定该修改是不是必要，有没有提升的空间或更好的办法。
- 在达成一致后再开发，并提交代码，减少双方沟通成本，也减少 pull request 被拒绝的情况。' metadata={'Header 1': '如何贡献', 'Header 2': '4. 贡献代码流程', 'Header 3': '4.1. 提交issue'}","page_content='如何贡献

4. 贡献代码流程

4.2. 获取源码

要修改或新增功能，在提交 issue 后，fork一份 TuGraph  Master代码到您的代码仓库。' metadata={'Header 1': '如何贡献', 'Header 2': '4. 贡献代码流程', 'Header 3': '4.2. 获取源码'}",空,空,空,空,空,空,空,空
社区版本和企业版本之间的差距在哪里？,空,空,空,空,空,空,空,空,空,空
bfs_standalone程序的输出结果是什么？,"page_content='OLAP API

4. Standalone 编译与运行

C++:

在tugraph-db/build编译standalone算法程序  
```bash
make bfs_standalone
```  
在tugraph-db/build/output目录下运行text源文件  
```bash
./output/algo/bfs_standalone --type text --input_dir ../test/integration/data/algo/fb_unweighted --root 0
```  
得到运行结果：  
```text
prepare_cost = 0.10(s)
core_cost = 0.02(s)
found_vertices = 3829
output_cost = 0.00(s)
total_cost = 0.11(s)
DONE.
```  
结果参数解释同上。  
对于新的算法，运行时不了解该算法的所需参数时，可通过`./output/algo/bfs_standalone -h`进行查阅对应参数。' metadata={'Header 1': 'OLAP API', 'Header 2': '4. Standalone 编译与运行', 'Header 3': 'C++:'}","page_content='OLAP API

4. Standalone 编译与运行

该文件主要用于在终端处直接加载图数据，并运行打印输出结果。使用方法如下：
在tugraph-db/build目录下执行`make bfs_standalone` (需要在g++默认include路径中包含boost/sort/sort.hpp)即可得到bfs_standalone文件,该文件生成于tugraph-db/build/output/algo文件夹下。
运行方式：在tugraph-db/build目录下执行`./output/algo/bfs_standalone -–type [type] –-input_dir [input_dir] --id_mapping [id_mapping] -–vertices [vertices] --root [root] –-output_dir [output_dir]`即可运行。  
- `[type]`：表示输入图文件的类型来源，包含text文本文件、BINARY_FILE二进制文件和ODPS源。' metadata={'Header 1': 'OLAP API', 'Header 2': '4. Standalone 编译与运行'}",空,空,空,空,空,空,空,空
当Key_start和key_end都等于v时，VertexIndexIterator是如何工作的？,"page_content='src/python/python_api.cpp/ ""GetVertexIndexIterator"",
            [](Transaction& a, const std::string& label, const std::string& field,
               const std::string& key_start, const std::string& key_end) {
                return a.GetVertexIndexIterator(label, field, key_start, key_end);
            },
            ""Gets an VertexIndexIterator pointing to the indexed item which has index ""
            ""value [key_start, key_end].\n""
            ""key_start=key_end=v returns an iterator pointing to all vertexes ""
            ""that has field value v."",
            ""label_name specifies the name of the indexed label.\n""
            ""field_id specifies the name of the indexed field.\n""
            ""key_start_string is the string representation of the minimum ""
            ""indexed value.\n""
            ""key_end_string is the string representation of the maximum indexed ""
            ""value."",
            pybind11::arg(""label_name""), pybind11::arg(""field_name""),
            pybind11::arg(""key_start_string""), pybind11::arg(""key_end_string""),
            pybind11::return_value_policy::move,
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""GetVertexIndexIterator"",
            [](Transaction& a, const std::string& label, const std::string& field,
               const FieldData& key_start, const FieldData& key_end) {
                return a.GetVertexIndexIterator(label, field, key_start, key_end);
            },
            ""Gets an VertexIndexIterator pointing to the indexed item which has index ""
            ""value [key_start, key_end].\n""
            ""key_start=key_end=v returns an iterator pointing to all vertexes ""
            ""that has field value v."",
            ""label_name specifies the name of the indexed label.\n""
            ""field_id specifies the name of the indexed field.\n""
            ""key_start is a FieldData containing the minimum indexed value.\n""
            ""key_end is a FieldData containing the maximum indexed value."",
            pybind11::arg(""label_name""), pybind11::arg(""field_name""), pybind11::arg(""key_start""),
            pybind11::arg(""key_end""), pybind11::return_value_policy::move,
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""GetVertexIndexIterator"",
            [](Transaction& a, size_t label_id, size_t field_id, const FieldData& key_start,
               const FieldData& key_end) {
                return a.GetVertexIndexIterator(label_id, field_id, key_start, key_end);
            },
            ""Gets an VertexIndexIterator pointing to the indexed item which has index ""
            ""value [key_start, key_end].\n""
            ""key_start=key_end=v returns an iterator pointing to all vertexes ""
            ""that has field value v.\n""
            ""label_id specifies the id of the indexed label.\n""
            ""field_id specifies the id of the indexed field.\n""
            ""key_start is a FieldData containing the minimum indexed value.\n""
            ""key_end is a FieldData containing the maximum indexed value."",
            pybind11::arg(""label_id""), pybind11::arg(""field_id""), pybind11::arg(""key_start""),
            pybind11::arg(""key_end""), pybind11::return_value_policy::move,
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/core/vertex_index.cpp/ VertexIndexIterator::VertexIndexIterator(VertexIndex* idx, Transaction* txn, KvTable& table,
                                         const Value& key_start, const Value& key_end, VertexId vid,
                                         IndexType type)
    : IteratorBase(txn),
      index_(idx),
      it_(table.GetClosestIterator(txn->GetTxn(), type == IndexType::GlobalUniqueIndex
                                                      ? key_start
                                                      : _detail::PatchKeyWithVid(key_start, vid))),
      key_end_(type == IndexType::GlobalUniqueIndex ? Value::MakeCopy(key_end)
                                                    : _detail::PatchKeyWithVid(key_end, -1)),
      iv_(),
      valid_(false),
      pos_(0),
      type_(type) {
    if (type == IndexType::PairUniqueIndex) {
        return;
    }
    if (!it_->IsValid() || KeyOutOfRange()) {
        return;
    }
    LoadContentFromIt();
}' metadata={'file_name': 'vertex_index.cpp', 'file_path': 'src/core/vertex_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/vertex_index.cpp'}","page_content='src/core/vertex_index.cpp/ VertexIndexIterator::VertexIndexIterator(VertexIndex* idx, KvTransaction* txn, KvTable& table,
                                         const Value& key_start, const Value& key_end, VertexId vid,
                                         IndexType type)
    : IteratorBase(nullptr),
      index_(idx),
      it_(table.GetClosestIterator(*txn, type == IndexType::GlobalUniqueIndex
                                             ? key_start
                                             : _detail::PatchKeyWithVid(key_start, vid))),
      key_end_(type == IndexType::GlobalUniqueIndex ? Value::MakeCopy(key_end)
                                                    : _detail::PatchKeyWithVid(key_end, -1)),
      iv_(),
      valid_(false),
      pos_(0),
      type_(type) {
    if (type == IndexType::PairUniqueIndex) {
        return;
    }
    if (!it_->IsValid() || KeyOutOfRange()) {
        return;
    }

    LoadContentFromIt();
}

VertexIndexIterator::VertexIndexIterator(VertexIndexIterator&& rhs)
    : IteratorBase(std::move(rhs)),
      index_(rhs.index_),
      it_(std::move(rhs.it_)),
      key_end_(std::move(rhs.key_end_)),
      curr_key_(std::move(rhs.curr_key_)),
      iv_(std::move(rhs.iv_)),
      valid_(rhs.valid_),
      pos_(rhs.pos_),
      vid_(rhs.vid_),
      type_(rhs.type_) {
    rhs.valid_ = false;
}' metadata={'file_name': 'vertex_index.cpp', 'file_path': 'src/core/vertex_index.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/vertex_index.cpp'}",空,空,空,空,空
如何将顶点数据写入图数据库中？,"page_content='使用 TuGraph 图学习模块进行点分类

6. 模型训练及保存

6.2.构建采样器

训练过程中，首先使用GetDB算子从数据库中获取图数据并转换成所需数据结构，具体代码如下：
```python
GetDB.Process(db_: lgraph_db_python.PyGraphDB, olapondb: lgraph_db_python.PyOlapOnDB, feature_num: size_t, NodeInfo: list, EdgeInfo: list)
```
如代码所示，结果存储在NodeInfo和EdgeInfo中。NodeInfo和EdgeInfo是python list结果，其存储的信息结果如下：  
| 图数据 | 存储信息位置 |
| --- | --- |
| 边起点 | EdgeInfo[0] |
| 边终点 | EdgeInfo[1] |
| 顶点ID | NodeInfo[0] |
| 顶点特征 | NodeInfo[1] |
| 顶点标签 | NodeInfo[2] |  
然后构建采样器
```python
batch_size = 5
count = 2708' metadata={'Header 1': '使用 TuGraph 图学习模块进行点分类', 'Header 2': '6. 模型训练及保存', 'Header 3': '6.2.构建采样器'}",空,空,空,空,空,空,空,空,空
lgraph_api::Transaction的作用是什么？,"page_content='src/lgraph_api/c.cpp/ lgraph_api_edge_index_iterator_t* lgraph_api_transaction_get_edge_index_iterator_by_data(
    lgraph_api_transaction_t* txn, const char* label, const char* field,
    const lgraph_api_field_data_t* key_start, const lgraph_api_field_data_t* key_end,
    char** errptr) {
    try {
        return new lgraph_api_edge_index_iterator_t{
            txn->repr.GetEdgeIndexIterator(label, field, key_start->repr, key_end->repr)};
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return nullptr;
    }
}

lgraph_api_vertex_index_iterator_t*
lgraph_api_transaction_get_vertex_index_iterator_by_value_string(
    lgraph_api_transaction_t* txn, const char* label, const char* field, const char* key_start,
    const char* key_end, char** errptr) {
    try {
        return new lgraph_api_vertex_index_iterator_t{
            txn->repr.GetVertexIndexIterator(label, field, key_start, key_end)};
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return nullptr;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ bool lgraph_api_transaction_upsert_edge_with_value_strings(
    lgraph_api_transaction_t* txn, int64_t src, int64_t dst, const char* label,
    const char** field_names, size_t field_names_size, const char** field_value_strings,
    size_t field_value_strings_size, char** errptr) {
    try {
        std::vector<std::string> name_vec(field_names, field_names + field_names_size);
        std::vector<std::string> value_vec(field_value_strings,
                                           field_value_strings + field_value_strings_size);
        return txn->repr.UpsertEdge(src, dst, label, name_vec, value_vec);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_transaction_upsert_edge_with_field_data(
    lgraph_api_transaction_t* txn, int64_t src, int64_t dst, const char* label,
    const char* const* field_names, size_t field_names_size,
    const lgraph_api_field_data_t* const* field_values, size_t field_values_size, char** errptr) {
    try {
        std::vector<std::string> name_vec(field_names, field_names + field_names_size);
        return txn->repr.UpsertEdge(
            src, dst, label, name_vec,
            lgraph_api_field_data_array_to_field_data_vec(field_values, field_values_size));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ uint16_t lgraph_api_edge_index_iterator_get_label_id(lgraph_api_edge_index_iterator_t* iter,
                                                     char** errptr) {
    try {
        return iter->repr.GetLabelId();
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return 0;
    }
}

int64_t lgraph_api_edge_index_iterator_get_edge_id(lgraph_api_edge_index_iterator_t* iter,
                                                   char** errptr) {
    try {
        return iter->repr.GetEdgeId();
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return 0;
    }
}

void lgraph_api_transaction_destroy(lgraph_api_transaction_t* txn) { delete txn; }
void lgraph_api_transaction_commit(lgraph_api_transaction_t* txn, char** errptr) {
    try {
        txn->repr.Commit();
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
}
void lgraph_api_transaction_abort(lgraph_api_transaction_t* txn, char** errptr) {
    try {
        txn->repr.Abort();
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
}
bool lgraph_api_transaction_is_valid(lgraph_api_transaction_t* txn) { return txn->repr.IsValid(); }
bool lgraph_api_transaction_is_read_only(lgraph_api_transaction_t* txn) {
    return txn->repr.IsReadOnly();
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ lgraph_api_out_edge_iterator_t* lgraph_api_transaction_get_edge_by_unique_index_with_data(
    lgraph_api_transaction_t* txn, const char* label_name, const char* field_name,
    const lgraph_api_field_data_t* field_value, char** errptr) {
    try {
        return new lgraph_api_out_edge_iterator_t{
            txn->repr.GetEdgeByUniqueIndex(label_name, field_name, field_value->repr)};
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return nullptr;
    }
}

lgraph_api_vertex_iterator_t* lgraph_api_transaction_get_vertex_by_unique_index_with_id(
    lgraph_api_transaction_t* txn, size_t label_id, size_t field_id,
    const lgraph_api_field_data_t* field_value, char** errptr) {
    try {
        return new lgraph_api_vertex_iterator_t{
            txn->repr.GetVertexByUniqueIndex(label_id, field_id, field_value->repr)};
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return nullptr;
    }
}

lgraph_api_out_edge_iterator_t* lgraph_api_transaction_get_edge_by_unique_index_with_id(
    lgraph_api_transaction_t* txn, size_t label_id, size_t field_id,
    const lgraph_api_field_data_t* field_value, char** errptr) {
    try {
        return new lgraph_api_out_edge_iterator_t{
            txn->repr.GetEdgeByUniqueIndex(label_id, field_id, field_value->repr)};
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return nullptr;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ int64_t lgraph_api_transaction_add_vertex_with_field_data(
    lgraph_api_transaction_t* txn, const char* label_name, const char* const* field_names,
    size_t field_names_size, const lgraph_api_field_data_t* const* field_values,
    size_t field_values_size, char** errptr) {
    try {
        std::vector<std::string> name_vec(field_names, field_names + field_names_size);
        return txn->repr.AddVertex(
            label_name, name_vec,
            lgraph_api_field_data_array_to_field_data_vec(field_values, field_values_size));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return -1;
    }
}
int64_t lgraph_api_transaction_add_vertex_with_field_data_and_id(
    lgraph_api_transaction_t* txn, size_t label_id, const size_t* field_ids, size_t field_ids_size,
    const lgraph_api_field_data_t* const* field_values, size_t field_values_size, char** errptr) {
    try {
        std::vector<size_t> ids_vec(field_ids, field_ids + field_ids_size);
        return txn->repr.AddVertex(
            label_id, ids_vec,
            lgraph_api_field_data_array_to_field_data_vec(field_values, field_values_size));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return -1;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}",空,空,空,空,空
在执行`ProcessVertexActive`函数时，如果运行时出现错误，会引发什么异常？,空,空,空,空,空,空,空,空,空,空
在调用存储过程时，如果指定json_format参数为false，返回结果的格式是什么？,"page_content='C++客户端

2.使用示例

2.6.调用存储过程

interrupted.
@param [in]  in_process          (Optional) support in future.
@param [in]  graph               (Optional) the graph to query.
@param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,
binary format.
@param [in]  url                 (Optional) Node address of calling procedure.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}","page_content='C++客户端

2.使用示例

2.6.调用存储过程

binary format.
@param [in]  url                 (Optional) Node address of calling procedure.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。
其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}","page_content='C++客户端

2.使用示例

2.7.向leader调用存储过程

@param [in]  procedure_time_out  (Optional) Maximum execution time, overruns will be
interrupted.
@param [in]  in_process          (Optional) support in future.
@param [in]  graph               (Optional) the graph to query.
@param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,
binary format.
@returns True if it succeeds, false if it fails.
```
本接口支持在HA模式下使用，默认以json格式直接返回存储过程的执行结果，指定jsonFormat为false可以返回字符串格式的执行结果。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.7.向leader调用存储过程'}","page_content='Java客户端

2.使用示例

2.7.向leader调用存储过程

@param jsonFormat: (Optional) Return format of calling stored procedure
@return: the result of procedure execution
public String callProcedureToLeader(String procedureType, String procedureName, String param, double procedureTimeOut,
boolean inProcess, String graph)
```
本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.7.向leader调用存储过程'}","page_content='Java客户端

2.使用示例

2.6.调用存储过程

@param inProcess: Running query or not
@param graph: the graph to query
@param jsonFormat: (Optional) Return format of calling stored procedure
@param url: (Optional) Node address of calling procedure
@return: the result of procedure execution
public String callProcedure(String procedureType, String procedureName, String param, double procedureTimeOut,
boolean inProcess, String graph, String url)
```
本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}",空,空,空,空,空
Prometheus的地址是什么？,空,空,空,空,空,空,空,空,空,空
TuGraph图分析引擎主要面向哪类任务？,"page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

TuGraph 的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。 在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='OLAP API

1. TuGraph 图分析引擎介绍

TuGraph的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助TuGraph的 C++ / Python 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如PageRank、LPA、WCC等迭代式图算法，最后根据运行结果做出相应的对策。  
在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
TuGraph图计算系统社区版内置6个算法，商业版内置了25种算法，用户几乎不需要自己实现具体的图计算过程。其详细介绍可参考algorithms.md。  
根据数据来源及实现不同，可分为Procedure、Embed和Standalone三种运行方式，均继承于OlapBase API，OlapBase API接口文档可参考olapbase-api.md。' metadata={'Header 1': 'OLAP API', 'Header 2': '1. TuGraph 图分析引擎介绍'}","page_content='图算法介绍

2\. 流图推理简介

TuGraph计算引擎（TuGraph Analytics\[1\]）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持了丰富的图计算算法。TuGraph Analytics的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大得提高了数据的计算效率和实时性。TuGraph Analytics解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。  
随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，是无法基于传统的图迭代计算模式直接高效地表达的。' metadata={'Header 1': '图算法介绍', 'Header 2': '2\\. 流图推理简介'}","page_content='功能概览

3.计算层

计算层在功能上分成三个部分，包括TP类的图事务引擎，AP类的图分析引擎和图神经网络引擎。  
- __图事务引擎__，主要用来处理并发的图操作，包括单点查询、邻居查询、路径遍历。图事务引擎侧重并发操作的ACID事务，确保操作逻辑不会互相干扰，主要性能指标为 QPS，即每秒完成的查询数量。  
- __图分析引擎__，操作类型通常为全图迭代。部分简单的分析任务（比如SPSP）可以由图事务引擎完成，复杂的分析任务均由图分析引擎完成，单个任务通常需要数秒至数小时。因此单个图分析任务要并发利用所有的硬件资源，性能指标为任务完成的总时长。  
- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。' metadata={'Header 1': '功能概览', 'Header 2': '3.计算层'}","page_content='HTAP

2.设计

在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。  
- 事务操作，即图事务引擎测的操作，为局部图的增删查改操作，典型的应用为 K 跳访问 K-Hop。
- 简单分析操作，是图分析引擎中较为简单的部分，通常也是局部的图分析操作，比如两点间最短路算法 SPSP、Jaccard 算法。
- 复杂分析操作，是图分析引擎中较为复杂的部分，通常涉及全图的多轮数据迭代操作，比如网页排序算法 PageRank、社区发现算法 Louvain。  
如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。  
- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。
- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。' metadata={'Header 1': 'HTAP', 'Header 2': '2.设计'}",空,空,空,空,空
在给定的XML配置中，如果表内属性字段名为id，应该如何处理node_id字段以避免报错？,空,空,空,空,空,空,空,空,空,空
"在使用OGM（对象图映射）进行创建节点和边的代码示例中，通常边的标签""DIRECT""会在定义边的类时指定。请问在这个代码示例中，哪部分代码具体用于创建边标签""DIRECT""？","page_content='TuGraph-OGM

3.使用 TuGraph-OGM

3.3.通过OGM进行增删改查

session.query(""CALL db.createVertexLabel('Director', 'name', 'name',"" +
""STRING, false, 'age', INT16, true)"", emptyMap());            // 创建节点Label Director
session.query(""CALL db.createEdgeLabel('DIRECT', '[]')"", emptyMap()); // 创建边Label DIRECT
Result createResult = session.query(
""CREATE (n:Movie{title:\""The Shawshank Redemption\"", released:1994})"" +
""<-[r:DIRECT]-"" +
""(n2:Director{name:\""Frank Darabont\"", age:63})"",
emptyMap());' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '3.使用 TuGraph-OGM', 'Header 3': '3.3.通过OGM进行增删改查'}","page_content='TuGraph-OGM

使用TuGraph-OGM

通过OGM进行增删改查

session.query(""CALL db.createVertexLabel('Director', 'name', 'name',"" +
""STRING, false, 'age', INT16, true)"", emptyMap());            // 创建节点Label Director
session.query(""CALL db.createEdgeLabel('DIRECT', '[]')"", emptyMap()); // 创建边Label DIRECT
Result createResult = session.query(
""CREATE (n:Movie{title:\""The Shawshank Redemption\"", released:1994})"" +
""<-[r:DIRECT]-"" +
""(n2:Director{name:\""Frank Darabont\"", age:63})"",
emptyMap());' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '使用TuGraph-OGM', 'Header 3': '通过OGM进行增删改查'}","page_content='TuGraph Java Client

用例

OGM 用例

session.query(""CALL db.createEdgeLabel('DIRECT', '[]')"", emptyMap());
Movie movie1 = new Movie(""Jokes"", 1990);
session.save(movie1);
Movie m1 = session.load(Movie.class, movie1.getId());
assertThat(movie1.getId()).isEqualTo(m1.getId());
assertThat(movie1.getTitle()).isEqualTo(m1.getTitle());' metadata={'Header 1': 'TuGraph Java Client', 'Header 2': '用例', 'Header 3': 'OGM 用例'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.3 通过OGM进行增操作**

OGM支持对TuGraph的实体执行CRUD 操作，同时支持发送任意TuGraph支持的Cypher语句，包括通过CALL调用存储过程。  
**CREATE**  
在完成图对象的构建后，即可通过类的实例化创建节点，当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边，最后使用session.save方法将数据存入数据库。  
注意：TuGraph数据库为强schema类型数据库，在创建实体前需要该数据的label已经存在，且新建过程中需要提供唯一的主键。  
```
Movie jokes = new Movie（""Jokes""，1990）； // 新建Movie节点jokes session.save(jokes); // 将jokes存储在TuGraph中

Movie speed = new Movie(""Speed"", 2019);

Actor alice = new Actor(""Alice Neeves"");

alice.actsIn(speed);

session.save(speed);' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.3 通过OGM进行增操作**'}",空,空,空,空,空,空
"如何统一返回可视化页面的数据结构，以确保 return n 和 return p.name, p.age 的数据一致性？",空,空,空,空,空,空,空,空,空,空
如何在编译TuGraph时为基于ARM的机器（如Mac M1）配置CMake？,"page_content='从源码编译

2.编译介绍

以下是编译TuGraph的步骤：  
1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤
2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`，如果在arm机器编译（如M1芯片的Mac中，需要加上` -DENABLE_BUILD_ON_AARCH64=ON`）
3. `make`
4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build' metadata={'Header 1': '从源码编译', 'Header 2': '2.编译介绍'}","page_content='TuGraph-db

3. 从源代码编译

建议在Linux系统中构建TuGraph，Docker环境是个不错的选择。如果您想设置一个新的环境，请参考[Dockerfile]  
以下是编译TuGraph的步骤：  
1. 如果需要web接口运行`deps/build_deps.sh`，不需要web接口则跳过此步骤
2. 根据容器系统信息执行`cmake .. -DOURSYSTEM=centos`或者`cmake .. -DOURSYSTEM=ubuntu`
3. `make`
4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build' metadata={'Header 1': 'TuGraph-db', 'Header 2': '3. 从源代码编译'}","page_content='demo/TuGraph-Demo.md/ # TuGraph 示例

## 1 简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph是TuGraph的曾用名。

主要功能特征包括：

- 支持属性图模型
- 原生图存储及处理
- 完全的ACID事务支持
- 支持OpenCypher图查询语言
- 支持原生的Core API和Traversal API
- 支持REST和RPC接口
- 支持CSV、JSON、MySQL等多数据源导入导出
- 支持可视化图交互
- 支持命令行交互
- 内置用户权限控制、操作审计
- 支持任务和日志的监控管理
- 原生适配PandaGraph图分析引擎
- 集成DGL图神经网络系统

性能及可扩展性特征包括：

- 支持TB级大容量
- 吞吐率高达千万顶点每秒
- 面向读优化的存储引擎
- 支持高可用模式
- 支持离线备份恢复
- 在线热备份
- 高性能批量导入导出

## 2 快速上手

见QuickStart文档。

## 3 基本功能

### 3.1 RPC Client
#### 3.1.1 概述
RPC Client是对cpp语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.1.2 编译
在代码目录demo/CppRpcClientDemo目录下,执行下列命令 ,成功后将会看到可执行文件clientdemo
```bash
mkdir build && cd build && cmake ../ && make
```
#### 3.1.3 运行
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
        -h             show this usage
        -i --ip        ip for graph server
        -p --port      port for graph server
        -g --graph     graph name
        -u --user      user name
        --password     user password
        -c --cypher    cypher to query
举例如下
```bash
./clientdemo -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
### 3.2 Python RPC Client
#### 3.2.1 概述
Python RPC Client是对python语言rpc客户端的简单封装，每次执行时会创建一条到lgraph_server的链接用于发送请求数据以及接收响应结果，执行完毕后进程退出前会断开链接
#### 3.2.2 运行
需要依赖编译生成的python_client.so库，将python_client.so与client_python.py放在同一目录下
先启动lgraph_server，确保rpc端口处于打开状态。

clientdemo程序接收参数如下：
-h             show this usage
-i --ip        ip for graph server
-p --port      port for graph server
-g --graph     graph name
-u --user      user name
--password     user password
-c --cypher    cypher to query
举例如下
```bash
python3 client_python.py -i 127.0.0.1 -p 9090 -u admin --password 73@TuGraph -g default -c ""MATCH (n) RETURN n LIMIT 100""
```
## 4 集成工具

### 4.1 DataX 导入导出工具
#### 4.1.1 概述
DataX 支持 TuGraph 和 MySQL、SQL Server、Oracle、PostgreSQL、HDFS、Hive、HBase、OTS、ODPS、Kafka 等各种异构数据源的数据导入导出。
#### 4.' metadata={'file_name': 'TuGraph-Demo.md', 'file_path': 'demo/TuGraph-Demo.md', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/TuGraph-Demo.md'}","page_content='TuGraph-db

3. 从源代码编译

4. `make package` 或者 `cpack --config CPackConfig.cmake`  
示例：`tugraph/tugraph-compile-centos7`Docker环境  
```bash
$ git clone --recursive https://github.com/TuGraph-family/tugraph-db.git
$ cd tugraph-db
$ deps/build_deps.sh
$ mkdir build && cd build
$ cmake .. -DOURSYSTEM=centos7
$ make
$ make package
```' metadata={'Header 1': 'TuGraph-db', 'Header 2': '3. 从源代码编译'}","page_content='src/CMakeLists.txt/ cmake_minimum_required(VERSION 3.1)
project(TuGraphSrc C CXX)

set(LGRAPH_SRC_DIR ${PROJECT_SOURCE_DIR})

include(BuildLGraphApi.cmake)
if(BUILD_JAVASDK)
    include(BuildLGraphApiForJNI.cmake)
endif()
include(BuildPythonApi.cmake)
include(BuildLGraphServer.cmake)
include(BuildCypherLib.cmake)
include(BuildClients.cmake)
include(BuildCythonExtension.cmake)
include(BuildBoltLib.cmake)

install(TARGETS lgraph lgraph_python_api lgraph_server lgraph_db_python
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lgraph/lib64)
install(DIRECTORY
        ${CMAKE_CURRENT_LIST_DIR}/restful/server/resource
        DESTINATION share/lgraph)
install(DIRECTORY
        ${CMAKE_CURRENT_LIST_DIR}/restful/server/browser-resource
        DESTINATION share/lgraph)
# install procedure demos
install(DIRECTORY
        DESTINATION share/lgraph/resource/procedure_demo/)
install(FILES
        ${CMAKE_CURRENT_LIST_DIR}/../procedures/demo/v1_scan_graph.cpp
        ${CMAKE_CURRENT_LIST_DIR}/../procedures/demo/v2_pagerank.cpp
        ${CMAKE_CURRENT_LIST_DIR}/../procedures/demo/scan_graph.py
        DESTINATION share/lgraph/resource/procedure_demo/)
install(DIRECTORY
        DESTINATION share/lgraph/browser-resource/procedure_demo/)
install(FILES
        ${CMAKE_CURRENT_LIST_DIR}/../procedures/demo/v1_scan_graph.cpp
        ${CMAKE_CURRENT_LIST_DIR}/../procedures/demo/v2_pagerank.cpp
        ${CMAKE_CURRENT_LIST_DIR}/../procedures/demo/scan_graph.py
        DESTINATION share/lgraph/browser-resource/procedure_demo/)
install(FILES
        ${CMAKE_CURRENT_LIST_DIR}/python/lgraph_task_runner.py
        DESTINATION bin)
install(FILES
        ${CMAKE_CURRENT_LIST_DIR}/../release/local/etc/lgraph.json
        DESTINATION etc)
install(FILES
        /usr/local/lib64/libvsag.so
        /usr/local/lib64/libmkl_intel_lp64.so
        /usr/local/lib64/libmkl_sequential.so
        /usr/local/lib64/libmkl_core.so
        /usr/local/lib64/libmkl_def.so
        /usr/local/lib64/libmkl_avx2.so
        /usr/local/lib64/libmkl_mc3.so
  ' metadata={'file_name': 'CMakeLists.txt', 'file_path': 'src/CMakeLists.txt', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/CMakeLists.txt'}",空,空,空,空,空
单机的配置通常是指在一台计算机上运行的系统或软件的硬件和软件环境，具体包括哪些方面呢？,空,空,空,空,空,空,空,空,空,空
如何在TuGraph中查询两点之间的一条通路？,"page_content='空间数据类型在TuGraph-DB中的实现

相关函数介绍

| PointWKT() | 根据WKT与指定SRID创建Point | WKT format(string) , SRID(int) | point |  
查询用相关函数：  
| **函数名** | **描述** | **输入参数** | **返回值类型** |
| --- | --- | --- | --- |
| Distance() | 计算两个空间数据间的距离 |
|
|
| 注：要求坐标系相同 | Spatial data1, Spatial data2 | double |
|
| Disjoint() | 判断两个空间数据是否相交 |
|
|
| 注：开发中 | Spatial data1, Spatial data2 | bool |
|
| WithinBBox() | 判断某个空间数据是否在给定的长方形区域内 |
|
|
| 注：开发中 | Spatial data, Point1 | bool |
|  
使用实例如下：  
```
#创建包含空间数据类型的点模型' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '相关函数介绍'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

5. 结果展示

Tugraph Analytics 完成环路检测计算任务后，会自动返回检测结果。  
<img width=""324"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/ba343acf-812a-4df5-8da4-ff70e0b2531d"">  
右侧画布中会动态显示出本次环路检测结果信息：  
![Jun-12-2023 19-53-35](https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/f8595322-d477-4702-a52e-4f03092b7219)' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '5. 结果展示'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

4. 演示

环路检测 Demo 提供了两种方式来进行交互：  
* 方式一 在输入框中输入点边信息
* 方式二 使用内置数据进行演示  
> 两种方式本质都是调用 Tugraph Analytics 进行实时计算，不过方式二省略了手动输入过程。  
这里我们使用内置数据进行快速演示，点击【选项】，选择`添加点`，画布中出现了 7 个点信息；接着选择`添加边`。我们可以在上方对话框中看到添加记录。  
<img width=""332"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/7ca76607-41a1-4afe-9427-cf7599de6889"">  
同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '4. 演示'}",空,空,空,空,空,空,空
TuGraph是否支持通过Cypher或Python的方式来修改其schema？,"page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

简介

TuGraph 图数据库提供了 JAVA、C++、Python 等多种语言的 SDK 支持，方便客户在各种场景下使用。用户使用 SDK 向TuGraph服务器发送Cypher请求，服务器则以 JSON形式返回数据。近日，TuGraph 推出了一款面向 JAVA 客户端用户的开发工具 TuGraph-OGM (Object Graph Mapping)，为用户提供了对象操作接口，相较 Cypher/JSON 接口应用起来更加便捷。  
OGM 类似于关系数据库中的 ORM（Object Relational Model），可以将数据库返回的数据自动映射成 JAVA 中的对象，方便用户读取，而用户对这些对象的更新操作也可以被自动翻译成 Cypher 语句发送给服务器。这样即便是完全不懂 Cypher 的用户，也可以通过操作对象与数据库进行交互，大大降低了图数据库的使用门槛。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.3 通过OGM进行增操作**

OGM支持对TuGraph的实体执行CRUD 操作，同时支持发送任意TuGraph支持的Cypher语句，包括通过CALL调用存储过程。  
**CREATE**  
在完成图对象的构建后，即可通过类的实例化创建节点，当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边，最后使用session.save方法将数据存入数据库。  
注意：TuGraph数据库为强schema类型数据库，在创建实体前需要该数据的label已经存在，且新建过程中需要提供唯一的主键。  
```
Movie jokes = new Movie（""Jokes""，1990）； // 新建Movie节点jokes session.save(jokes); // 将jokes存储在TuGraph中

Movie speed = new Movie(""Speed"", 2019);

Actor alice = new Actor(""Alice Neeves"");

alice.actsIn(speed);

session.save(speed);' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.3 通过OGM进行增操作**'}","page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}","page_content='RPC API

5.存储过程

为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。
用户可以使用RPC请求对存储过程进行增删改查操作。' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程'}",空,空,空,空,空
TuGraph-Restful-Server使用哪种框架来支持其HTTP协议，并且具体提供了哪些主要功能？,"page_content='TuGraph-Restful-Server

1.TuGraph-Restful-Server 简介

TuGraph Restful Server 使用brpc框架支持的http协议，提供restful接口查询功能，在实现中，restful server 与rpc server 使用同一个端口。目前restful接口提供文件上传，数据导入，导入进度查询，cypher查询，文件删除等功能' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '1.TuGraph-Restful-Server 简介'}","page_content='功能概览

6.生态工具

6.3.运维监控

TuGraph 使用 Prometheus 加 Grafana 的监控框架，采用松耦合的方式。Prometheus 从 TuGraph 的监控接口获取监控信息，存储在本地时序数据库中，然后通过 Grafana 在网页端交互展示。  
TuGraph 提供的监控的状态包括图数据库的状态和服务器的状态，前者包括读写负载、点边数量等数据库端的状态，后者包括内存、CPU、硬盘等服务器的实时状态。如果某些监控状态超过了预期的阈值，就需要主动告警，通常需要对接其他运维管控系统，比如群消息、邮件告警等。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.3.运维监控'}","page_content='RESTful API

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。' metadata={'Header 1': 'RESTful API', 'Header 2': '1.简介'}","page_content='RESTful API Legacy

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。  
**注意：除""登陆""、""查询""和""存储过程""外，其余接口自 **2023年4月30日** 起将不再提供支持，统一使用Cypher接口提供服务。**' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '1.简介'}","page_content='RESTful API Legacy

3.登录

TuGraph 提供基于 JWT 的用户认证方式，可以使用 HTTP 或 HTTPS 协议进行传输。系统默认使用 HTTP 协议，如果需要使用 HTTPS，需要在 lgraph.json 配置文件中将 ssl_auth 设为 1。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '3.登录'}",空,空,空,空,空
禁用角色后，具有该角色的用户会受到什么影响？,"page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

```  
#### 6.2.6.禁用角色  
角色可以被禁用。角色被禁用后，具有该角色的用户将不再从该角色中获得任何权限。只有管理员可以执行此操作。  
- **URI**: `/role/{role_name}/disable`
- **METHOD**: POST
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/disable
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
```  
#### 6.2.6.禁用角色  
角色可以被禁用。角色被禁用后，具有该角色的用户将不再从该角色中获得任何权限。只有管理员可以执行此操作。  
- **URI**: `/role/{role_name}/disable`
- **METHOD**: POST
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/disable' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

![角色管理-添加角色](../../../images/browser/role-add.png)  
###### b.编辑角色  
在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。  
![角色管理-编辑角色](../../../images/browser/role-edit.png)  
###### c.禁用角色  
在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。  
- 禁用角色：禁用之后，对应角色图访问权限失效。
- 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。  
![角色管理-禁用](../../../images/browser/role-disable.png)
![角色管理-启用](../../../images/browser/role-enable.png)  
###### d.删除角色  
在`角色管理`界面点击`删除`按钮删除对应的角色。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

- 禁用角色：禁用之后，对应角色图访问权限失效。
- 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。  
![角色管理-禁用](../../../images/browser/role-disable.png)
![角色管理-启用](../../../images/browser/role-enable.png)  
###### d.删除角色  
在`角色管理`界面点击`删除`按钮删除对应的角色。  
![角色管理-删除](../../../images/browser/role-delete.png)  
#### 2.5.2.数据库信息  
##### 2.5.2.1.基础信息  
`基础信息`获取当前系统运行的状态，并展示关键信息。  
![数据库信息-基础信息](../../../images/browser/db_basic.png)  
|参数    |含义    |
|-------|--------|
|TuGraph版本号|当前TuGraph的版本号，x.x.x|' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

- 角色名称：支持中文、字母、数字以及下划线，不支持空格以及其他特殊符号。
- 图权限：browser支持全部、读、写和无共四类图权限配置。
- 全部：对应图的读和写权限，包含编辑图模型权限（schema）。
- 读写：对应图的写权限，不包含编辑图模型权限（schema）。
- 只读：对应图的读权限。
- 无：无法访问和操作对应图。
- 角色冲突：当两个角色对同一个图有不同图权限，同时对一个账户授权了这两个角色，该账户对该图的图权限为两个角色的并集。  
![角色管理-添加角色](../../../images/browser/role-add.png)  
###### b.编辑角色  
在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。  
![角色管理-编辑角色](../../../images/browser/role-edit.png)  
###### c.禁用角色  
在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}",空,空,空,空,空
作为公司员工，我应该如何确保我提交的贡献内容获得合法授权？,空,空,空,空,空,空,空,空,空,空
如何在TuGraph中只清空数据，而保留schema？,"page_content='业务开发指南

子图操作

清空子图

#### 删除所有的点边数据和图schema
```
CALL db.dropDB()
```
#### 只删除所有点边数据, 保留图schema
```
CALL db.dropAllVertex()
```' metadata={'Header 1': '业务开发指南', 'Header 2': '子图操作', 'Header 3': '清空子图'}","page_content='src/client/python/TuGraphClient/TuGraphRestClient.py/ def import_data(self, graph, schema, delimiter, continue_on_error, skip_packages, task_id, flag):
        data = {""graph"" : graph, ""schema"" : schema, ""delimiter"" : delimiter,
                ""continueOnError"" : continue_on_error, ""skipPackages"" : skip_packages,
                ""taskId"" : task_id, ""flag"" : flag}
        r = self._sync(partial(self.__post__, 'import_data', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""taskId""]

    def import_schema(self, graph, schema):
        data = {""graph"":graph, ""description"":schema}
        r = self._sync(partial(self.__post__, 'import_schema', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""result""]

    def check_file_with_size(self, file_name, size):
        data = {""fileName"" : file_name, ""flag"" : ""2"" , ""fileSize"" : str(size)}
        r = self._sync(partial(self.__post__, 'check_file', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""pass""]

    def import_progress(self, task_id):
        data = {""taskId"" : task_id}
        r = self._sync(partial(self.__post__, 'import_progress', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""]' metadata={'file_name': 'TuGraphRestClient.py', 'file_path': 'src/client/python/TuGraphClient/TuGraphRestClient.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/TuGraphClient/TuGraphRestClient.py'}","page_content='TuGraph-OGM

3.使用 TuGraph-OGM

3.3.通过OGM进行增删改查

// 清空数据库
session.deleteAll(Movie.class);        // 删除所有Movie节点
session.purgeDatabase();               // 删除全部数据
```' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '3.使用 TuGraph-OGM', 'Header 3': '3.3.通过OGM进行增删改查'}",空,空,空,空,空,空,空
OGM在哪些方面与MyBatis类似？,空,空,空,空,空,空,空,空,空,空
如何在 Docker 中部署 BROWSER？,"page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}",空,空,空,空,空,空,空,空,空
TuGraph-DB是否提供数据导入工具？如果有，相关的代码可以在哪里找到？,"page_content='数据导入

1.简介

在图数据库服务安装成功后，您可以使用`lgraph_import`批量导入工具将现有数据导入 TuGraph。`lgraph_import`支持从 CSV 文件和 JSON 数据源导入数据。  
> CSV 格式  
```
[movies.csv]
id, name, year, rating
tt0188766,King of Comedy,1999,7.3
tt0286112,Shaolin Soccer,2001,7.3
tt4701660,The Mermaid,2016,6.3
```  
> jsonline 格式  
```json
[""tt0188766"",""King of Comedy"",1999,7.3]
[""tt0286112"",""Shaolin Soccer"",2001,7.3]
[""tt4701660"",""The Mermaid"",2016,6.3]
```  
TuGraph 支持两种导入模式：  
- _离线模式_：读取数据并将其导入指定服务器的数据文件，应仅在服务器离线时完成。' metadata={'Header 1': '数据导入', 'Header 2': '1.简介'}","page_content='数据导出

1.简介

TuGraph 可以通过 `lgraph_export` 工具来对已经存放在TuGraph的图数据进行数据导出。 `lgraph_export` 工具可以将指定 TuGraph 数据库的数据以 `csv` 或者 `json` 文件形式导出到指定目录，同时导出这些数据进行再导入时需要的配置文件 `import.config` ，详细描述可参见[配置文件](1.data-import.md)。' metadata={'Header 1': '数据导出', 'Header 2': '1.简介'}","page_content='功能概览

6.生态工具

6.1.TuGraph DataX

![导入导出](../../../images/tugraph-datax.png)  
TuGraph 核心支持 CSV 和 JSON 合适的导入导出，提供空库导入和增量导入的模式。实际中会存在 MySQL、Kafka、Hive 等多数据源导入的需求，TuGraph 通过 DataX 做多数据源的对接。由于关系模型和图模型存在的差异，数据清洗的流程可以使用 SparkSQL 快速处理，TuGraph 本身仅关注 CSV 和 JSON 的简单场景导入可靠性和性能。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.1.TuGraph DataX'}","page_content='功能概览

4.核心功能

4.3.数据导入导出

尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。  
TuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.3.数据导入导出'}","page_content='试用体验：TuGraph — 简单高效的图数据库

多数据源导入和多语言客户端支持

TuGraph支持从不同数据源导入数据，无论是关系型数据库还是其他图数据库，都可以轻松迁移到TuGraph中。此外，TuGraph还提供了多语言客户端支持，我可以使用自己熟悉的编程语言与图数据库进行交互，这为我带来了极大的便利。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '多数据源导入和多语言客户端支持'}",空,空,空,空,空
图数据库相比关系型数据库有哪些独特的优势？,"page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.2. 兼容性

现实中，项目进程通常不断演变，数据的内容甚至数据格式也在不断变化。在关系型数据库中，这意味着表结构的变化或建立多个新表，对源数据的修改非常大。而在图数据库中，仅需添加新的点、边和属性，并将其设置为对应的类型即可。从本质上说，一个表代表一种类型的数据，一个点代表一个特定的数据。这意味着关系型数据库更关注数据类型，而图数据库更关注数据个体及其关联关系。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.2. 兼容性'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.3. 直观性

使用图的方式表达现实世界的关系更直接和自然，在万物互联的时代尤为突出。如果使用关系型数据，先建立实体表，再建立关系表，最后映射数据，需要高度的抽象思维。在图数据上进行分析查询时，可以直观地通过点边连接的拓扑结构找到所需数据，无需任何专业知识。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.3. 直观性'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

2.1. 性能

在关联关系处理上，使用关系型数据库不可避免地要使用表的JOIN操作，这会对性能产生较大影响；而图数据库则直接跳转访问类指针，操作关联数据的效率更高，比关系型数据库提高2到4个数量级的性能。' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势', 'Header 3': '2.1. 性能'}","page_content='什么是图数据库

2. 图数据库相比较于关系型数据库的优势

图数据库的功能是传统关系型数据库的扩展。与关系型数据库仅支持的“表结构”相比，图数据库所支持的“图结构”更为灵活。图数据库在基于图的增加、删除、查询和修改方面采用不同于其他数据库的设计。在图数据操作抽象上，采用基于点的视角，例如点通过其所有“出边”（从一个点出发，连接到其他点的边）访问其邻接点。这是图数据库系统设计的核心。  
图数据库的独特性体现在以下三个方面:' metadata={'Header 1': '什么是图数据库', 'Header 2': '2. 图数据库相比较于关系型数据库的优势'}","page_content='什么是图数据库

3. 图数据库与关系型数据库对比

| 分类         | 模型   | 优势                                   | 劣势                                     | 举例           |
| ------------ | ------ | -------------------------------------- | ---------------------------------------- | -------------- |
| 关系型数据库 | 表结构 | 数据高度结构化，一致性强，软件成熟度高 | 面向多跳的关联关系查询低效或不支持       | MySQL、Oracle  |
| 图数据库     | 图结构 | 针对关联关系的建模建模和操作效率非常高 | 高度结构化的数据处理能力不及关系型数据库 | Neo4j、TuGraph |' metadata={'Header 1': '什么是图数据库', 'Header 2': '3. 图数据库与关系型数据库对比'}",空,空,空,空,空
TuGraph 产品架构中，客户端 SDK 支持哪些编程语言？,"page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}","page_content='功能概览

5.客户端工具

客户端主要分为各种编程语言的SDK，OGM以及命令行工具。  
客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。  
OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。' metadata={'Header 1': '功能概览', 'Header 2': '5.客户端工具'}","page_content='QA汇总

Client QA

支持语言

Q：client 目前有哪些编程语言，是否支持 node js？
A：目前主要支持的编程语言有 c++,python,java；目前不支持 node js。使用 node 作为主要开发语言的用户，可以使用 tugraph 提供的 restful api 来调用。建议使用 Cypher 来封装调用接口。后续版本 restful api 将不再进行更新维护，只会保留登录、登出、刷新 token、cypher 调用这几个常见的 api。' metadata={'Header 1': 'QA汇总', 'Header 2': 'Client QA', 'Header 3': '支持语言'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

三、TuGraph-DB高可用集群部署与应用

1.TuGraph-DB高可用（V3.6）

关于 TuGraph-DB 高可用集群的部署方式和 client 应用，相关文档已经放到了 tugraph-db.readthedocs.io 网站上。  
现在支持 C++、Java 和 Python 多种版本的 client SDK。' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '三、TuGraph-DB高可用集群部署与应用', 'Header 3': '1.TuGraph-DB高可用（V3.6）'}","page_content='Procedure API

3.存储过程语言支持

在 TuGraph 中，用户可以动态的加载，更新和删除存储过程。TuGraph 支持 C++ 语言、 Python 语言和 Rust 语言编写存储过程。在性能上 C++ 语言支持的最完整，性能最优。  
注意存储过程是在服务端编译执行的逻辑，和客户端的语言支持无关。' metadata={'Header 1': 'Procedure API', 'Header 2': '3.存储过程语言支持'}",空,空,空,空,空
OGC定义了哪些空间数据的标准表示格式？,"page_content='空间数据类型在TuGraph-DB中的实现

空间数据类型的实现

OGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为EWKT(extended well known text)与EWKB(extended well known binary)格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。' metadata={'Header 1': '空间数据类型在TuGraph-DB中的实现', 'Header 2': '空间数据类型的实现'}","page_content='地理空间数据类型使用示例

2. 预备知识

2.3 数据存储格式

OGC(Open Geospatial Consortium) 定义了空间数据的标准表示格式，分别为WKT与WKB格式，用于在不同系统和平台之间交换和存储空间数据，现已被广泛采用。其中WKT(well-kown text)格式, 是一种文本标记语言,易于人类阅读和编写，而WKB(Well-Known Binary)格式采用一系列字节来编码空间数据，更适合在计算机中存储;  
**WKT:**  
```
POINT(<x> <y>)
LINESTRING(<x1> <y1>, <x2><y2>, ...)
```  
WKT格式的数据如上例所示，先指定空间数据类型，再在括号内指定具体的坐标，一个坐标对表示一个点，每个坐标对之间用逗号隔开。对于Polygon类型的数据，第一个坐标对需要与最后一个坐标对相同，形成闭合的面。  
**WKB:**  
![image.png](../../../images/spatail/WKB.png)  
针对EWKB格式的编码，说明如下:  
- 第0 - 1位: 编码方式;' metadata={'Header 1': '地理空间数据类型使用示例', 'Header 2': '2. 预备知识', 'Header 3': '2.3 数据存储格式'}",空,空,空,空,空,空,空,空
db.importor.dataImportor函数的目的是什么？,"page_content='Cypher API

5.附录2. 内置procedures列表

5.2.内置procedures完整列表

| db.importor.dataImportor              | 导入点或边数据                               | db.importor.dataImportor(description::STRING,content::STRING,continue_on_error::BOOLEAN,thread_nums::INTEGER,delimiter::STRING) :: (::VOID)                                             |' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '5.2.内置procedures完整列表'}",空,空,空,空,空,空,空,空,空
TuGraph企业版是什么？,"page_content='什么是TuGraph

4. TuGraph企业版

企业版对商业化功能支持更加完善，包括分布式集群架构，覆盖探索、研发、服务、运维管理全生命周期的一站式图平台，在线、近线、离线的图计算引擎，支持流式、大数据类数据源，多地多中心的部署形态，以及专家支持服务等。企业版是商业化解决方案的理想选择。  
如需商业支持，请联系我们：  
- 电话：400-903-0809
- 邮件：tugraph@service.alipay.com
- 官网：https://tugraph.antgroup.com' metadata={'Header 1': '什么是TuGraph', 'Header 2': '4. TuGraph企业版'}","page_content='TuGraph在图计算系统建设中的作用

TuGraph 技术优势

TuGraph 企业版特色

除了开源版本，我们也继续提供商业版本。这个版本包含一个分布式图数据库，以及离线计算引擎和流式图计算功能。此外，我们还提供了 TuGraph Platform 一站式图平台，包括运维、可视化等功能。在这个平台上，用户可以在图数据库中执行流式计算，并在线写回数据库。这种方式通常用于实时查询结果，因为流式计算的时间可能比较长，但用户可以立即查询到较早的结果。这对于在线业务来说非常重要。  
商业化产品还提供私有化部署，也可以通过一体机的方式部署硬件，并将很快推出云上部署方案，这样大家就可以在云上体验我们的产品。' metadata={'Header 1': 'TuGraph在图计算系统建设中的作用', 'Header 2': 'TuGraph 技术优势', 'Header 3': 'TuGraph 企业版特色'}","page_content='什么是TuGraph

1. 简介

TuGraph图数据库由蚂蚁集团与清华大学联合研发，构建了一套包含图存储、图计算、图学习、图研发平台的完善的图技术体系，拥有业界领先规模的图集群，解决了图数据分析面临的大数据量、高吞吐率和低延迟等重大挑战，是蚂蚁集团金融风控能力的重要基础设施，显著提升了欺诈洗钱等金融风险的实时识别能力和审理分析效率，并面向金融、工业、政务服务等行业客户。' metadata={'Header 1': '什么是TuGraph', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}",空,空,空,空,空
请求存储过程列表时，应该使用哪种HTTP方法和URI？,"page_content='RESTful API Legacy

5.存储过程

5.2.列出所有存储过程

- **URI**: `/db/{graph_name}/cpp_plugin|python_plugin`
- **METHOD**: GET
- **RESPONSE**: 存储过程列表，其中每个元素是一个 plugin 的描述，其格式为：
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | 存储过程名 | 字符串 |
| description | 存储过程描述 | 字符串 |
| read_only | 存储过程是否只读 | 布尔值 |  
**Example request.**  
```
• GET http://localhost:7070/db/graph1/cpp_plugin
• Accept: application/json; charset=UTF-8
```  
**Example response.**  
```
• 200: OK
Output:
{
[
{
""description"":""adds a vertex label to the db"",' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '5.存储过程', 'Header 3': '5.2.列出所有存储过程'}","page_content='RPC API

5.存储过程

5.4.列举存储过程

列举存储过程请求不需要参数，以C++为例，用户列举存储过程的方式如下所示：
```C++
LGraphRequest req;
req.set_is_write_op(false);
lgraph::PluginRequest* pluginRequest = req.mutable_plugin_request();
pluginRequest->set_graph(graph);
pluginRequest->set_type(procedure_type == ""CPP"" ? lgraph::PluginRequest::CPP
: lgraph::PluginRequest::PYTHON);
pluginRequest->mutable_list_plugin_request();
cntl->Reset();
cntl->request_attachment().append(FLAGS_attachment);
req.set_client_version(server_version);
req.set_token(token);' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程', 'Header 3': '5.4.列举存储过程'}","page_content='Procedure API

4.2.如何使用存储过程

4.2.2.列出已加载的存储过程

在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')
>>> r.status_code
200
>>> r.text
'{""plugins"":[{""description"":""Custom Page Rank Procedure"", ""name"":""age_10"", ""read_only"":true}]}'
```' metadata={'Header 1': 'Procedure API', 'Header 2': '4.2.如何使用存储过程', 'Header 3': '4.2.2.列出已加载的存储过程'}",空,空,空,空,空,空,空
TuGraph基础算法包包含哪些算法？,"page_content='内置算法

简介

TuGraph目前包含以下6个基础算法28种扩展算法，共34个图算法：' metadata={'Header 1': '内置算法', 'Header 2': '简介'}","page_content='OlapOnDisk API

1. 简介

TuGraph的Standalone模式可用于加载图数据文件，其中图数据文件来源可包含text文本文件、BINARY_FILE二进制文件和ODPS源。在该模式下，TuGraph可实现多数据来源快速加载成图，然后在该图上运行如BFS、WCC、SSSP等迭代式算法，并输出最终结果至终端。  
在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
TuGraph内置了大量的常见图分析算法和丰富的辅助接口，因此用户几乎不需要自己实现具体的图计算过程，只需要在实现自己的存储过程的时候将相应算法库的头文件(.h)包含到自己的程序中，并在编译阶段链接自己的动态库文件即可。  
该文档主要介绍了Standalone的常用接口，使用到的辅助函数主要包含在OlapOnDB类。同时为帮助用户理解方便，对BFS算法进行举例说明。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '1. 简介'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。  
TuGraph 图计算系统社区版内置 6 个基础算法，商业版内置了共 34 种算法。涵盖了图结构、社区发现、路径查询、重要性分析、模式挖掘和关联性分析的六大类常用方法，可以满足多种业务场景需要，因此用户几乎不需要自己实现具体的图计算过程。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='图算法介绍

2\. 流图推理简介

TuGraph计算引擎（TuGraph Analytics\[1\]）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持了丰富的图计算算法。TuGraph Analytics的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大得提高了数据的计算效率和实时性。TuGraph Analytics解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。  
随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，是无法基于传统的图迭代计算模式直接高效地表达的。' metadata={'Header 1': '图算法介绍', 'Header 2': '2\\. 流图推理简介'}","page_content='图算法介绍

2\. 流图推理简介

受上述问题启发，我们思考是否可以将TuGraph Analytics的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：  
-   对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。  
-   对于AI算法工程师，可以通过TuGraph Analytics分布式流式计算的能力实现实时的模型推理。  
众所周知，在深度学习为代表的数据科学领域，Python已经成为数据分析、模型训练和推理框架的主流开发语言，并提供了丰富的开发库和框架生态。而以Hadoop全家桶为代表的大数据计算引擎领域，基于Java语言开发的系统仍占据一席之地，当然TuGraph Analytics也在其中。这种语言差异带来的“互操作性”成本，使得相当一部分大数据和AI生态组件无法轻松地融合，这也是TuGraph Analytics支持图推理需要亟待解决的问题。' metadata={'Header 1': '图算法介绍', 'Header 2': '2\\. 流图推理简介'}",空,空,空,空,空
REST服务器的默认端口号通常是哪个？,"page_content='数据库运行

4.服务配置

4.1.配置参数

| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |
| enable_rpc                   | 布尔值                   | 是否使用 RPC 服务。默认值为 false。                                                                                                                                                           |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| host                         | 字符串                   | REST 服务器监听时使用的地址，一般为服务器的 IP 地址。默认地址为 0.0.0.0。注：在HA模式下，host需要设置为对应服务器的IP地址，不能设置为0.0.0.0。                                                                                           |
| port                         | 整型                    | REST 服务器监听时使用的端口。默认端口为 7070。                                                                                                                                                      |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}",空,空,空,空,空,空,空,空
如何对一个角色进行禁用，并且在什么情况下调用的函数会返回true？,空,空,空,空,空,空,空,空,空,空
TuGraph更新之后，原库中的数据会丢失吗？,"page_content='数据迁移

1. 简介

数据迁移是指将数据从一个系统、存储介质或应用程序迁移到另一个系统、存储介质或应用程序的过程。当TuGraph要升级或者系统硬件环境发生变化时，
需要对原TuGraph服务中的数据进行迁移。以系统硬件环境和软件版本为依据进行划分，本文将数据迁移分为三种方案：
1. 兼容迁移：当迁移前后系统环境一致且TuGraph软件兼容时，可以直接使用备份恢复的方式迁移数据；
2. 升级迁移：当迁移前后系统环境不一致或TuGraph软件不兼容时，需要使用先导出数据再重新导入的方式迁移数据；
3. 在线迁移：当对高可用集群进行数据迁移且集群网络环境良好时，可以使用增删节点的的方式将原集群平滑切换到新集群。
接下来本文将详细介绍这三种方案。' metadata={'Header 1': '数据迁移', 'Header 2': '1. 简介'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

一、高可用架构介绍

4.TuGraph-DB高可用架构—Raft 共识算法

-   有了一致性的保证后，安全性也就有了保证，当超过半数的节点达成一致之后，才应用日志，这样就能解决网络分区延迟、丢包、冗余和乱序的错误。
-   基于一致性和安全性，它的可用性也就得到了保证，只要少于半数的节点宕机，即使主机宕机，也可以快速恢复应用，通过一次选举的时间就可以重新选出一个leader对外提供服务。  
国标对于高可用系统的指标评估，RTO 和 RPO 分别是恢复时间指标和恢复点目标，有 6 个等级，TuGraph-DB 已经达到了最高等级。当少量节点故障时，RPO 是 0，也就是没有数据损失，数据恢复时间点指标是小于 15 秒。即使是在部署的时候，无论是在同城的两中心、三中心，还是多地的多中心，都可以达成 RTO 小于 15 秒的标准。  
Raft算法优点:  
• 易用性：状态简单，强Leader  
• 一致性：日志逐个复制，超过半数节点达成一致才提交，不存在日志空洞  
• 安全性：超半数节点达成一致才应用日志，能解决网络延迟、分区、丢包、冗余和乱序等错误' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '一、高可用架构介绍', 'Header 3': '4.TuGraph-DB高可用架构—Raft 共识算法'}","page_content='数据迁移

2. 兼容迁移

兼容迁移指的是在系统环境不变，且TuGraph软件版本兼容时，原服务的数据和存储过程可以在新服务中使用，所以可以直接迁移。
用户可以先使用`lgraph_backup`工具备份数据，然后将数据传输到新机器中并重启服务。具体迁移步骤如下：' metadata={'Header 1': '数据迁移', 'Header 2': '2. 兼容迁移'}",空,空,空,空,空,空,空
"如果节点中未包含属性""belt""，应该返回什么值？",空,空,空,空,空,空,空,空,空,空
磁盘IO警报是在什么情况下会被触发？,空,空,空,空,空,空,空,空,空,空
调用 Close() 函数后，InEdgeIterator 的状态是什么样的？,"page_content='src/lgraph_api/lgraph_edge_iterator.cpp/ void OutEdgeIterator::Delete() {
    ThrowIfInvalid();
    txn_->DeleteEdge(*it_);
    txn_->RefreshIterators();
}

std::string OutEdgeIterator::ToString() const {
    ThrowIfInvalid();
    return txn_->EdgeToString(*it_);
}

InEdgeIterator::InEdgeIterator(lgraph::graph::InEdgeIterator&& impl,
                               const std::shared_ptr<lgraph::Transaction>& txn)
    : it_(new lgraph::graph::InEdgeIterator(std::move(impl))), txn_(txn) {}

InEdgeIterator::InEdgeIterator(InEdgeIterator&& rhs)
    : it_(std::move(rhs.it_)), txn_(std::move(rhs.txn_)) {}

InEdgeIterator& InEdgeIterator::operator=(InEdgeIterator&& rhs) {
    it_ = std::move(rhs.it_);
    txn_ = std::move(rhs.txn_);
    return *this;
}

InEdgeIterator::~InEdgeIterator() {}

void InEdgeIterator::Close() noexcept { it_->Close(); }

bool InEdgeIterator::Next() {
    ThrowIfInvalid();
    return it_->Next();
}

bool InEdgeIterator::Goto(EdgeUid euid, bool nearest) {
    if (!txn_->IsValid()) THROW_CODE(InvalidTxn);
    return it_->Goto(euid, nearest);
}

EdgeUid InEdgeIterator::GetUid() const {
    ThrowIfInvalid();
    return it_->GetUid();
}

int64_t InEdgeIterator::GetSrc() const {
    ThrowIfInvalid();
    return it_->GetSrc();
}

int64_t InEdgeIterator::GetDst() const {
    ThrowIfInvalid();
    return it_->GetDst();
}

int64_t InEdgeIterator::GetEdgeId() const {
    ThrowIfInvalid();
    return it_->GetEdgeId();
}' metadata={'file_name': 'lgraph_edge_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_edge_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_edge_iterator.cpp'}","page_content='src/lgraph_api/lgraph_edge_index_iterator.cpp/ #define ThrowIfInvalid()                                                        \
    do {                                                                        \
        if (!txn_->IsValid()) throw std::runtime_error(""Invalid transaction.""); \
        if (!it_->IsValid()) throw std::runtime_error(""Invalid iterator."");     \
    } while (0)

EdgeIndexIterator::EdgeIndexIterator(lgraph::EdgeIndexIterator&& it,
                                     const std::shared_ptr<lgraph::Transaction>& txn)
    : it_(new lgraph::EdgeIndexIterator(std::move(it))), txn_(txn) {}

EdgeIndexIterator::EdgeIndexIterator(EdgeIndexIterator&& rhs)
    : it_(std::move(rhs.it_)), txn_(std::move(rhs.txn_)) {}

EdgeIndexIterator& EdgeIndexIterator::operator=(EdgeIndexIterator&& rhs) {
    it_ = std::move(rhs.it_);
    txn_ = std::move(rhs.txn_);
    return *this;
}

EdgeIndexIterator::~EdgeIndexIterator() {}

void EdgeIndexIterator::Close() { it_->Close(); }

bool EdgeIndexIterator::IsValid() const { return it_->IsValid(); }

bool EdgeIndexIterator::Next() {
    ThrowIfInvalid();
    return it_->Next();
}

FieldData EdgeIndexIterator::GetIndexValue() const {
    ThrowIfInvalid();
    return lgraph::field_data_helper::ValueToFieldData(it_->GetKey(), it_->KeyType());
}

EdgeUid EdgeIndexIterator::GetUid() const {
    ThrowIfInvalid();
    return it_->GetUid();
}

int64_t EdgeIndexIterator::GetSrc() const {
    ThrowIfInvalid();
    return it_->GetSrcVid();
}' metadata={'file_name': 'lgraph_edge_index_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_edge_index_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_edge_index_iterator.cpp'}",空,空,空,空,空,空,空,空
DUAL_DIRECTION表示什么？,"page_content='OlapOnDisk API

3. 其他常用函数功能描述

3.1 图加载

DUAL_DIRECTION : 输入文件为非对称图，加载图为非对称图。
MAKE_SYMMETRIC : 输入文件为非对称图，加载图为对称图。
INPUT_SYMMETRIC : 输入文件为对称图，加载图为对称图。
对应的详细介绍见lgraph文件夹下的olap_config.h文件的`enum EdgeDirectionPolicy`。  
- `void LoadVertexArrayTxt<V>(V * array, std::string path, std::function<size_t(const char *, const char *, VertexUnit<V> &)> parse_line)`：将文件中的点-数据对按照点id的顺序加载到数组中。各参数表示意义分别为：
- `array`：待读入数据的数组
- `path`：读取文件的路径，文件中每行表示一对点-数据对
- `parse_line`：用户自定义函数，告诉系统如何将一行文本数据解析为一个点-数据对。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '3. 其他常用函数功能描述', 'Header 3': '3.1 图加载'}","page_content='OlapOnDisk API

3. 其他常用函数功能描述

3.1 图加载

- `config`：需要加载的配置参数。该参数内保存了该图的一般信息（如数据来源，算法名称，数据输入、输出路径，点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数。
- `edge_direction_policy`：指定图为有向或无向，包含三种模式，分别为DUAL_DIRECTION、MAKE_SYMMETRIC以及INPUT_SYMMETRIC。其中DUAL_DIRECTION为默认的图加载方式。
DUAL_DIRECTION : 输入文件为非对称图，加载图为非对称图。
MAKE_SYMMETRIC : 输入文件为非对称图，加载图为对称图。
INPUT_SYMMETRIC : 输入文件为对称图，加载图为对称图。
对应的详细介绍见lgraph文件夹下的olap_config.h文件的`enum EdgeDirectionPolicy`。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '3. 其他常用函数功能描述', 'Header 3': '3.1 图加载'}",空,空,空,空,空,空,空,空
当指定的顶点ID不存在，并且nearest参数为true时，Goto函数将如何处理？,"page_content='src/lgraph_api/lgraph_edge_iterator.cpp/ #define ThrowIfInvalid()                                    \
    do {                                                    \
        if (!txn_->IsValid()) THROW_CODE(InvalidTxn);      \
        if (!it_->IsValid())  THROW_CODE(InvalidIterator);  \
    } while (0)

OutEdgeIterator::OutEdgeIterator(lgraph::graph::OutEdgeIterator&& impl,
                                 const std::shared_ptr<lgraph::Transaction>& txn)
    : it_(new lgraph::graph::OutEdgeIterator(std::move(impl))), txn_(txn) {}

OutEdgeIterator::OutEdgeIterator(OutEdgeIterator&& rhs)
    : it_(std::move(rhs.it_)), txn_(std::move(rhs.txn_)) {}

OutEdgeIterator& OutEdgeIterator::operator=(OutEdgeIterator&& rhs) {
    it_ = std::move(rhs.it_);
    txn_ = std::move(rhs.txn_);
    return *this;
}

OutEdgeIterator::~OutEdgeIterator() {}

void OutEdgeIterator::Close() noexcept { it_->Close(); }

bool OutEdgeIterator::Goto(EdgeUid euid, bool nearest) {
    if (!txn_->IsValid()) THROW_CODE(InvalidTxn);
    return it_->Goto(euid, nearest);
}

bool OutEdgeIterator::Next() {
    ThrowIfInvalid();
    return it_->Next();
}

EdgeUid OutEdgeIterator::GetUid() const {
    ThrowIfInvalid();
    return it_->GetUid();
}

int64_t OutEdgeIterator::GetDst() const {
    ThrowIfInvalid();
    return it_->GetDst();
}

int64_t OutEdgeIterator::GetEdgeId() const {
    ThrowIfInvalid();
    return it_->GetEdgeId();
}

int64_t OutEdgeIterator::GetSrc() const {
    ThrowIfInvalid();
    return it_->GetSrc();
}' metadata={'file_name': 'lgraph_edge_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_edge_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_edge_iterator.cpp'}",空,空,空,空,空,空,空,空,空
在BFS算法中，最终返回的结果是什么？,"page_content='内置算法

基础算法包

广度优先搜索

广度优先搜索实现了Breadth-first Search算法，从根点开始，沿着图的宽度遍历所有可访问点。返回结果为遍历点个数。算法内容请参考 [https://en.wikipedia.org/wiki/Breadth-first_search](https://en.wikipedia.org/wiki/Breadth-first_search ""bfs wiki"")。' metadata={'Header 1': '内置算法', 'Header 2': '基础算法包', 'Header 3': '广度优先搜索'}","page_content='OlapOnDisk API

2. 算法举例

2.4 bfs算法流程

if (parent[dst] == (size_t)-1) {
auto lock = graph.GuardVertexLock(dst);
if (parent[dst] == (size_t)-1) {
parent[dst] = vi;
num_activations += 1;
active_out.Add(dst);       //存放当前循环阶段找到的节点
}
}
}
return num_activations;
},
active_in);
active_in.Swap(active_out);
}
// 返回全部节点数
return discovered_vertices;
}
```' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '2. 算法举例', 'Header 3': '2.4 bfs算法流程'}","page_content='OlapOnDisk API

2. 算法举例

2.4 bfs算法流程

`bfs`主流程有两个输入参数，快照类（子图）还有迭代次数，整体流程可以分为以下几步：  
1. 相关定义、数据结构的初始化
2. 使用批处理函数对每个节点进行循环计算，每一轮找到与当前节点相邻的全部节点，并在该轮次终止时进行交换。
3. 直到找到全部节点，返回节点个数discovered_vertices。  
```C++
size_t BFSCore(Graph<Empty>& graph, size_t root_vid, ParallelVector<size_t>& parent){' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '2. 算法举例', 'Header 3': '2.4 bfs算法流程'}",空,空,空,空,空,空,空
TuGraph的“refresh_time”的默认设置是什么？,空,空,空,空,空,空,空,空,空,空
如何在GetEdgeProp命令中指定timestamp字段以查找特定时间戳的边属性？,空,空,空,空,空,空,空,空,空,空
使用TuGraph Browser时，默认的端口号是多少？,"page_content='可视化操作手册

2.操作指南

2.1.访问

当用户完成图数据库的安装后，可以通过浏览器访问Browser。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7070。  
- 例如：127.0.0.1:7070。
- 推荐使用Chrome。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.1.访问'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
5. 前端访问  
访问tugraph-db-browser: `http://x.x.x.x:7070`，数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。
首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='可视化操作手册（旧版）

操作详情

1.连接数据库

当用户完成图数据库的安装后，可以通过浏览器进行访问，TuGraph Browser 工具。用户只需要在浏览器地址栏输入：TuGraph 所在服务器的 IP:Port。默认的端口使用的是 7090。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '1.连接数据库'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
**方式二**  
```shell
docker run -dt -p 7070:7070  -p 7687:7687 -p 9090:9090 -v /root/tugraph/data:/var/lib/lgraph/data  -v /root/tugraph/log:/var/log/lgraph_log \' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}","page_content='Docker部署

2.现有Docker Image

2.5. 运行服务

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.5. 运行服务'}",空,空,空,空,空
TuGraph-DB是否支持运行图算法？如果支持，有哪些示例图算法可以参考？,"page_content='图算法介绍

2\. 流图推理简介

TuGraph计算引擎（TuGraph Analytics\[1\]）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持了丰富的图计算算法。TuGraph Analytics的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大得提高了数据的计算效率和实时性。TuGraph Analytics解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。  
随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，是无法基于传统的图迭代计算模式直接高效地表达的。' metadata={'Header 1': '图算法介绍', 'Header 2': '2\\. 流图推理简介'}","page_content='🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！

仅需 5 步，即可呈现 🎊

4. 演示

<img width=""332"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/7ca76607-41a1-4afe-9427-cf7599de6889"">  
同样的，Tugraph Analytics 终端也会实时输出操作信息，并自动启动计算任务。  
<img width=""611"" alt=""image"" src=""https://github.com/TuGraph-family/tugraph-analytics/assets/25787943/d8d0d73a-4c07-4ecd-bcac-4633a742933a"">' metadata={'Header 1': '🌈 [G6VP](https://github.com/antvis/g6vp) 现在支持与 Tugraph 协作实现流图作业可视化了！', 'Header 2': '仅需 5 步，即可呈现 🎊', 'Header 3': '4. 演示'}","page_content='图算法介绍

2\. 流图推理简介

受上述问题启发，我们思考是否可以将TuGraph Analytics的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：  
-   对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。  
-   对于AI算法工程师，可以通过TuGraph Analytics分布式流式计算的能力实现实时的模型推理。  
众所周知，在深度学习为代表的数据科学领域，Python已经成为数据分析、模型训练和推理框架的主流开发语言，并提供了丰富的开发库和框架生态。而以Hadoop全家桶为代表的大数据计算引擎领域，基于Java语言开发的系统仍占据一席之地，当然TuGraph Analytics也在其中。这种语言差异带来的“互操作性”成本，使得相当一部分大数据和AI生态组件无法轻松地融合，这也是TuGraph Analytics支持图推理需要亟待解决的问题。' metadata={'Header 1': '图算法介绍', 'Header 2': '2\\. 流图推理简介'}","page_content='技术规划

2. 已完成功能

| 4.0.0 | ISO GQL支持，新增11个开源图算法，支持m1 Docker | 2023.9.6   |
| 4.0.1 | 支持时序边排序，新增5个开源图算法                | 2023.9.28  |
| 4.1.0 | 支持Bolt协议，支持快速在线全量导入，支持地理空间数据类型   | 2023.12.25 |  
除此之外，TuGraph-DB搭建了较为完善的质量体系，涵盖自动化的单元测试、集成测试、性能测试等。  
更详细的描述可以在源码目录在的 ""[root]/release/CHANGELOG.md"" 文件查看。' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}","page_content='快速上手

1.简介

TuGraph 是蚂蚁集团自主研发的大规模图计算系统，提供图数据库引擎和图分析引擎。其主要特点是大数据量存储和计算，高吞吐率，以及灵活的 API，同时支持高效的在线事务处理（OLTP）和在线分析处理（OLAP）。 LightGraph、GeaGraph 是 TuGraph 的曾用名。  
主要功能特征包括：  
- 标签属性图模型
- 支持多图
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 基于 web 客户端的图可视化工具
- 支持 RESTful API 和 RPC
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程
- 适用于高效图算法开发的 Traversal API  
性能及可扩展性特征包括：  
- TB 级大容量
- 千万点/秒的高吞吐率
- 高可用性支持
- 高性能批量导入
- 在线/离线备份' metadata={'Header 1': '快速上手', 'Header 2': '1.简介'}",空,空,空,空,空
Python存储过程接口包含哪些重要组件和功能？,"page_content='Procedure API

5.Procedure v2接口

5.2.加载存储过程

```  
#### 5.2.2.获取存储过程详情  
在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')
>>> r.status_code
200
>>> r.text
'{""description"":""Custom Page Rank Procedure"", ""name"":""custom_pagerank"", ""read_only"":true, ""code_base64"":<CODE>, ""code_type"":""so""}'
```  
#### 5.2.3.调用存储过程  
调用存储过程的代码示例如下：  
```Cypher
CALL plugin.cpp.custom_pagerank(10)
YIELD node, pr WITH node, pr' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.2.加载存储过程'}","page_content='Procedure API

4.1.编写存储过程

4.1.2.编写Python存储过程

与 C++类似，Python 存储过程也可以调用 core API，一个简单的例子如下：  
```python
def Process(db, input):
txn = db.CreateReadTxn()
it = txn.GetVertexIterator()
n = 0
while it.IsValid():
if it.GetLabel() == 'student' and it['age'] and it['age'] == 10:
n = n + 1
it.Next()
return (True, str(nv))
```  
Python 存储过程返回的是一个 tuple，其中第一个元素是一个布尔值，表示该存储过程是否成功执行；第二个元素是一个`str`，里面是需要返回的结果。  
Python 存储过程不需要编译，可以直接加载。' metadata={'Header 1': 'Procedure API', 'Header 2': '4.1.编写存储过程', 'Header 3': '4.1.2.编写Python存储过程'}","page_content='Procedure API

5.Procedure v2接口

5.2.加载存储过程

#### 5.2.1.列出已加载的存储过程  
在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')
>>> r.status_code
200
>>> r.text
'{""plugins"":[{""description"":""Custom Page Rank Procedure"", ""name"":""custom_pagerank"", ""read_only"":true}]}'
```  
#### 5.2.2.获取存储过程详情  
在服务器运行过程中，用户可以随时获取单个存储过程的详情，包括代码。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')
>>> r.status_code
200
>>> r.text' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.2.加载存储过程'}","page_content='Procedure API

5.Procedure v2接口

5.2.加载存储过程

YIELD node, pr WITH node, pr
MATCH(node)-[r]->(n) RETURN node, r, n, pr
```  
#### 5.2.4.删除存储过程  
删除存储过程只需要如下调用：  
```python
>>> r = requests.delete(url='http://127.0.0.1:7071/db/school/cpp_plugin/custom_pagerank')
>>> r.status_code
200
```  
与加载存储过程类似，只有管理员用户才能删除存储过程。  
#### 5.2.5.更新存储过程  
更新存储过程需要执行如下两个步骤：  
1.  删除已存在的存储过程
2.  安装新的存储过程  
TuGraph 较为谨慎地管理存储过程操作的并发性，更新存储过程不会影响现有存储过程的运行。' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.2.加载存储过程'}","page_content='Procedure API

5.Procedure v2接口

5.2.加载存储过程

```  
需要注意的是，这时的`data['code']`是一个经过 base64 处理的字符串，`custom_pagerank.so`中的二进制代码是无法通过 JSON 直接传输的。此外，存储过程的加载和删除都只能由具有管理员权限的用户来操作。  
存储过程加载之后会被保存在数据库中，在服务器重启后也会被自动加载。此外，如果需要对存储过程进行更新，调用的 REST API 也是同样的。建议用户在更新存储过程时更新相应描述，以便区分不同版本的存储过程。  
#### 5.2.1.列出已加载的存储过程  
在服务器运行过程中，用户可以随时获取存储过程列表。其调用如下：  
```python
>>> r = requests.get('http://127.0.0.1:7071/db/school/cpp_plugin')
>>> r.status_code
200
>>> r.text' metadata={'Header 1': 'Procedure API', 'Header 2': '5.Procedure v2接口', 'Header 3': '5.2.加载存储过程'}",空,空,空,空,空
当执行 CallGql 函数时，成功和失败分别会返回什么信息？,"page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ bool RpcClient::CallGql(std::string &result, const std::string &gql,
                           const std::string &graph, bool json_format,
                           double timeout, const std::string& url) {
    if (client_type == SINGLE_CONNECTION) {
        return base_client->CallGql(result, gql, graph, json_format, timeout);
    }
    auto fun = [&]{
        if (!url.empty())
            return GetClientByNode(url)->CallGql(result, gql, graph, json_format, timeout);
        return GetClient(lgraph::GraphQueryType::GQL, gql, graph)->
            CallGql(result, gql, graph, json_format, timeout);
    };
    return DoubleCheckQuery(fun);
}

bool RpcClient::CallGqlToLeader(std::string& result, const std::string& gql,
                                const std::string& graph, bool json_format, double timeout) {
    if (client_type == SINGLE_CONNECTION) {
        return base_client->CallGql(result, gql, graph, json_format, timeout);
    } else {
        return DoubleCheckQuery([&] {
            return leader_client->CallGql(result, gql, graph, json_format, timeout);
        });
    }
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='C++客户端

2.使用示例

2.4.调用GQL

@param [in]  graph       (Optional) the graph to query.
@param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary
format.
@param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.
@param [in]  url         (Optional) Node address of calling gql.
@returns True if it succeeds, false if it fails.
```
本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.4.调用GQL'}","page_content='C++客户端

2.使用示例

2.5.向leader发送GQL请求

const std::string& graph = ""default"", bool json_format = true,
double timeout = 0);
@param [out] result      The result.
@param [in]  gql         inquire statement.
@param [in]  graph       (Optional) the graph to query.
@param [in]  json_format (Optional) Returns the format， true is json，Otherwise, binary
format.
@param [in]  timeout     (Optional) Maximum execution time, overruns will be interrupted.
@returns True if it succeeds, false if it fails.
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.5.向leader发送GQL请求'}","page_content='Java客户端

2.使用示例

2.4.调用GQL

@param timeout: Maximum execution time, overruns will be interrupted
@param url: (Optional) Node address of calling GQL
@return: the result of GQL query execution
public String callGql(String gql, String graph, double timeout, String url)
```
本接口支持在单机模式和HA模式下使用。其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。
注：JAVA不支持默认参数，因此，JAVA中的默认参数是使用重载函数实现的。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.4.调用GQL'}","page_content='Java客户端

2.使用示例

2.4.调用GQL

```java
String res = client.callGql(""CALL db.edgeLabels()"", ""default"", 10);
log.info(""db.edgeLabels() : "" + res);
```
```
@param gql: inquire statement.
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@param url: (Optional) Node address of calling GQL
@return: the result of GQL query execution
public String callGql(String gql, String graph, double timeout, String url)
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.4.调用GQL'}",空,空,空,空,空
如何在TuGraph中执行复杂的图分析操作？,"page_content='HTAP

2.设计

在 TuGraph 中，OLTP 为图事务引擎，在图 4.4对应事务操作；OLAP 为图分析引擎，对应简单图分析操作（比如 SPSP）和复杂图分析操作（比如 PageRank），前者可以直接在图存储上执行，而后者需要额外导出快照执行。  
- 事务操作，即图事务引擎测的操作，为局部图的增删查改操作，典型的应用为 K 跳访问 K-Hop。
- 简单分析操作，是图分析引擎中较为简单的部分，通常也是局部的图分析操作，比如两点间最短路算法 SPSP、Jaccard 算法。
- 复杂分析操作，是图分析引擎中较为复杂的部分，通常涉及全图的多轮数据迭代操作，比如网页排序算法 PageRank、社区发现算法 Louvain。  
如架构图所示，我们在图中增加了外部存储，使得图分析的数据源不局限在图数据库中，可以直接从文本文件读取。  
- 图存储，即图数据库中的存储，有精心设计的数据结构，能够完成实时增删查改。
- 外部存储，可以是 RDBMS 或文本文件，以边表的简单方式存储，仅供一次性批量读取，和批量结果写入。在计算层，和整体架构图中的接口对应。' metadata={'Header 1': 'HTAP', 'Header 2': '2.设计'}","page_content='Traversal API

1. 简介

TuGraph 强大的在线分析处理（OLAP）能力是其区别于其它图数据库的一个重要特性。
借助 C++ OLAP API（olap_on_db.h），用户可以快速地导出一个需要进行复杂分析的子图，然后在其上运行诸如 PageRank、连通分量、社区发现等迭代式图计算过程，最后根据结果做出相应决策。
导出和计算的过程都可以通过并行处理的方式进行加速，从而实现几乎实时的分析处理，避免了传统解决方案需要将数据导出、转换、再导入（ETL）到专门的分析系统进行离线处理的冗长步骤。  
TuGraph 内置了大量常用的图分析算法和丰富的辅助接口，因此用户几乎不需要自己来实现具体的图计算过程，只需在实现自己的存储过程时将相应算法库的头文件（.h 文件）包含到自己程序中，并在编译时链接相应的动态库文件（.so）即可。
一般情况下，用户需要自己实现的只有将需要分析的子图抽取出来的过程。  
目前 Traversal API 仅支持 C++。' metadata={'Header 1': 'Traversal API', 'Header 2': '1. 简介'}","page_content='图分析引擎技术解析

1 TuGraph 图分析引擎概览

TuGraph 的图分析引擎，面向的场景主要是全图/全量数据分析类的任务。借助 TuGraph 的 C++ 图分析引擎 API ，用户可以对不同数据来源的图数据快速导出一个待处理的复杂子图，然后在该子图上运行诸如 BFS、PageRank、LPA、WCC 等迭代式图算法，最后根据运行结果做出相应的对策。 在 TuGraph 中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
根据数据来源及实现不同，可分为 Procedure、Embed 和 Standalone 三种运行模式。其中 Procedure 模式和 Embed 模式的数据源是图存储中加载图数据，分别适用于 Client/Server 部署，以及服务端直接调用，后者多用于调试。  
Standalone 模式的数据源是 TXT、二进制、ODPS 文件等外部数据源，能够独立于图数据存储直接运行分析算法。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '1 TuGraph 图分析引擎概览'}","page_content='功能概览

3.计算层

- __图神经网络引擎__，通常也为全图迭代。图神经网络引擎除了基于图拓扑的操作，也需要集成一个机器学习的框架来处理向量操作，比如 PyTorch、MXNet、TenserFlow。  
三个引擎的操作逻辑不尽相同，独立配置资源池。事图事务引擎基于RPC操作设置了一个线程池，每接受客户端的一个操作，从线程中取一个线程来处理，并发执行的数量等于RPC线程池的容量，通常配置为服务器的核数。图分析引擎有一个分析线程池，每个图分析任务会并发执行，即用所有的线程来执行一个任务，来加速操作的性能。TuGraph图分析操作串行执行的特性会一定程度限制用户的使用体验，并发的图分析的需求可以通过高可用部署的方式，增加机器资源来处理，或者接入外部的任务调度器，将数据传到实时调度的容器来计算。图神经网络操作在图上的操作会复用图事务引擎或图分析引擎的资源，向量的操作会起单独的资源，在机器学习框架中可以使用GPU等单独的加速硬件。' metadata={'Header 1': '功能概览', 'Header 2': '3.计算层'}","page_content='OlapOnDisk API

1. 简介

TuGraph的Standalone模式可用于加载图数据文件，其中图数据文件来源可包含text文本文件、BINARY_FILE二进制文件和ODPS源。在该模式下，TuGraph可实现多数据来源快速加载成图，然后在该图上运行如BFS、WCC、SSSP等迭代式算法，并输出最终结果至终端。  
在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
TuGraph内置了大量的常见图分析算法和丰富的辅助接口，因此用户几乎不需要自己实现具体的图计算过程，只需要在实现自己的存储过程的时候将相应算法库的头文件(.h)包含到自己的程序中，并在编译阶段链接自己的动态库文件即可。  
该文档主要介绍了Standalone的常用接口，使用到的辅助函数主要包含在OlapOnDB类。同时为帮助用户理解方便，对BFS算法进行举例说明。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '1. 简介'}",空,空,空,空,空
filter_output_default函数的主要作用是什么？,"page_content='OlapOnDisk API

3. 其他常用函数功能描述

3.2 图写入

- `void Write(ConfigBase<EdgeData> & config, ParallelVector<VertexData>& array, size_t array_size, std::string name, std::function<bool(VertexData &)> filter_output = filter_output_default<VertexData&>)`：把array中数据写回文件中，各参数表示意义分别是：
- `config`：需要加载的配置参数。该参数内保存了该图的一般信息（如数据来源，算法名称，数据输入、输出路径，点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数。
- `array`：待写入数据的数组
- `array_size`：待写入数据的数字长度
- `name`：算法名称
- `filter_output`：写入数据规则函数，待写入数据需要满足该函数的要求。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '3. 其他常用函数功能描述', 'Header 3': '3.2 图写入'}",空,空,空,空,空,空,空,空,空
如何在Java运行时配置MyBatis Generator的XML配置文件中的targetProject？,空,空,空,空,空,空,空,空,空,空
"在给定的代码中，`@Property(""class"")`注解指定了数据库字段名为“class”。请问这个注解在代码中具体是如何使用的？",空,空,空,空,空,空,空,空,空,空
在TuGraph中，是否可以使用Cypher语句删除图中的重复关系？,"page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

简介

TuGraph 图数据库提供了 JAVA、C++、Python 等多种语言的 SDK 支持，方便客户在各种场景下使用。用户使用 SDK 向TuGraph服务器发送Cypher请求，服务器则以 JSON形式返回数据。近日，TuGraph 推出了一款面向 JAVA 客户端用户的开发工具 TuGraph-OGM (Object Graph Mapping)，为用户提供了对象操作接口，相较 Cypher/JSON 接口应用起来更加便捷。  
OGM 类似于关系数据库中的 ORM（Object Relational Model），可以将数据库返回的数据自动映射成 JAVA 中的对象，方便用户读取，而用户对这些对象的更新操作也可以被自动翻译成 Cypher 语句发送给服务器。这样即便是完全不懂 Cypher 的用户，也可以通过操作对象与数据库进行交互，大大降低了图数据库的使用门槛。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '简介'}","page_content='TuGraph-DataX

4.导出TuGraph

4.2.参数说明

在使用DataX导出TuGraph数据时，需要将reader设置为tugraphreader并配置以下5个参数：  
* **url**
* 描述：TuGraph的bolt server地址 <br />
* 必选：是 <br />
* 默认值：无 <br />  
* **username**
* 描述：TuGraph的用户名 <br />
* 必选：是 <br />
* 默认值：无 <br />  
* **password**
* 描述：TuGraph的密码 <br />
* 必选：是 <br />
* 默认值：无 <br />  
* **graphName**
* 描述：所选取的需要同步的TuGraph子图 <br />
* 必选：是 <br />
* 默认值：无 <br />  
* **queryCypher**
* 描述：通过cypher语句读取TuGraph中的数据 <br />
* 必选：否 <br />
* 默认值：无 <br />' metadata={'Header 1': 'TuGraph-DataX', 'Header 2': '4.导出TuGraph', 'Header 3': '4.2.参数说明'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。
- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)  
##### 2.4.4.2.配置查询  
在`配置查询`功能中，用户可以选择节点类型和输入属性条件来查询图数据，并加载数据至画布区域进行展示。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-模板查询](../../../images/browser/graphanalysis-queryfilter-configurequery.png)  
##### 2.4.4.3.画布分析' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}",空,空,空,空,空,空
在默认情况下，第一次快照的时间是如何设置的？,"page_content='src/server/server_main.cpp/ if (!config->ha_first_snapshot_start_time.empty()) {
        std::tm tm = {};
        std::istringstream ss(config->ha_first_snapshot_start_time);
        ss >> std::get_time(&tm, ""%H:%M:%S"");
        if (ss.fail() || !ss.eof() || tm.tm_hour < 0 || tm.tm_hour > 23 ||
            tm.tm_min < 0 || tm.tm_min > 59 || tm.tm_sec < 0 || tm.tm_sec > 59) {
            LOG_ERROR() << ""ha_first_snapshot_start_time must be a regular time between ""
                           ""00:00:00-23:59:59, however it is ""
                        << config->ha_first_snapshot_start_time;
            return -1;
        }
    }
    // now run the service
    lgraph::LGraphDaemon daemon(config);
    if (cmd == ""run"") {
        return daemon.Run();
    } else if (cmd == ""start"") {
        return daemon.Start();
    } else if (cmd == ""restart"") {
        return daemon.Restart();
    } else if (cmd == ""stop"") {
        return daemon.Stop();
    }
}' metadata={'file_name': 'server_main.cpp', 'file_path': 'src/server/server_main.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/server/server_main.cpp'}","page_content='src/server/ha_state_machine.cpp/ if (config_.ha_first_snapshot_start_time != """") {
        braft::FLAGS_enable_first_snapshot_config = true;
        braft::FLAGS_first_snapshot_start_time =
            config_.ha_first_snapshot_start_time;
    }
    // start braft::Node
    braft::Node* node = new braft::Node(""lgraph"", braft::PeerId(addr, 0,
                                                                config_.ha_is_witness));
    braft::NodeOptions node_options;
    if (config_.ha_bootstrap_role == 1) {
        node_options.initial_conf.add_peer(braft::PeerId(addr));
    } else if (config_.ha_bootstrap_role == 0) {
        if (node_options.initial_conf.parse_from(config_.ha_conf) != 0) {
            ::lgraph::StateMachine::Stop();
            throw std::runtime_error(""Fail to parse configuration "" + config_.ha_conf);
        }
    }
    braft::FLAGS_raft_enable_witness_to_leader = config_.ha_enable_witness_to_leader;
    node_options.election_timeout_ms = config_.ha_election_timeout_ms;
    node_options.fsm = this;
    node_options.node_owns_fsm = false;
    node_options.snapshot_interval_s = config_.ha_snapshot_interval_s;
    std::string prefix = ""local://"" + config_.ha_dir;
    node_options.log_uri = prefix + ""/log"";
    node_options.raft_meta_uri = prefix + ""/raft_meta"";
    node_options.snapshot_uri = prefix + ""/snapshot"";
    node_options.disable_cli = false;
    node_options.witness = config_.ha_is_witness;
    int r = node->init(node_options);' metadata={'file_name': 'ha_state_machine.cpp', 'file_path': 'src/server/ha_state_machine.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/server/ha_state_machine.cpp'}",空,空,空,空,空,空,空,空
如果我想提交非原创作品给蚂蚁集团，我需要标注哪些相关信息？,空,空,空,空,空,空,空,空,空,空
在TuGraph的web端导入点数据后，为什么使用不同的查询方式会得到不同的结果？,"page_content='QA汇总

内核引擎QA

单机QPS

Q: TuGraph 单机的QPS是多少？
A: 不同数据规模，不同查询操作的QPS差异较大，比如LDBC SNB典型图操作超过1.2万，参考测试结果：https://www.tugraph.org/blog?id=0' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '单机QPS'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

- path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）
- header（可选，数字，头信息占文件起始的几行，没有就是 0）
- format（必须选，只能是 JSON 或者 CSV）
- label（必选，字符串）
- columns（数组形式）
- SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)
- DST_ID (特殊字符串，仅边有，代表这列是目的点数据)
- SKIP  (特殊字符串，代表跳过这列数据)
- [property]
- SRC_ID (仅边配置，值是起始点标签)
- DST_ID (仅边配置，值是目的点标签)  
#### 3.1.2.索引长度
因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。
##### 3.1.2.1.unique索引' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}",空,空,空,空,空,空,空
对象图映射（OGM）支持哪些功能和特性？,"page_content='功能概览

5.客户端工具

OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。  
命令行工具`lgraph_cypher`是查询客户端，可用于向 TuGraph 服务器提交 OpenCypher 请求。`lgraph_cypher`客户端有两种执行模式：单命令模式和交互式模式。' metadata={'Header 1': '功能概览', 'Header 2': '5.客户端工具'}","page_content='TuGraph Java Client

特性

- Java中的RPC客户端
- OGM，即对象图映射，支持将图中的实体和关系映射到Java对象，从而加速Java开发过程。' metadata={'Header 1': 'TuGraph Java Client', 'Header 2': '特性'}","page_content='TuGraph-OGM

1.简介

> TuGraph-OGM 项目在其他仓库开源。  
TuGraph-OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。同时 TuGraph-OGM 兼容 Neo4j-OGM，Neo4j 生态用户可以无缝迁移到 TuGraph 数据库上。' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '1.简介'}","page_content='功能概览

5.客户端工具

客户端主要分为各种编程语言的SDK，OGM以及命令行工具。  
客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。  
OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。' metadata={'Header 1': '功能概览', 'Header 2': '5.客户端工具'}","page_content='TuGraph-OGM

简介

TuGraph-OGM(Object Graph Mapping), 源自 `Neo4j-OGM` 项目，TuGraph-OGM
支持将JAVA对象（POJO）映射到TuGraph中，JAVA中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此JAVA开发人员可以在熟悉的生态中轻松地使用TuGraph数据库。同时TuGraph-OGM兼容Neo4j-OGM，Neo4j生态用户可以无缝迁移到TuGraph数据库上。' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '简介'}",空,空,空,空,空
如何在单节点模式下实例化liblgraph_client_python.client对象？,"page_content='Python客户端

3.RPC Client

3.1.实例化client对象

#### 3.1.1.实例化单节点client对象
当以单节点模式启动server时，client按照如下格式进行实例化
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, url: str, user: str, password: str)
```  
#### 3.1.2.实例化HA集群直连连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.1.实例化client对象'}","page_content='Python客户端

3.RPC Client

3.1.实例化client对象

client按照如下格式进行实例化
```python
client = liblgraph_client_python.client([""189.33.97.23:9091"",""189.33.97.24:9091"", ""189.33.97.25:9091""], ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, urls: list, user: str, password: str)
```
因为用户连接的网址和server启动时配置的信息不同，不能通过向集群发请求的方式自动更新client连接池，所以需要在启动
client时手动传入所有集群中节点的网址，并在集群节点变更时手动重启client。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.1.实例化client对象'}","page_content='Python客户端

3.RPC Client

3.1.实例化client对象

```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 3.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化
```python
client = liblgraph_client_python.client([""189.33.97.23:9091"",""189.33.97.24:9091"", ""189.33.97.25:9091""], ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, urls: list, user: str, password: str)
```' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.1.实例化client对象'}","page_content='Python客户端

3.RPC Client

3.1.实例化client对象

```  
#### 3.1.2.实例化HA集群直连连接client对象
当服务器上部署的HA集群可以使用ha_conf中配置的网址直接连接时，client按照如下格式进行实例化。
```python
client = liblgraph_client_python.client(""127.0.0.1:19099"", ""admin"", ""73@TuGraph"")
```
```
client(self: liblgraph_client_python.client, url: str, user: str, password: str)
```
用户只需要传入HA集群中的任意一个节点的url即可，client会根据server端返回的查询信息自动维护连接池，在HA集群横向扩容时
也不需要手动重启client。  
#### 3.1.3.实例化HA集群间接连接client对象
当服务器上部署的HA集群不能使用ha_conf中配置的网址直接连接而必须使用间接网址（如阿里云公网网址）连接时，
client按照如下格式进行实例化
```python' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.1.实例化client对象'}","page_content='Python客户端

3.RPC Client

3.11.从字节流中导入schema

```python
ret, res = client.importSchemaFromContent(schema, ""default"", 1000)
```
```
importSchemaFromContent(self: liblgraph_client_python.client, schema: str, graph: str, json_format: bool, timeout: float) -> (bool, str)
```
本接口支持在单机模式和HA模式下使用。其中，由于导入schema是写请求，HA模式下的client只能向leader发送导入schema请求。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.11.从字节流中导入schema'}",空,空,空,空,空
如果传递给 `GetRoleInfo` 函数的角色名非法，会抛出哪种类型的异常？,空,空,空,空,空,空,空,空,空,空
TuGraph 的部署方式有哪些？,"page_content='功能概览

1.1.部署方式

TuGraph目前提供云部署、Docker部署以及安装包部署三种部署方式，用户可根据实际情况选择适合的部署方式。' metadata={'Header 1': '功能概览', 'Header 2': '1.1.部署方式'}","page_content='部署高可用模式

1.原理

提供服务，该`leader`将每个请求复制同步到`follower`，并在请求同步到服务器后才能响应客户端。这样，如果任何服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`
服务器发生故障，其他服务器将自动选择出新的`leader`。  
TuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。
而`witness`节点是一种只接收心跳和日志但不保存数据的节点。根据部署需求，`leader`节点和`follower`节点可以灵活的部署为`replica`节点或`witness`节点。
基于此，TuGraph高可用模式的部署方式有两种：一是普通部署模式，二是带witness的简约部署模式。  
对于普通部署模式，`leader`和所有`follower`均为`replica`类型的节点。写入请求由`leader`提供服务，该`leader`将每个请求复制同步到`follower`，' metadata={'Header 1': '部署高可用模式', 'Header 2': '1.原理'}","page_content='环境和版本选择

3. 部署方式选择

TuGraph部署仅需一台服务器（高可用模式需要多台），可根据实际资源情况和使用场景，选择适合的部署方式。  
| 部署方式     | 描述                   | 备注                                                                                      |
|----------|----------------------|-----------------------------------------------------------------------------------------|
| 云部署      | 阿里云计算巢一键部署，免费试用      | 新手适用，流程参考 [链接](../5.installation&running/5.cloud-deployment.md)              |' metadata={'Header 1': '环境和版本选择', 'Header 2': '3. 部署方式选择'}","page_content='部署高可用模式

1.原理

TuGraph 通过多机热备份来提供高可用（HA）模式。在高可用模式下，对数据库的写操作会被同步到所有服务器（非witness）上，这样即使有部分服务器宕机也不会影响服务的可用性。  
高可用模式启动时，多个 TuGraph 服务器组成一个备份组，即高可用集群。每个备份组由三个或更多 TuGraph 服务器组成，其中某台服务器会作为`leader`，而其他复制组服务器则作为`follower`。写入请求由`leader`
提供服务，该`leader`将每个请求复制同步到`follower`，并在请求同步到服务器后才能响应客户端。这样，如果任何服务器发生故障，其他服务器仍将具有到目前为止已写入的所有数据。如果`leader`
服务器发生故障，其他服务器将自动选择出新的`leader`。  
TuGraph的高可用模式提供两种类型的节点：`replica`节点和`witness`节点。其中，`replica`节点是普通节点，有日志有数据，可对外提供服务。' metadata={'Header 1': '部署高可用模式', 'Header 2': '1.原理'}","page_content='文档地图

快速上手

> 基于[阿里云计算巢](5.installation&running/5.cloud-deployment.md)或[Docker方式](5.installation&running/3.docker-deployment.md)快速部署TuGraph。  
> 通过产品内置的场景上手体验：[电影](./3.quick-start/2.demo/1.movie.md)、[流浪地球](./3.quick-start/2.demo/2.wandering-earth.md)、[三体](./3.quick-start/2.demo/3.the-three-body.md)、[三国](./3.quick-start/2.demo/4.three-kingdoms.md)。  
> 可视化操作手册看这里：[可视化操作手册](./4.user-guide/1.tugraph-browser.md)、[可视化操作手册（旧版）](./4.user-guide/2.tugraph-browser-legacy.md)。' metadata={'Header 1': '文档地图', 'Header 2': '快速上手'}",空,空,空,空,空
如何根据使用MATCH和SKIP语句的查询结果，获取跳过第一行后返回的第一位人物的名字？,"page_content='Cypher API

2.Clauses

2.5.SKIP

- ✓ Skip first three records  
```
MATCH (n:person)
RETURN n.name
ORDER BY n.name
SKIP 3
```  
- ✓ Return middle two records  
```
MATCH (n:person)
RETURN n.name
ORDER BY n.name
SKIP 1
LIMIT 2
```  
- ❏ Using an expression with SKIP to return a subset of the records  
```
MATCH (n:person)
RETURN n.name
ORDER BY n.name
SKIP toInteger(3*rand())+ 1
```' metadata={'Header 1': 'Cypher API', 'Header 2': '2.Clauses', 'Header 3': '2.5.SKIP'}","page_content='ISO GQL

2.Clauses

2.7.SKIP

`SKIP`指定结果偏移行数。  
#### 未使用SKIP  
```
MATCH (n:Person)
RETURN n.name LIMIT 3
```  
返回结果  
```JSON
[{""n.name"":""Christopher Nolan""},{""n.name"":""Corin Redgrave""},{""n.name"":""Dennis Quaid""}]
```  
#### 使用SKIP  
```
MATCH (n:Person)
RETURN n.name SKIP 1 LIMIT 2
```  
返回结果
```JSON
[{""n.name"":""Corin Redgrave""},{""n.name"":""Dennis Quaid""}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.7.SKIP'}",空,空,空,空,空,空,空,空
如果在导入数据时操作失败，是否可以继续导入其他数据？,"page_content='C++客户端

2.使用示例

2.12.从字节流中导入点边数据

@param [in]  continue_on_error   (Optional) whether to continue when importing data fails.
@param [in]  thread_nums         (Optional) maximum number of threads.
@param [in]  graph               (Optional) the graph to query.
@param [in]  json_format         (Optional) Returns the format， true is json，Otherwise,
binary format.
@param [in]  timeout             (Optional) Maximum execution time, overruns will be
interrupted.
@returns True if it succeeds, false if it fails.
```' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='Java客户端

2.使用示例

2.14.从文件中导入点边数据

@param delimiter: data separator
@param continueOnError: whether to continue when importing data fails
@param threadNums: maximum number of threads
@param skipPackages: skip packages number
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@return: the result of import data
public boolean importDataFromFile(String confFile, String delimiter, boolean continueOnError, int threadNums,' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.14.从文件中导入点边数据'}","page_content='C++客户端

2.使用示例

2.12.从字节流中导入点边数据

double timeout = 0);
@param [out] result              The result.
@param [in]  desc                data format description.
@param [in]  data                the data to be imported.
@param [in]  delimiter           data separator.
@param [in]  continue_on_error   (Optional) whether to continue when importing data fails.
@param [in]  thread_nums         (Optional) maximum number of threads.
@param [in]  graph               (Optional) the graph to query.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

###### c.数据映射  
文件上传成功后，需要在`数据导入`页面设置`数据对应表`，将数据文件中的数据列和目标点/边、对应属性建立映射关系。  
- 数据对应表：展示已经上传的数据问题。
- 文件名称：上传的数据文件名称。
- 文件大小：上传的数据文件大小。
- 读取结果：数据文件上传结果，success为读取成功。
- 删除：在页面中删除，不会删除本地文件。
- 数据文件映射：每个已上传的数据文件都需要配置映射关系。
- 标签：选择该文件对应的点或边类型，只能选择一类点或一类边。
- 从第N行，开始：从第N行开始读取数据，系统默认从第0行开始读取数据，如需跳过表头可输入1。
- 属性映射：下拉选择数据列对应的属性字段。
- 数据预览：系统会预读数据文件的前5行。  
![数据导入-数据映射](../../../images/browser/graphbuild-import-datamapping.png)  
文件上传成功后，可以点击`继续导入`按钮继续导入其他数据，或者点击`前往图查询`按钮在`图查询`页面查询已导入的数据。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='Java客户端

2.使用示例

2.12.从字节流中导入点边数据

@param continueOnError: whether to continue when importing data fails
@param threadNums: maximum number of threads
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@return: the result of import data
public boolean importDataFromContent(String desc, String data, String delimiter, boolean continueOnError,
int threadNums, String graph, double timeout) throws UnsupportedEncodingException
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.12.从字节流中导入点边数据'}",空,空,空,空,空
在使用空的Result()初始化TuGraph中的表时，接下来应该使用什么方法为该表设置表头？,"page_content='src/lgraph_api/lgraph_result.cpp/ Result::Result(const std::initializer_list<std::pair<std::string, LGraphType>> &args) {
    for (auto h : args) header.push_back(h);
    row_count_ = -1;
}

Record *Result::MutableRecord() {
    result.emplace_back(Record(header));
    row_count_++;
    return &result[row_count_];
}

void Result::Reserve(size_t n) {
    result.reserve(n);
}

void Result::Resize(size_t n) {
    result.resize(n, Record(header));
    row_count_ = (int64_t)(n - 1);
}

Record* Result::At(size_t n) {
    return &result.at(n);
}

void Result::ResetHeader(const std::vector<std::pair<std::string, LGraphType>> &new_header) {
    result.clear();
    header = new_header;
    row_count_ = -1;
}

void Result::ResetHeader(
    const std::initializer_list<std::pair<std::string, LGraphType>> &new_header) {
    result.clear();
    header.clear();
    row_count_ = -1;
    for (auto h : new_header) header.push_back(h);
}

const std::vector<std::pair<std::string, LGraphType>> &Result::Header() { return header; }

Result::Result(const std::vector<std::pair<std::string, LGraphType>> &args) {
    header = args;
    row_count_ = -1;
}

int64_t Result::Size() const { return row_count_ + 1; }

const std::unordered_map<std::string, std::shared_ptr<ResultElement>> &Result::RecordView(
    int64_t row_num) {
    if (row_num > row_count_) {
        throw std::runtime_error(
            FMA_FMT(""[RecordView ERROR] table size is {}, but row_num is {}"", row_count_, row_num));
    }
    return result[row_num].record;
}' metadata={'file_name': 'lgraph_result.cpp', 'file_path': 'src/lgraph_api/lgraph_result.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_result.cpp'}","page_content='src/cypher/execution_plan/scheduler.cpp/ ctx->result_info_ = std::make_unique<ResultInfo>();
            ctx->result_ = std::make_unique<lgraph::Result>();
            std::string header, data;
            if (plan->CommandType() == parser::CmdType::EXPLAIN) {
                header = ""@plan"";
                data = plan->DumpPlan(0, false);
            } else {
                header = ""@profile"";
                data = plan->DumpGraph();
            }
            ctx->result_->ResetHeader({{header, lgraph_api::LGraphType::STRING}});
            auto r = ctx->result_->MutableRecord();
            r->Insert(header, lgraph::FieldData(data));' metadata={'file_name': 'scheduler.cpp', 'file_path': 'src/cypher/execution_plan/scheduler.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/execution_plan/scheduler.cpp'}",空,空,空,空,空,空,空,空
蚂蚁集团的个人贡献者许可协议主要目的是什么？,空,空,空,空,空,空,空,空,空,空
TuGraph Mini Runtime Image不包含哪些功能？,"page_content='Docker部署

1.简介

- TuGraph Compile Image：提供编译环境，可以用于TuGraph的编译，测试；
- TuGraph Runtime Image：提供二进制可运行环境，附带TuGraph库和可执行文件；
- TuGraph Mini Runtime Image: 提供二进制可运行环境，不包含TuGraph中Java、Python相关的功能，无C++ plugin编译运行，仅so上传。' metadata={'Header 1': 'Docker部署', 'Header 2': '1.简介'}","page_content='Docker部署

2.现有Docker Image

2.2.命名规范

`tugraph/tugraph-runtime-[os name & version]:[tugraph-runtime version]`  
例如：`tugraph/tugraph-runtime-centos7:3.4.0`  
#### 2.2.3.TuGraph Mini Runtime Image  
提供二进制可运行环境，不包含TuGraph种Java、Python相关的功能，无C++ plugin编译运行，仅so上传。  
`tugraph/tugraph-mini-runtime-[os name & version]:[tugraph-runtime version]`  
例如： `tugraph/tugraph-mini-runtime-centos7:3.4.0`' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.2.命名规范'}","page_content='Docker部署

2.现有Docker Image

2.2.命名规范

#### 2.2.1.TuGraph Compile Image  
提供编译环境，可以用于TuGraph的编译。  
`tugraph/tugraph-compile-[os name & version]:[tugraph compile version]`  
例如： `tugraph/tugraph-compile-centos7:1.2.0`  
#### 2.2.2.TuGraph Runtime Image  
提供二进制可运行环境，附带TuGraph库和可执行文件。  
`tugraph/tugraph-runtime-[os name & version]:[tugraph-runtime version]`  
例如：`tugraph/tugraph-runtime-centos7:3.4.0`  
#### 2.2.3.TuGraph Mini Runtime Image  
提供二进制可运行环境，不包含TuGraph种Java、Python相关的功能，无C++ plugin编译运行，仅so上传。' metadata={'Header 1': 'Docker部署', 'Header 2': '2.现有Docker Image', 'Header 3': '2.2.命名规范'}","page_content='环境分类

1.分类

根据环境所承载功能的不同，区分为编译环境，运行环境，以及精简运行环境。
* 编译环境，具备TuGraph编译的所有依赖库，包含运行环境的所有依赖，并且能够编译TuGraph源码，但不包含预编译好的TuGraph可执行文件和库文件，供开发者编译源码使用。
* 运行环境，具备GCC/Java/Python环境，能够运行TuGraph的所有功能，并且能承载全文索引，java client，c++源码上传为plugin，以及python plugin的完整功能，内置TuGraph预编译好的可执行文件和库文件，供客户直接安装使用，无需编译源码。
* 精简运行环境，约等于裸系统加预编译TuGraph，仅能运行TuGraph的基本功能，无C++ plugin编译运行，仅so上传，无全文索引，无python plugin，供快速搭建试用。  
TuGraph编译后，会把所有的依赖库以.a的形式打包在一起，因此原则上运行不需要的其他的依赖库。但TuGraph支持存储过程，即在服务端编译C++代码，因此在环境中依然需要涉及的编译器。' metadata={'Header 1': '环境分类', 'Header 2': '1.分类'}","page_content='环境分类

2.依赖系统库

针对三种环境，除去TuGraph的运行包，所需要的系统库如下：
* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。
* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。
* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}",空,空,空,空,空
OlapOnDB API文档中介绍的Procedure及Embed主要使用了哪些辅助函数？,"page_content='OlapOnDB API

2. 模型

Procedure及Embed使用到的辅助函数主要包含在OlapOnDB类，还有一些使用频率较高的函数都会逐一介绍  
在TuGraph中OLAP相关的有以下常用的数据结构：  
1. DB图分析类 `OlapOnDB<EdgeData>`
2. 点数组`ParallelVector<VertexData>`
3. 点集合`ParallelBitset`
4. 边数据结构`AdjUnit/AdjUnit<Empty>`
5. 边集合数据结构`AdjList<EdgeData>`' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '2. 模型'}","page_content='OlapOnDB API

1. 简介

一般用户需要自己实现的只是将需要分析的子图抽取出来的过程。用户也可以通过使用TuGraph中丰富的辅助接口实现自己的图分析算法。  
该文档主要介绍Procedure及Embed的接口设计，并介绍部分常用接口，具体的接口信息参见include/lgraph/olap_on_db.h文件。' metadata={'Header 1': 'OlapOnDB API', 'Header 2': '1. 简介'}","page_content='OlapOnDisk API

1. 简介

TuGraph的Standalone模式可用于加载图数据文件，其中图数据文件来源可包含text文本文件、BINARY_FILE二进制文件和ODPS源。在该模式下，TuGraph可实现多数据来源快速加载成图，然后在该图上运行如BFS、WCC、SSSP等迭代式算法，并输出最终结果至终端。  
在TuGraph中，导出和计算过程均可以通过在内存中并行处理的方式进行加速，从而达到近乎实时的处理分析，和传统方法相比，即避免了数据导出落盘的开销，又能使用紧凑的图数据结构获得计算的理想性能。  
TuGraph内置了大量的常见图分析算法和丰富的辅助接口，因此用户几乎不需要自己实现具体的图计算过程，只需要在实现自己的存储过程的时候将相应算法库的头文件(.h)包含到自己的程序中，并在编译阶段链接自己的动态库文件即可。  
该文档主要介绍了Standalone的常用接口，使用到的辅助函数主要包含在OlapOnDB类。同时为帮助用户理解方便，对BFS算法进行举例说明。' metadata={'Header 1': 'OlapOnDisk API', 'Header 2': '1. 简介'}","page_content='图分析引擎技术解析

2 功能介绍

2.2 点边筛选器

点边筛选器作用于图分析引擎中的 Procedure 和 Embed 模式。对于图存储数据源可根据用户需要和实际业务场景对图数据进行筛查，选择有效的点边进行图结构的构建。 2.3 一致性快照 TuGraph 中的 Procedure 和 Embed 模式能够提供数据“快照”，即建立一个对指定数据集的完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的镜像。由于 OLAP 的操作仅涉及读操作而不涉及写操作，OlapOnDB 会以一种更紧凑的方式对数据进行排布，在节省空间的同时，提高数据访问的局部性。 2.4 块状读写模块 块状读写模块作用于图分析引擎中的 Standalone 模式，用于对不同外部数据源的数据进行高效读入，同时也包含对内部算法处理后的图数据结果写回。 2.5 参数模块 参数模块作用于分析引擎中的 Standalone 模式，用于对图的一般信息（如数据来源，算法名称，数据输入、输出路径，顶点个数等）以及根据不同数据来源、不同算法所配置的不同信息参数进行接受和整理，传输给图算法及各个模块，同时将最终结果模块化展示。' metadata={'Header 1': '图分析引擎技术解析', 'Header 2': '2 功能介绍', 'Header 3': '2.2 点边筛选器'}","page_content='procedures/algo_cython/bfs_procedure.py/ # 通过 GetVertexIndexIterator 根据root节点label名和filed名与filed值（root_id）
    # 获取root节点的迭代器，通过迭代器获取vid，在无ID_MAPPING时，该vid与OlapOnDB中的id相同
    cost = time.time() - cost
    printf(""prepare_cost = %lf s\n"", cython.cast(cython.double, cost))
    a = BFSCore()
    cost = time.time()
    count = a.run(cython.address(olapondb), root_vid)
    cost = time.time() - cost
    printf(""core_cost = %lf s\n"", cython.cast(cython.double, cost))
    response[""found_vertices""] = count
    response[""num_vertices""] = olapondb.NumVertices()
    response[""num_edges""] = olapondb.NumEdges()
    return True


@cython.ccall
def Process(db: lgraph_db_python.PyGraphDB, inp: bytes):
    # Process为embed模式和procedure模式下插件入口，用cython.ccall修饰
    # Process函数必须名为Process，参数为lgraph_db_python.PyGraphDB与bytes
    # 返回值必须为(bool, str)
    _inp = inp.decode(""utf-8"")
    request = json.loads(_inp)
    response = {}
    addr = cython.declare(cython.Py_ssize_t, db.get_pointer())
    # 获取PyGraphDB中GraphDB对象的地址，转换为指针后传递
    procedure_process(cython.cast(cython.pointer(GraphDB), addr),
                      request, response)
    return (True, json.dumps(response))' metadata={'file_name': 'bfs_procedure.py', 'file_path': 'procedures/algo_cython/bfs_procedure.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/procedures/algo_cython/bfs_procedure.py'}",空,空,空,空,空
在尝试为用户设置新密码时，可能会抛出哪些异常？,空,空,空,空,空,空,空,空,空,空
如何使用 liblgraph_python_api.Galaxy 类来创建一个新的用户账户？,"page_content='src/python/python_api.cpp/ CreateUser"", &Galaxy::CreateUser,
             ""Creates a new user account.\n""
             ""name: name of the user\n""
             ""password: password for the user\n""
             ""desc: description of this user"",
             pybind11::arg(""name""), pybind11::arg(""password""), pybind11::arg(""desc""),
             pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/lgraph_api/c.cpp/ lgraph_api_galaxy_t* lgraph_api_galaxy_create_with_user(const char* dir, const char* user,
                                                        const char* password, bool durable,
                                                        bool create_if_not_exist, char** errptr) {
    try {
        return new lgraph_api_galaxy_t{Galaxy(dir, user, password, durable, create_if_not_exist)};
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return nullptr;
    }
}

void lgraph_api_galaxy_destroy(lgraph_api_galaxy_t* galaxy) { delete galaxy; }

void lgraph_api_galaxy_set_current_user(lgraph_api_galaxy_t* galaxy, const char* user,
                                        const char* password, char** errptr) {
    try {
        galaxy->repr.SetCurrentUser(user, password);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
}

void lgraph_api_galaxy_set_user(lgraph_api_galaxy_t* galaxy, const char* user, char** errptr) {
    try {
        galaxy->repr.SetUser(user);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
}

bool lgraph_api_galaxy_create_graph(lgraph_api_galaxy_t* galaxy, const char* graph_name,
                                    const char* description, size_t max_size, char** errptr) {
    try {
        return galaxy->repr.CreateGraph(graph_name, description, max_size);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ size_t lgraph_api_galaxy_list_graphs(lgraph_api_galaxy_t* galaxy, char*** graph_names,
                                     char*** graph_descs, size_t** graph_sizes, char** errptr) {
    size_t n = 0;
    try {
        auto graphs = galaxy->repr.ListGraphs();
        n = graphs.size();
        *graph_names = (char**)malloc(sizeof(char*) * n);
        *graph_descs = (char**)malloc(sizeof(char*) * n);
        *graph_sizes = (size_t*)malloc(sizeof(size_t) * n);
        size_t i = 0;
        for (const auto& [name, desc_size] : graphs) {
            (*graph_names)[i] = strdup(name.c_str());
            (*graph_descs)[i] = strdup(desc_size.first.c_str());
            (*graph_sizes)[i] = desc_size.second;
            ++i;
        }
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
    return n;
}

bool lgraph_api_galaxy_create_user(lgraph_api_galaxy_t* galaxy, const char* user,
                                   const char* password, const char* desc, char** errptr) {
    try {
        return galaxy->repr.CreateUser(user, password, desc);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_galaxy_delete_user(lgraph_api_galaxy_t* galaxy, const char* user, char** errptr) {
    try {
        return galaxy->repr.DeleteUser(user);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/lgraph_api/c.cpp/ bool lgraph_api_galaxy_set_user_graph_access(lgraph_api_galaxy_t* galaxy, const char* user,
                                             const char* graph, int access, char** errptr) {
    try {
        return galaxy->repr.SetUserGraphAccess(user, graph, static_cast<AccessLevel>(access));
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_galaxy_disable_user(lgraph_api_galaxy_t* galaxy, const char* user, char** errptr) {
    try {
        return galaxy->repr.DisableUser(user);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}

bool lgraph_api_galaxy_enable_user(lgraph_api_galaxy_t* galaxy, const char* user, char** errptr) {
    try {
        return galaxy->repr.EnableUser(user);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return false;
    }
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='Python Olap API

5. lgraph_db API

PyGalaxy:

- `PyGalaxy(self, dir_path: str)`: 构造函数，dir_path为db路径
- `SetCurrentUser(self, user: str password: str)-> void`: 设置用户
- `SetUser(self, user: std::string)-> void`: 设置用户
- `OpenGraph(self, graph: str, read_only: bool)-> PyGraphDB`: 创建PyGraphDB' metadata={'Header 1': 'Python Olap API', 'Header 2': '5. lgraph_db API', 'Header 3': 'PyGalaxy:'}",空,空,空,空,空
如何调用liblgraph_python_api.GraphDB中的哪个方法来删除一个顶点标签？,"page_content='src/python/python_api.cpp/ ""DeleteEdgeLabel"",
            [](GraphDB& db, const std::string& label) {
                size_t n;
                if (db.DeleteEdgeLabel(label, &n)) return n;
                THROW_CODE(InputError, ""No such label."");
            },
            ""Deletes an edge label"", pybind11::arg(""label_name""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""DeleteVertexLabel"",
            [](GraphDB& db, const std::string& label) {
                size_t n;
                if (db.DeleteVertexLabel(label, &n)) return n;
                THROW_CODE(InputError, ""No such label."");
            },
            ""Deletes a vertex label"", pybind11::arg(""label_name""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ DeleteVertexIndex"", &GraphDB::DeleteVertexIndex, ""Deletes the specified index."",
             pybind11::arg(""label_name""), pybind11::arg(""field_name""),
             pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""AlterEdgeLabelDelFields"",
            [](GraphDB& db, const std::string& label, const std::vector<std::string>& del_fields) {
                size_t n;
                if (db.AlterEdgeLabelDelFields(label, del_fields, &n)) return n;
                THROW_CODE(InputError, ""No such label."");
            },
            ""Delete fields from an edge label\n""
            ""label: name of the label\n""
            ""del_fields: list of field names"",
            pybind11::arg(""label""), pybind11::arg(""del_fields""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""AlterVertexLabelDelFields"",
            [](GraphDB& db, const std::string& label, const std::vector<std::string>& del_fields) {
                size_t n;
                if (db.AlterVertexLabelDelFields(label, del_fields, &n)) return n;
                THROW_CODE(InputError, ""No such label."");
            },
            ""Delete fields from a vertex label\n""
            ""label: name of the label\n""
            ""del_fields: list of field names"",
            pybind11::arg(""label""), pybind11::arg(""del_fields""),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}",空,空,空,空,空
当角色被禁用后，用户将失去该角色所赋予的所有权限，这些权限将不再可用。请问具体在什么样的场景下讨论角色禁用的问题，或者您想了解哪种权限管理的机制？,"page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

```  
#### 6.2.6.禁用角色  
角色可以被禁用。角色被禁用后，具有该角色的用户将不再从该角色中获得任何权限。只有管理员可以执行此操作。  
- **URI**: `/role/{role_name}/disable`
- **METHOD**: POST
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/disable
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
```  
**Example response.**  
```
• 200: OK
```  
#### 6.2.6.禁用角色  
角色可以被禁用。角色被禁用后，具有该角色的用户将不再从该角色中获得任何权限。只有管理员可以执行此操作。  
- **URI**: `/role/{role_name}/disable`
- **METHOD**: POST
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/disable' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

- 禁用角色：禁用之后，对应角色图访问权限失效。
- 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。  
![角色管理-禁用](../../../images/browser/role-disable.png)
![角色管理-启用](../../../images/browser/role-enable.png)  
###### d.删除角色  
在`角色管理`界面点击`删除`按钮删除对应的角色。  
![角色管理-删除](../../../images/browser/role-delete.png)  
#### 2.5.2.数据库信息  
##### 2.5.2.1.基础信息  
`基础信息`获取当前系统运行的状态，并展示关键信息。  
![数据库信息-基础信息](../../../images/browser/db_basic.png)  
|参数    |含义    |
|-------|--------|
|TuGraph版本号|当前TuGraph的版本号，x.x.x|' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

![角色管理-添加角色](../../../images/browser/role-add.png)  
###### b.编辑角色  
在`角色管理`界面点击`编辑`按钮编辑已有角色，用户可以编辑角色描述以及图权限。  
![角色管理-编辑角色](../../../images/browser/role-edit.png)  
###### c.禁用角色  
在`角色管理`界面点击`禁用`按钮禁止对应的角色，点击`启用`按钮开启对应的角色。禁用角色后，对应角色图访问权限失效。  
- 禁用角色：禁用之后，对应角色图访问权限失效。
- 当一个用户拥有两个角色对同一个图有操作权限时，当禁用其中一个角色时，另一个角色权限同样有效。  
![角色管理-禁用](../../../images/browser/role-disable.png)
![角色管理-启用](../../../images/browser/role-enable.png)  
###### d.删除角色  
在`角色管理`界面点击`删除`按钮删除对应的角色。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}",空,空,空,空,空,空
TuGraph的可视化监控主要使用了哪些软件？,"page_content='运维监控

1.设计思路

可视化监控并不是TuGraph自身不可或缺的一部分，因此在设计时将可视化监控作为TuGraph周边生态中的一个应用，来减少和TuGraph数据库的耦合度，以及对于TuGraph自身的影响。TuGraph可视化监控采用目前最火热的开源解决方案，TuGraph Monitor + Prometheus + Grafana来实现。其中TuGraph Monitor作为TuGraph服务的客户端，通过TCP链接向TuGraph服务发起Procedure请求，TuGraph服务在接收到请求后收集自身所在机器的cpu，memory，disk，io，以及请求数量等指标的统计结果进行响应。TuGraph Monitor在接收到TuGraph响应的指标数据后，将数据包装成prometheus需要的格式，保存在内存中，等待Prometheus服务通过http请求获取。Prometheus服务会定期通过http请求从TuGraph' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路'}","page_content='功能概览

6.生态工具

6.3.运维监控

TuGraph 使用 Prometheus 加 Grafana 的监控框架，采用松耦合的方式。Prometheus 从 TuGraph 的监控接口获取监控信息，存储在本地时序数据库中，然后通过 Grafana 在网页端交互展示。  
TuGraph 提供的监控的状态包括图数据库的状态和服务器的状态，前者包括读写负载、点边数量等数据库端的状态，后者包括内存、CPU、硬盘等服务器的实时状态。如果某些监控状态超过了预期的阈值，就需要主动告警，通常需要对接其他运维管控系统，比如群消息、邮件告警等。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.3.运维监控'}","page_content='功能概览

6.生态工具

6.2.可视化交互

TuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.2.可视化交互'}","page_content='功能概览

5.客户端工具

客户端主要分为各种编程语言的SDK，OGM以及命令行工具。  
客户端 SDK 主要用于二次开发，可以通过 RPC 或 REST 协议链接服务端。RPC 基于长链接有较好的性能，数据需要通过 protobuf 统一序列化。TuGraph 使用brpc，支持 Java、Python、C++ 的 rpc 客户端。REST 的协议比较宽泛，能够简单适配更加多样的环境，不同的编程语言能够简单对接。TuGraph 给出了 Python 的REST 客户端实例，命令行的交互也是用 REST 实现。  
OGM(Object Graph Mapping)为面向 TuGraph 的图对象映射工具，支持将 JAVA 对象（POJO）映射到 TuGraph 中，JAVA 中的类映射为图中的节点、类中的集合映射为边、类的属性映射为图对象的属性，并提供了对应的函数操作图数据库，因此 JAVA 开发人员可以在熟悉的生态中轻松地使用 TuGraph 数据库。' metadata={'Header 1': '功能概览', 'Header 2': '5.客户端工具'}","page_content='运维监控

1.设计思路

1.3.Prometheus

Prometheus是一个开源的监控平台，并配备有专属的时序数据库，它会定期通过http请求从TuGraph Monitor服务获取统计指标，并保存在自己的时序数据库中。详细信息请参考官网: [https://prometheus.io/docs/introduction/first_steps](https://prometheus.io/docs/introduction/first_steps)' metadata={'Header 1': '运维监控', 'Header 2': '1.设计思路', 'Header 3': '1.3.Prometheus'}",空,空,空,空,空
TuGraph 服务的配置文件在哪里可以找到？,"page_content='数据库运行

4.服务配置

4.2.服务器配置文件

TuGraph 的配置文件以 JSON 格式存储。建议将大多数配置存储在配置文件中，并且仅在需要时使用命令行选项临时修改某些配置参数。
一个典型的配置文件如下：  
```json
{
""directory"" : ""/var/lib/lgraph/data"",
""host"" : ""0.0.0.0"",
""port"" : 7070,
""rpc_port"" : 9090,
""enable_rpc"" : true,
""bolt_port"": 7687,
""enable_ha"" : false,
""verbose"" : 1,
""log_dir"" : ""/var/log/lgraph_log"",
""disable_auth"" : false,
""ssl_auth"" : false,
""server_key"" : ""/usr/local/etc/lgraph/server-key.pem"",
""server_cert"" : ""/usr/local/etc/lgraph/server-cert.pem"",' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.2.服务器配置文件'}","page_content='src/client/python/TuGraphClient/setup.py/ from setuptools import setup

setup(
    name='TuGraphClient',
    version='2.0',
    description='rest client for TuGraph',
    install_requires=[
        'httpx',
    ],
    packages=[''],
    entry_points={}
)' metadata={'file_name': 'setup.py', 'file_path': 'src/client/python/TuGraphClient/setup.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/TuGraphClient/setup.py'}","page_content='QA汇总

TuGraph Browser QA

如何更新

Q: 可视化文件 build 后如何更新到 tugraph 服务？
A: 可视化文件打包后，需要进行以下操作进行替换。  
- 登录 tugraph 服务所在的服务或 docker 容器内。
- 通过 lgraph_server --help 查看服务启动的配置文件所在目录。通常情况：`/usr/local/etc/lgraph.json`
- 查看 `/usr/local/etc/lgraph.json`文件中 web 的配置目录。通常情况：`/usr/local/share/lgraph/resource`
- 将可视化打包后生成的文件夹中的内容全部替换到配置目录下 `/usr/local/share/lgraph/resource`
- 重新启动 tugraph 服务' metadata={'Header 1': 'QA汇总', 'Header 2': 'TuGraph Browser QA', 'Header 3': '如何更新'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

|运行时间|TuGraph服务启动到现在的时间|
|服务器代码版本|tugraph-db仓库的当前commit|
|前端代码版本|tugraph-web仓库的当前commit|
|CPP编译器版本号|编译TuGraph时的CPP版本号|
|Python版本号|编译TuGraph时的Python版本号|
|CPP编译器ID|编译TuGraph时的CPP类型|  
也可以通过命令获取当前系统运行状态。  
```
CALL dbms.system.info()
```  
##### 2.5.2.2.数据库配置信息  
`数据库配置信息`获取当前系统运行的配置参数，并展示关键信息。调整配置参数或了解详细配置参数请参考[数据库运行-服务配置](../5.installation&running/7.tugraph-running.md)。  
![数据库信息-数据库配置信息](../../../images/browser/db_configuration.png)' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='TuGraph-db

2. 快速上手

一个简单的方法是使用docker进行设置，可以在DockerHub)中找到, 名称为`tugraph/tugraph-runtime-[os]:[tugraph version]`,
例如， `tugraph/tugraph-runtime-centos7:3.3.0`。  
更多详情请参考 [快速上手文档](和 [业务开发指南]' metadata={'Header 1': 'TuGraph-db', 'Header 2': '2. 快速上手'}",空,空,空,空,空
`StudentMapper`接口中的`selectVertex`方法的超时设置是多少毫秒？,空,空,空,空,空,空,空,空,空,空
在 PathTraversal 类中，展开当前前沿的操作可以使用哪些类型的过滤函数？,"page_content='Traversal API

2. 接口说明

2.2. Traversal

std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
```  
上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。  
```c
ParallelVector<size_t> & GetFrontier();
```  
当前点集合的扩展结束后，新的点集合可以通过上述方法取得。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &, Path &, IteratorHelper &)> out_edge_filter = nullptr,' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

);
void ExpandEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,
std::function<bool(InEdgeIterator &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
```  
上述为 FrontierTraversal 的三种遍历方式，即从当前的点集合出发，对集合中的每个点，依次访问每条出边/入边/出边和入边，若满足用户自定义的过滤条件（其中，edge_filter 为面向边的过滤函数，neighbour_filter 则为面向邻居点的过滤函数），则将邻居点加入新的点集合。  
```c' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> out_neighbour_filter = nullptr,
std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter = nullptr
);
```  
PathTraversal 的三种遍历方式与 FrontierTraversal 类似，只是用户自定义的过滤函数中增加了两个参数，其中：Path 包含了到新扩展的这条边之前的路径，IteratorHelper 可用于将路径中的点/边转为数据库中对应的迭代器，相关文档可参考对应的 C++ API 文档。' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='Traversal API

2. 接口说明

2.2. Traversal

两类 Traversal 的遍历都是从当前层的点集合出发，根据使用的扩展函数访问每条出边/入边/出边和入边，通过用户自定义的过滤函数决定扩展是否成功，若成功则将邻居点/追加了该条边的路径加入下一层的点/路径集合。  
```c
void ExpandOutEdges(
std::function<bool(OutEdgeIterator &)> out_edge_filter = nullptr,
std::function<bool(VertexIterator &)> out_neighbour_filter = nullptr
);
void ExpandInEdges(
std::function<bool(InEdgeIterator &)> in_edge_filter = nullptr,
std::function<bool(VertexIterator &)> in_neighbour_filter = nullptr
);
void ExpandEdges(' metadata={'Header 1': 'Traversal API', 'Header 2': '2. 接口说明', 'Header 3': '2.2. Traversal'}","page_content='src/lgraph_api/lgraph_traversal.cpp/ void PathTraversal::ExpandEdges(
    std::function<bool(OutEdgeIterator &, Path &, IteratorHelper &)> out_edge_filter,
    std::function<bool(InEdgeIterator &, Path &, IteratorHelper &)> in_edge_filter,
    std::function<bool(VertexIterator &, Path &, IteratorHelper &)> out_neighbour_filter,
    std::function<bool(VertexIterator &, Path &, IteratorHelper &)> in_neighbour_filter) {' metadata={'file_name': 'lgraph_traversal.cpp', 'file_path': 'src/lgraph_api/lgraph_traversal.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_traversal.cpp'}",空,空,空,空,空
在TuGraph中，当在只读交易中调用函数时，会抛出哪种异常？,空,空,空,空,空,空,空,空,空,空
在TuGraph中，如果开发的UDF（用户定义函数）的语言是Python，那么模块通常放在什么位置？,"page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}","page_content='使用 TuGraph 图学习模块进行点分类

5. 编译采样算子

采样算子用于从数据库中获取图数据并转换成所需数据结构，具体执行过程如下(如果TuGraph已编译，可跳过此步骤)：
在tugraph-db/build文件夹下执行
`make -j2`  
或在tugraph-db/learn/procedures文件夹下执行
`python3 setup.py build_ext -i`  
```python
from lgraph_db_python import *  # 导入tugraph-db的python接口模块
import importlib  # 导入importlib模块
getdb = importlib.import_module(""getdb"")  #获取getdb算子
getdb.Process(db, olapondb, feature_len, NodeInfo, EdgeInfo) #调用getdb算子
```  
如代码所示，得到算子so文件后，import 导入使用。' metadata={'Header 1': '使用 TuGraph 图学习模块进行点分类', 'Header 2': '5. 编译采样算子'}",空,空,空,空,空,空,空,空
在文本中，哪种资源名称的颜色设置为固定的“light-orange”？,空,空,空,空,空,空,空,空,空,空
如何删除已导入到TuGraph中的数据？,"page_content='TuGraph-OGM

3.使用 TuGraph-OGM

3.3.通过OGM进行增删改查

// 清空数据库
session.deleteAll(Movie.class);        // 删除所有Movie节点
session.purgeDatabase();               // 删除全部数据
```' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '3.使用 TuGraph-OGM', 'Header 3': '3.3.通过OGM进行增删改查'}","page_content='TuGraph-OGM

使用TuGraph-OGM

通过OGM进行增删改查

// 清空数据库
session.deleteAll(Movie.class);        // 删除所有Movie节点
session.purgeDatabase();               // 删除全部数据
```' metadata={'Header 1': 'TuGraph-OGM', 'Header 2': '使用TuGraph-OGM', 'Header 3': '通过OGM进行增删改查'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.4 通过OGM进行删操作**

**DELETE**  
使用session.delete方法删除节点，同时会删除与节点相关联的所有边。  
```java
session.delete(alice); // 删除alice节点以及相连的边

Movie m = session. load(Movie.class, jokes.getId); // EjokesTaMidsiXjokes# 点

session.delete(m);

// 清空数据库

session.deleteAll(Movie.class);

session.purgeDatabase ();

1/ 删除所有Movie节点

// 删除全部数据
```' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.4 通过OGM进行删操作**'}","page_content='src/client/python/TuGraphClient/TuGraphRestClient.py/ def delete_specified_user_files(self, user_name):
        data = {""userName"" : user_name, ""flag"" : '1'}
        r = self._sync(partial(self.__post__, 'clear_cache', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""result""]

    def delete_all_user_files(self):
        data = {""flag"" : '2'}
        r = self._sync(partial(self.__post__, 'clear_cache', data))
        if isinstance(r['data'], str):
            return None
        else:
            return r[""data""][""result""]

    def upload_file(self, file_name):
        # fragment_size at most 1024 * 1024 bytes
        fragment_size = 1024*1024
        with open(file_name, ""rb"") as f:
            idx = 0;
            while (True):
                stream = f.read(fragment_size)
                if not stream:
                    break
                begin = fragment_size * idx
                end = len(stream)
                self.http_headers[""File-Name""] = """" + file_name
                self.http_headers[""Begin-Pos""] = """" + str(begin)
                self.http_headers[""Size""] = """" + str(end)
                r = self._sync(partial(self.__post_binary__, 'upload_files', data=stream))
                idx += 1' metadata={'file_name': 'TuGraphRestClient.py', 'file_path': 'src/client/python/TuGraphClient/TuGraphRestClient.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/python/TuGraphClient/TuGraphRestClient.py'}","page_content='TuGraph-Restful-Server

7.接口

7.8 数据导入请求

用户通过此类请求导入已经上传的数据文件。导入不论成功或失败，都将删除已上传文件。数据导入请求在server中实现为一个异步任务，响应返回并不意味着导入已完成，返回的是任务id，后续可以通过此任务id查询导入进度
#### 7.8.1 URL
http://${ip}:${rpc_port}/LGraphHttpService/Query/import_data
#### 7.8.2 REQUEST
|  body参数  |          参数说明           |  参数类型  | 是否必填 |
|:--------:|:-----------------------:|:------:|:----:|
| graph |         导入目标子图          |  字符串  |  是   |
| schema |       导入schema描述        | json字符串  |  是   |
| delimiter |           分隔符           |  字符串  |  是   |' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '7.接口', 'Header 3': '7.8 数据导入请求'}",空,空,空,空,空
当使用 TuGraph 批量创建边时，如果请求成功，响应中将返回什么内容？,"page_content='RESTful API Legacy

6.Deprecated

6.8.边操作

- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。  
**Example request.**  
```
• POST http://localhost:7070/db/{graph_name}/node/{src}/relationship
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""destination"" : 14,
""label"" : ""BORN_IN"",
""property"" : {}
}
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
""1_14_1_0""
}
```  
#### 6.8.2.批量创建边  
- **URI**: `/db/{graph_name}/relationship`' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.8.边操作'}","page_content='RESTful API Legacy

6.Deprecated

6.8.边操作

#### 6.8.1.创建一条边  
- **URI**: `/db/{graph_name}/node/{src}/relationship`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| label | 边 Label | 字符串 |
| destination | 目的点 ID | 整数值 |
| property | 边属性 | 字典 |  
- **RESPONSE**: 如果成功，返回代码 200，同时返回新建立的边的 euid（字符串）。  
**Example request.**  
```
• POST http://localhost:7070/db/{graph_name}/node/{src}/relationship
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.8.边操作'}","page_content='RESTful API

2.请求与响应格式

2.2请求类型

- **RESPONSE**:
如果成功，返回的响应信息中success为00，data中包含令牌  
| body参数  | 参数说明 | 参数类型  | 是否必填       |
| ------- |------|-------|------------|
| authorization   | 令牌  | 字符串类型   | 是          |  
#### 2.2.4. 调用cypher
用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起  
- **URI**:     /cypher
- **METHOD**:  POST
- **REQUEST**:  
| body参数  | 参数说明     | 参数类型  | 是否必填       |
| ------- |----------|-------|------------|
| graph   | 查询的子图名称  | 字符串类型   | 是          |' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式', 'Header 3': '2.2请求类型'}","page_content='TuGraph-Restful-Server

7.接口

7.7 批量创建schema请求

用户通过此类请求批量创建schema，请求报文在http body 中将创建schema的目标子图和schema信息发送给server，如果拿到返回errorCode为200的响应报文即为正常创建
#### 7.7.1 URL
http://${ip}:${rpc_port}/LGraphHttpService/Query/import_schema
#### 7.7.2 REQUEST
|  body参数  |    参数说明    |  参数类型  |  是否必填  |
|:--------:|:----------:|:------:| :-----: |
| graph |   创建目标子图   |  字符串  |  是  |
| schema | schema描述信息 |  字符串  |  是  |' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '7.接口', 'Header 3': '7.7 批量创建schema请求'}","page_content='RESTful API

2.请求与响应格式

2.2请求类型

用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起  
- **URI**:     /cypher
- **METHOD**:  POST
- **REQUEST**:  
| body参数  | 参数说明     | 参数类型  | 是否必填       |
| ------- |----------|-------|------------|
| graph   | 查询的子图名称  | 字符串类型   | 是          |
| script   | cypher语句 | 字符串类型 | 是          |  
- **RESPONSE**:
如果成功，返回的响应信息中success为00，data中包含查询结果  
| body参数  | 参数说明 | 参数类型    | 是否必填       |
| ------- |------|---------|------------|
| result   | 查询结果 | json字符串 | 是          |' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式', 'Header 3': '2.2请求类型'}",空,空,空,空,空
TuGraph为什么选择使用B+树作为其底层存储数据结构？,"page_content='性能优先

3.存储数据结构

TuGraph底层采用B+树来支持实时的增删查改事务。  
在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='性能优先

3.存储数据结构

总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='功能概览

2.存储层

在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。  
在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。  
存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。' metadata={'Header 1': '功能概览', 'Header 2': '2.存储层'}","page_content='TuGraph与ARM架构

内容：

**背景介绍：**

数据库作为底层系统软件，面对CPU的更新换代也迎来了更多的挑战和机遇。在ARM架构中，CPU通常拥有更多的核数、更低的能耗、更高的性价比。作为拥抱开源的图数据库产品，TuGraph不仅需要兼容新型硬件，更需要充分发挥出新硬件的功能和性能优势。适配和测试工作包括超多线程的支持、更加细致的负载均衡策略、并发读写性能优化等。  
**本次测试机构国际关联数据基准委员会LDBC是由高校、研究所、企业联合组成的非盈利组织，其中企业成员包括Intel、Oracle、Neo4j、蚂蚁集团等国内外知名图数据厂商，致力于推进图数据的规范标准化。**本次测试使用的图数据来自LDBC的社交网络运营场景SNB（Social Network Benchmark），LDBC SNB的图数据是一个包含14类顶点和20类边的属性图，用户可以指定scale factor生成不同规模的数据。LDBC SNB的交互式工作负载由14个复杂的只读查询、7个简单的只读查询和8个事务型更新查询组成。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**背景介绍：**'}","page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}",空,空,空,空,空
"接口 ""CallProcedureToLeader"" 支持哪些参数设置以改变其返回结果的格式？","page_content='Java客户端

2.使用示例

2.7.向leader调用存储过程

@param jsonFormat: (Optional) Return format of calling stored procedure
@return: the result of procedure execution
public String callProcedureToLeader(String procedureType, String procedureName, String param, double procedureTimeOut,
boolean inProcess, String graph)
```
本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.7.向leader调用存储过程'}","page_content='Python客户端

3.RPC Client

3.7.向leader调用存储过程

```python
ret, res = client.callProcedureToLeader(""CPP"", ""khop"", kHopParamGen(), 1000, false, ""default"")
```
```
callProcedureToLeader(self: liblgraph_client_python.client, procedure_type: str, procedure_name: str, param: str, procedure_time_out: float, in_process: bool, graph: str, json_format: bool) -> (bool, str)
```
本接口支持在HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。' metadata={'Header 1': 'Python客户端', 'Header 2': '3.RPC Client', 'Header 3': '3.7.向leader调用存储过程'}","page_content='Java客户端

2.使用示例

2.7.向leader调用存储过程

@param procedureName: procedure name
@param param: the execution parameters
@param procedureTimeOut: Maximum execution time, overruns will be interrupted
@param inProcess: Running query or not
@param graph: the graph to query
@param jsonFormat: (Optional) Return format of calling stored procedure
@return: the result of procedure execution
public String callProcedureToLeader(String procedureType, String procedureName, String param, double procedureTimeOut,' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.7.向leader调用存储过程'}","page_content='src/client/cpp/rpc/lgraph_rpc_client.cpp/ bool RpcClient::CallProcedureToLeader(std::string& result, const std::string& procedure_type,
                                      const std::string& procedure_name, const std::string& param,
                                      double procedure_time_out, bool in_process,
                                      const std::string& graph, bool json_format) {
    if (client_type == SINGLE_CONNECTION) {
        return base_client->CallProcedure(result, procedure_type, procedure_name, param,
                                          procedure_time_out, in_process, graph, json_format);
    } else {
        return DoubleCheckQuery([&] {
            return leader_client->CallProcedure(result, procedure_type, procedure_name, param,
                                                procedure_time_out, in_process, graph, json_format);
        });
    }
}' metadata={'file_name': 'lgraph_rpc_client.cpp', 'file_path': 'src/client/cpp/rpc/lgraph_rpc_client.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/client/cpp/rpc/lgraph_rpc_client.cpp'}","page_content='Java客户端

2.使用示例

2.6.调用存储过程

public String callProcedure(String procedureType, String procedureName, String param, double procedureTimeOut,
boolean inProcess, String graph, String url)
```
本接口支持在单机模式和HA模式下使用，默认以字符串格式直接返回存储过程的执行结果，指定jsonFormat为true可以返回json格式的执行结果。
其中，在HA模式下的client中，通过指定url参数可以定向向某个server发送读请求。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.6.调用存储过程'}",空,空,空,空,空
如何提高在TuGraph数据库中的查询效率？,"page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='功能概览

4.核心功能

4.3.数据导入导出

尽管TuGraph本身支持数据的插入，但批量导入能够大幅提升的效率。导入的功能可以分为空库导入（离线导入）和增量导入，前者指子图是空的时候进行导入，额外的假设能够大幅提升导入的性能，在 TuGraph 中，空库导入和增量导入的吞吐率差了10 倍。在数据导出中，需要考虑导出数据的一致性，即是基于一个快照数据导出的。  
TuGraph 可以通过 命令行工具`lgraph_export` 来对已经存放在TuGraph的图数据进行数据导出，导出格式支持CSV和JSON。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.3.数据导入导出'}","page_content='性能优先

3.存储数据结构

TuGraph底层采用B+树来支持实时的增删查改事务。  
在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

和点类似，边的non_unique索引指的是非全局唯一的索引，即若一个属性设置了non_unique索引，
在同一个图中，相同label的边的该属性可以存在相同的值。
由于non_unique索引一个key可能映射到多个值，为了加速查找和写入，
在用户指定的key后面加上了索引key相同的一组eid的最大值。
每个eid是24bytes长度，因此non_unique索引key最大长度是456bytes。
但是，不同于unique索引，超过456bytes也可以建立non_unique索引。
只不过在对这样的属性建立索引时会只截取**前456bytes**作为索引key（属性本身存储的值不受影响）。
并且，在通过迭代器遍历时，也是先自动截取查询值的前456bytes再进行遍历，
所以结果可能和预期不一致，需要用户再过滤。  
#### 1.3.2 组合索引  
目前只支持对点的多个属性建立组合索引，不支持对边的属性建立组合索引。组合索引支持唯一索引和非唯一索引两种类型，建立索引的要求如下：
1. 建立组合索引的属性个数在2到16个之间（含）' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}","page_content='功能概览

4.核心功能

4.5 数据预热

TuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.5 数据预热'}",空,空,空,空,空
在什么情况下 FieldData 类中的 integer() 方法会抛出 std::bad_cast 异常？,"page_content='src/cypher/arithmetic/arithmetic_expression.cpp/ cypher::FieldData BuiltinFunction::ToInteger(RTContext *ctx, const Record &record,
                                             const std::vector<cypher::ArithExprNode> &args) {
    if (args.size() != 2) CYPHER_ARGUMENT_ERROR();
    auto operand = args[1];
    auto r = operand.Evaluate(ctx, record);
    switch (r.type) {
    case Entry::CONSTANT:
        if (r.constant.IsInteger()) {
            return r.constant;
        }
        if (r.constant.IsReal()) {
            return cypher::FieldData(
                lgraph::FieldData(static_cast<int64_t>(r.constant.scalar.real())));
        }
        if (r.constant.IsString()) {
            try {
                return cypher::FieldData(lgraph::FieldData(
                    static_cast<int64_t>(std::stoll(r.constant.scalar.string()))));
            } catch (std::exception &e) {
                LOG_WARN() << e.what();
                break;
            }
        }
    default:
        break;
    }
    CYPHER_ARGUMENT_ERROR();
}' metadata={'file_name': 'arithmetic_expression.cpp', 'file_path': 'src/cypher/arithmetic/arithmetic_expression.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/arithmetic_expression.cpp'}","page_content='src/cypher/arithmetic/arithmetic_expression.cpp/ cypher::FieldData BuiltinFunction::ToFloat(RTContext *ctx, const Record &record,
                                           const std::vector<cypher::ArithExprNode> &args) {
    if (args.size() != 2) CYPHER_ARGUMENT_ERROR();
    auto operand = args[1];
    auto r = operand.Evaluate(ctx, record);
    switch (r.type) {
    case Entry::CONSTANT:
        if (r.constant.IsInteger()) {
            return cypher::FieldData(
                lgraph::FieldData(static_cast<double>(r.constant.scalar.integer())));
        }
        if (r.constant.IsReal()) {
            return r.constant;
        }
        if (r.constant.IsString()) {
            try {
                return cypher::FieldData(lgraph::FieldData(std::stod(r.constant.scalar.string())));
            } catch (std::exception &e) {
                LOG_WARN() << e.what();
                break;
            }
        }
    default:
        break;
    }
    CYPHER_ARGUMENT_ERROR();
}' metadata={'file_name': 'arithmetic_expression.cpp', 'file_path': 'src/cypher/arithmetic/arithmetic_expression.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/arithmetic_expression.cpp'}","page_content='src/cypher/arithmetic/arithmetic_expression.cpp/ cypher::FieldData BuiltinFunction::ToString(RTContext *ctx, const Record &record,
                                            const std::vector<ArithExprNode> &args) {
    if (args.size() != 2) CYPHER_ARGUMENT_ERROR();
    auto operand = args[1];
    auto r = operand.Evaluate(ctx, record);
    switch (r.type) {
    case Entry::CONSTANT:
        if (r.constant.IsString()) {
            return r.constant;
        }
        if (r.constant.IsInteger()) {
            try {
                return cypher::FieldData(
                    lgraph::FieldData(std::to_string(r.constant.scalar.integer())));
            } catch (std::exception &e) {
                LOG_WARN() << e.what();
                break;
            }
        }
        if (r.constant.IsReal()) {
            try {
                return cypher::FieldData(
                    lgraph::FieldData(std::to_string(r.constant.scalar.real())));
            } catch (std::exception &e) {
                LOG_WARN() << e.what();
                break;
            }
        }
        if (r.constant.IsBool()) {
            bool d = r.constant.scalar.AsBool();
            if (d)
                return cypher::FieldData(lgraph::FieldData(""true""));
            else
                return cypher::FieldData(lgraph::FieldData(""false""));
        }
    default:
        break;
    }
    CYPHER_ARGUMENT_ERROR();
}' metadata={'file_name': 'arithmetic_expression.cpp', 'file_path': 'src/cypher/arithmetic/arithmetic_expression.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/arithmetic_expression.cpp'}","page_content='src/cypher/arithmetic/ast_expr_evaluator.cpp/ static cypher::FieldData Neg(const cypher::FieldData& x) {
    if (!((IsNumeric(x) || x.IsNull()))) {
        throw lgraph::CypherException(""Type mismatch: expect Integer or Float in sub expr"");
    }
    cypher::FieldData ret;
    if (x.IsNull()) return ret;
    if (x.IsInteger()) {
        ret.scalar = ::lgraph::FieldData(-x.scalar.integer());
        return ret;
    } else {
        ret.scalar = ::lgraph::FieldData(-x.scalar.real());
        return ret;
    }
    NOT_SUPPORT_AND_THROW();
}

std::any cypher::AstExprEvaluator::visit(geax::frontend::GetField* node) {
    auto expr = std::any_cast<Entry>(node->expr()->accept(*this));
    return Entry(cypher::FieldData(expr.GetEntityField(ctx_, node->fieldName())));
}

std::any cypher::AstExprEvaluator::visit(geax::frontend::TupleGet* node) {
    NOT_SUPPORT_AND_THROW();
}

std::any cypher::AstExprEvaluator::visit(geax::frontend::Not* node) { DO_UNARY_EXPR(Not); }

std::any cypher::AstExprEvaluator::visit(geax::frontend::Neg* node) { DO_UNARY_EXPR(Neg); }

std::any cypher::AstExprEvaluator::visit(geax::frontend::Tilde* node) { NOT_SUPPORT_AND_THROW(); }

std::any cypher::AstExprEvaluator::visit(geax::frontend::VSome* node) { NOT_SUPPORT_AND_THROW(); }' metadata={'file_name': 'ast_expr_evaluator.cpp', 'file_path': 'src/cypher/arithmetic/ast_expr_evaluator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/cypher/arithmetic/ast_expr_evaluator.cpp'}",空,空,空,空,空,空
TuGraph-DB的存储引擎是否使用了KV数据库？如果是的话，它是基于哪个KV数据库构建的？,"page_content='TuGraph产品架构

1.简介

![产品架构](../../../images/architecture.png)  
上图从功能模块的角度，以 TuGraph 为例，给出了企业级图数据库的整体架构，自下而上包括：  
- 软硬件环境。涉及图数据库的开发和使用环境。TuGraph 主要基于底层的 C++语言开发，能够兼容市面上大部分操作系统和 CPU。
- 存储层，包括 KV 存储层和图存储层。存储层需要支持计算层所需的各个功能。
- 计算层。计算层应包括图事务引擎、图分析引擎和图神经网络引擎，也包含了服务端提供的多种编程接口，包括描述式查询语言 Cypher，存储过程等。
- 客户端。客户端 SDK 应支持 Java、Python、C++ 等多种语言，也支持命令行的交互方式。Browser 和 Explorer 通过网页端交互的方式，降低了图数据库的使用门槛。
- 在生态工具方面，覆盖了企业级图数据库的开发、运维、管理等链路，提升可用性。' metadata={'Header 1': 'TuGraph产品架构', 'Header 2': '1.简介'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='功能概览

2.存储层

在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。  
在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。  
存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。' metadata={'Header 1': '功能概览', 'Header 2': '2.存储层'}","page_content='TuGraph在图计算系统建设中的作用

TuGraph 技术优势

TuGraph 的整个图存储是建立在完美哈希的基础上的，这是我们与其他图系统的一个重要区别。目前，大多数图系统使用的是基于数的存储，但数的问题在于永远存在一个 LogN 的查找操作。然而，在图中可以看到，不同的顶点之间实际上是无序的，不需要有顺序，所以顶点这个级别实际上是基于哈希的，理论上，顶点的读取是最优的。  
此外，TuGraph 还参与了许多标准的定制，整个系统在尽量往标准化的方向去做。  
除了为内部提供服务，我们还向外提供服务，主要是因为，作为一个系统，如果只为有限的客户提供服务，就很容易构建成一个专有系统。我们希望这是一个标准化、开放的系统，所以我们也在对外提供图计算系统的产品和服务。目前，我们也有很多外部客户，包括金融、工业、互联网以及政企领域。  
开源开放，共建发展  
整个图计算系统目前仍处于较早期的阶段，我们认为还有很多工作要做，包括提升应用性、性能和降低成本。所有的系统都会有这些问题。但是，如果希望普及，我们认为最重要的是有健康的生态，来推动图计算系统的发展，需要有更多的用户和更多的场景使用这个系统。' metadata={'Header 1': 'TuGraph在图计算系统建设中的作用', 'Header 2': 'TuGraph 技术优势'}",空,空,空,空,空
请问如何在TuGraph中进行新旧版本的web切换，以及我在哪里可以找到新版的browser-resource？,"page_content='数据库运行

3.服务操作

3.4.新旧前端切换

进入容器，可以通过修改配置文件""/usr/local/etc/lgraph.json""中的""web""参数来选择使用老版本或新版本的前端。对于老版本，可以将""web""的值设为""/usr/local/share/lgraph/resource""；对于新版本，可以将""web""的值设为""/usr/local/share/lgraph/browser-resource""。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.4.新旧前端切换'}","page_content='快速上手

2.安装

2.2.新旧前端说明

进入容器，可以通过修改配置文件""/usr/local/etc/lgraph.json""中的""web""参数来选择使用老版本或新版本的前端。对于老版本，可以将""web""的值设为""/usr/local/share/lgraph/resource""；对于新版本，可以将""web""的值设为""/usr/local/share/lgraph/browser-resource""。完成配置文件的修改后，请执行命令 `docker restart tugraph` 以使更改生效。需要注意的是，新版本是默认选项。' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.2.新旧前端说明'}","page_content='QA汇总

TuGraph Browser QA

如何更新

Q: 可视化文件 build 后如何更新到 tugraph 服务？
A: 可视化文件打包后，需要进行以下操作进行替换。  
- 登录 tugraph 服务所在的服务或 docker 容器内。
- 通过 lgraph_server --help 查看服务启动的配置文件所在目录。通常情况：`/usr/local/etc/lgraph.json`
- 查看 `/usr/local/etc/lgraph.json`文件中 web 的配置目录。通常情况：`/usr/local/share/lgraph/resource`
- 将可视化打包后生成的文件夹中的内容全部替换到配置目录下 `/usr/local/share/lgraph/resource`
- 重新启动 tugraph 服务' metadata={'Header 1': 'QA汇总', 'Header 2': 'TuGraph Browser QA', 'Header 3': '如何更新'}","page_content='可视化操作手册

2.操作指南

2.5.控制台

![角色管理-删除](../../../images/browser/role-delete.png)  
#### 2.5.2.数据库信息  
##### 2.5.2.1.基础信息  
`基础信息`获取当前系统运行的状态，并展示关键信息。  
![数据库信息-基础信息](../../../images/browser/db_basic.png)  
|参数    |含义    |
|-------|--------|
|TuGraph版本号|当前TuGraph的版本号，x.x.x|
|运行时间|TuGraph服务启动到现在的时间|
|服务器代码版本|tugraph-db仓库的当前commit|
|前端代码版本|tugraph-web仓库的当前commit|
|CPP编译器版本号|编译TuGraph时的CPP版本号|
|Python版本号|编译TuGraph时的Python版本号|
|CPP编译器ID|编译TuGraph时的CPP类型|  
也可以通过命令获取当前系统运行状态。  
```
CALL dbms.system.info()' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.5.控制台'}","page_content='快速上手

2.安装

2.1.通过docker快速体验

# ${REPOSITORY}是镜像地址，${VERSION}是版本号。
# 7070是默认的http端口，访问tugraph-db-browser使用。
# 7687是bolt端口，bolt client访问使用。
# 9090是默认的rpc端口，rpc client访问使用。
# /var/lib/lgraph/data是容器内的默认数据目录，/var/log/lgraph_log是容器内的默认日志目录
# 命令将数据目录和日志目录挂载到了宿主机的/root/tugraph/上进行持久化，您可以根据实际情况修改。
```  
5. 前端访问  
访问tugraph-db-browser: `http://x.x.x.x:7070`，数据库地址格式为 `bolt://ip:bolt_port`（老版本不用填），默认用户名为 `admin`，密码为 `73@TuGraph`。
首次登录会默认跳转修改密码页面，请尽快修改默认密码避免安全风险。' metadata={'Header 1': '快速上手', 'Header 2': '2.安装', 'Header 3': '2.1.通过docker快速体验'}",空,空,空,空,空
在使用TuGraph进行大规模数据查询时，是否会对图数据进行压缩？,"page_content='图数据库智能化建设与探索

**04\. 技术分享｜CStore Compaction模块的设计与优化**

“TuGraph Analytics本质上是一款图分析OLAP数据库。CStore作为一个单机版存储引擎，提供了坚实的存储基础。同时，RocksDB也可以作为TuGraph Analytics的存储基础。我们采用LDBC提供的通用社交网络图数据集进行了基准测试，测试涉及让TuGraph Analytics分别连结RocksDB以及我们自有版本的CStore进行分析。在同步与异步compaction（数据压缩整理）两种方式下进行了读写性能测试：同步方式意味着数据写入完成后进行compaction，完成之后再进行读性能测试；异步方式则是写入和compaction同时进行，写入完成后立即测试读性能。在这两种情境下，使用CStore的TuGraph Analytics的读性能超过了使用RocksDB的三倍以上。”' metadata={'Header 1': '图数据库智能化建设与探索', 'Header 2': '**04\\. 技术分享｜CStore Compaction模块的设计与优化**'}","page_content='TuGraph与ARM架构

内容：

**测试介绍：**

TuGraph在测试中使用Client/Server分离的模式，来模拟真实的用户使用场景。在结果中，TuGraph在不同规模的数据集下均表现优异，在大规模100GB的数据集（2.8亿个点，18亿条边）上，TuGraph的吞吐率较上一次官方纪录提升了31%。在300GB数据集上，TuGraph测试了超过内存容量的数据吞吐量，虽然较100GB的性能有所下降，但考虑内存和硬盘的读写性能鸿沟，该结果也在预期之内。**除了性能测试，TuGraph在****系统事务性、可恢复性、正确性、稳定性等方面均达到官方标准，体现了TuGraph高并发低延迟的强大性能优势。**  
在性能测试中，我们发现并解决了一些值得注意的问题。其一是有的系统页大小默认为64KB，这个对图系统随机数据读写并不友好，调整为X86更普遍的4KB有助于提升性能。其二是在云上使用云盘，会比本地硬盘的读写带宽和稳定性差很多，如果能够在测试前进行数据预热和及时的硬盘性能监控，更有助于获得理想的结果。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**测试介绍：**'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

0 映射原理

TuGraph-OGM 将 JAVA 对象映射为图的对象，类映射为点，类的属性映射为图中的属性，类中的方法映射为操作 TuGraph 的查询语句。  
以电影场景为例，对演员、电影、导演之间的关系进行数据化，就形成了非常典型的图数据。举一个简单的示例，演员Alice在1990年和2019年分别出演了两部电影《Jokes》和《Speed》，其中《Jokes》的导演是Frank Darabont。  
以图的思维来看，演员、导演、电影可以被映射为三种不同的节点，而出演、执导可以被映射为两种边，映射结果如上图所示，将数据存入图数据库后，相关的开发人员就可以使用各类图查询语言对数据进行查询。  
但对非图数据库相关的开发人员来说，这个例子中的演员、导演、电影作为实体，同样可以映射为类中的对象，而与实体相关联的对象可以通过集合存储，这是大多数开发人员熟悉的领域。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '0 映射原理'}","page_content='TuGraph由LDBC认定全球领先

基本介绍

TuGraph 由蚂蚁集团和清华大学共同研发，是图数据库权威测试世界纪录保持者，也是世界上有测试纪录的“最快”的图数据库。  
**随着 TuGraph 的开源，图数据领域将迎来一款性能卓越、功能丰富、生态完备的开源产品**。  
开发者可以聚焦应用层，轻松打造属于自己的图数据，从而提升行业整体技术应用水位。TuGraph 开源采用 Apache2.0 协议，在 Github 和 Gitee 上进行托管。  
图数据库区别于关系型数据库，基于图模型，使用点边来表示、存储、处理数据，拥有灵活的数据抽象模型，能够更好地表达出“关系”的概念。  
蚂蚁 TuGraph 是一套分布式图数据库系统，可以支持万亿级边上的实时查询。此次开源的 TuGraph 单机版，同样具备完备的图数据库基础功能和成熟的产品设计，可以轻松支持 TB 级别数据和百亿级别大图，足以满足大多数业务场景需求。相较于市场上常见的开源产品，TuGraph 单机版的性能高 10 倍以上。' metadata={'Header 1': 'TuGraph由LDBC认定全球领先', 'Header 2': '基本介绍'}","page_content='功能概览

2.存储层

在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。  
在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。  
存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。' metadata={'Header 1': '功能概览', 'Header 2': '2.存储层'}",空,空,空,空,空
TuGraph选择使用哪种树结构作为其存储数据结构？选择这种树结构的主要原因是什么？,"page_content='性能优先

3.存储数据结构

总结来说，B+ 树有较好的顺序读写性能，而 LSM 树在数据随机写方面占优。此外 LSM 树采用后台合并的方式，使得性能的波动难以预期，性能波动和上层存储和计算的关联性较弱，增加了整体设计的成本。综上考虑，TuGraph 选用 B+ 树作为读性能优先的实现。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='性能优先

3.存储数据结构

TuGraph底层采用B+树来支持实时的增删查改事务。  
在排序树的数据结构中，B+树和LSM树为主要代表。B+树在树节点中使用拆分和合并式来更新排序数据，而 LSM 树在日志中追加更新，以进行延迟数据合并。B+ 早期用在文件系统的实现中，通过将数据保存 在自适应长度的叶子节点中，解决硬盘顺序操作和随机操作性能存在数据量级差别的问题，有较均衡的读写性能。LSM 树的主要优势使用 WAL(Write Ahead Log) 进行更新，将更新操作变成顺序操作，在键值较小时性能优势尤为突出。WAL 意味着将数据的更新合并推迟，批量更新能提升综合效率，也使得系统的调度变得复杂。如果更新合并完成前，恰好对其中的数据继续读取，LSM 树就需要读取几个层级局部合并的日志，会导致读取放大和空间放大，从而影响读效率。' metadata={'Header 1': '性能优先', 'Header 2': '3.存储数据结构'}","page_content='功能概览

2.存储层

在图数据模型上，TuGraph支持属性图模型，按照层次可以分为子图、标签（包括点标签和边标签）、属性。从存储层看，TuGraph使用使用直观的多层的树状模型，没有跨子图的标签，也没有跨标签的属性，仅保留图模型的核心逻辑。  
在子图的存储上，TuGraph对多图做了数据的物理隔离，每个图对应一个LMDB的实例。多图的元数据描述信息，保存在meta的特殊的公共LMDB实例中。点边标签及其属性的存储，通过将图数据自适应地映射到KV键值对，最大程度发挥读性能。同时在KV层实现了多线程写，解决了LMDB写性能较低的劣势。主键索引和二级索引，对应LMDB中B+的表，支持基于比较的索引值增删查改。  
存储层还保留了一些其他非核心功能的数据，包括权限数据、预编译的插件数据、监控数据等。' metadata={'Header 1': '功能概览', 'Header 2': '2.存储层'}","page_content='TuGraph与ARM架构

内容：

**背景介绍：**

数据库作为底层系统软件，面对CPU的更新换代也迎来了更多的挑战和机遇。在ARM架构中，CPU通常拥有更多的核数、更低的能耗、更高的性价比。作为拥抱开源的图数据库产品，TuGraph不仅需要兼容新型硬件，更需要充分发挥出新硬件的功能和性能优势。适配和测试工作包括超多线程的支持、更加细致的负载均衡策略、并发读写性能优化等。  
**本次测试机构国际关联数据基准委员会LDBC是由高校、研究所、企业联合组成的非盈利组织，其中企业成员包括Intel、Oracle、Neo4j、蚂蚁集团等国内外知名图数据厂商，致力于推进图数据的规范标准化。**本次测试使用的图数据来自LDBC的社交网络运营场景SNB（Social Network Benchmark），LDBC SNB的图数据是一个包含14类顶点和20类边的属性图，用户可以指定scale factor生成不同规模的数据。LDBC SNB的交互式工作负载由14个复杂的只读查询、7个简单的只读查询和8个事务型更新查询组成。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**背景介绍：**'}","page_content='TuGraph图模型说明

1. 数据模型

1.1. 图模型

TuGraph是一个具备多图能力的强类型、有向属性图数据库。  
- 图项目：每个数据库服务可以承载多个图项目（多图），每个图项目可以有自己的访问控制配置，数据库管理员可以创建或删除指定图项目。
- 点：指实体，一般用于表达现实中的实体对象，如一部电影、一个演员。
- 主键：用户自定义的点数据主键，默认唯一索引，在对应的点类型中唯一。
- VID：点在存储层自动分配图项目中的唯一ID，用户不可修改。
- 上限：每个图项目存储最多2^(40)个点数据。
- 边：用于表达点与点之间的关系，如演员出演电影。
- 有向边：边为有向边。若要模拟无向边，用户可以创建两个方向相反的边。
- 多条边：两个点数据之间可以有多条边数据。当前TuGraph支持重复边，如要确保边边唯一，需要通过业务策略实现。
- 上限：两个点数据之间存储最多2^(32)条边数据。
- 属性图：点和边可以具有与其关联的属性，每个属性可以有不同的类型。
- 强类型：每个点和边有且仅有一个标签，创建标签后，修改属性数量及类型有代价。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.1. 图模型'}",空,空,空,空,空
TuGraph-DB使用的是哪个版本的Boost库？,"page_content='TuGraph Java Client

版本选择

| Client Version | TuGraph Version |
|----------------|-----------------|
| 1.1.1          | 3.3.3           |
| 1.2.1, 1.2.2   | 3.4.x, 3.5.0    |
| 1.3.0          | 3.6.0           |
| 1.4.0, 1.4.1   | 4.0.0, 4.0.1    |  
**注意**:  
- 3.3.0~3.3.2 版本的 TuGraph Server 是在 java-client 重构前的遗留版本，本仓库不支持这些版本。
- 1.1.0 和 1.2.0 因 pom 文件中的 ${revision} 变量引入的无法使用的问题而不可用[1]。' metadata={'Header 1': 'TuGraph Java Client', 'Header 2': '版本选择'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

三、TuGraph-DB高可用集群部署与应用

1.TuGraph-DB高可用（V3.6）

关于 TuGraph-DB 高可用集群的部署方式和 client 应用，相关文档已经放到了 tugraph-db.readthedocs.io 网站上。  
现在支持 C++、Java 和 Python 多种版本的 client SDK。' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '三、TuGraph-DB高可用集群部署与应用', 'Header 3': '1.TuGraph-DB高可用（V3.6）'}","page_content='环境分类

2.依赖系统库

针对三种环境，除去TuGraph的运行包，所需要的系统库如下：
* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。
* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。
* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='技术规划

2. 已完成功能

TuGraph-DB于2022年9月1日开源，TuGraph-DB在社区的反馈声中，进行日常BUG修复，自身能力得到了完善。  
| 版本号   | 功能                               | 时间         |
|-------|----------------------------------|------------|
| 3.3.0 | 开源初版                             | 2022.9.1   |
| 3.3.1 | 图分析引擎重构，多模式支持                    | 2022.10.14 |
| 3.3.2 | OGM支持，UT覆盖率提升                    | 2022.11.21 |
| 3.3.3 | 链接认证机制迭代，加入英文文档                  | 2022.12.23 |
| 3.3.4 | 支持上云，梳理LDBC SNB Audit流程          | 2023.1.28  |' metadata={'Header 1': '技术规划', 'Header 2': '2. 已完成功能'}","page_content='蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍

二、TuGraph-DB高可用架构与规划

6.未来规划

第二个是按需快照。大家在使用图数据库的时候，数据量可能是非常庞大的。比如我们内部有一个 1.2T 的线上业务，当它去打 snapshot 的时候，时间非常长，大概要两个小时。虽然它并不阻塞读写请求，但对性能的影响还是非常严重的，并且会放大存储空间，原来数据是 1.2T，打完之后可能就变成 2.4T 了。所以我们希望改造 Raft 协议，去提供按需生成快照的功能，只有在 follower 加入节点的时候才进行快照，因为只有 follower 加入这个节点时需要快照来加速数据同步。  
第三个是高可用工具链。因为 TuGraph-DB 的高可用功能是 3.6 版本才开源，它提供的工具链现在还有一些待完善的地方，比如在线导入，只提供了单机的功能，我们希望可以提供一个集群在线导入，这样就不用去对多机执行在线导入的功能了。还有快照生成工具，client 的接口完善等等。' metadata={'Header 1': '蚂蚁关于 TuGraph-DB 图数据库高可用架构介绍', 'Header 2': '二、TuGraph-DB高可用架构与规划', 'Header 3': '6.未来规划'}",空,空,空,空,空
TuGraph适合哪些类型的用户？,"page_content='环境和版本选择

1. 简介

TuGraph为不同需求的用户提供了差异化的系统环境和部署方式，来满足新手、系统开发者、生产运维人员、研究人员等不同用户的需求。' metadata={'Header 1': '环境和版本选择', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

关于TuGraph

高性能图数据库 TuGraph（https://github.com/TuGraph-family/tugraph-db） 由蚂蚁集团和清华大学共同研发，经国际图数据库基准性能权威测试，是 LDBC-SNB 世界纪录保持者，在功能完整性、吞吐率、响应时间等技术指标均达到全球领先水平，为用户管理和分析复杂关联数据提供了高效易用可靠的平台。  
历经蚂蚁万亿级业务的实际场景锤炼，TuGraph 已应用于蚂蚁内部150多个场景，助力支付宝2021年资产损失率小于亿分之0.98。关联数据爆炸性增长对图计算高效处理提出迫切需求，TuGraph 已被成熟应用于金融风控、设备管理等内外部应用，适用于金融、工业、互联网、社交、电信、政务等领域的关系数据管理和分析挖掘。  
2022年9月，TuGraph 单机版开源，提供了完备的图数据库基础功能和成熟的产品设计，拥有完整的事务支持和丰富的系统特性，单机可部署，使用成本低，支持TB级别的数据规模。' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '关于TuGraph'}","page_content='TuGraph在图计算系统建设中的作用

TuGraph 技术优势

TuGraph 开源版特色

为什么要去开源单机版而不是分布式版本？主要是考虑到它的部署和使用成本比分布式版本要低得多，同时功能也很完整、独立。我们希望这样可以让许多刚开始使用图数据库或有使用图数据库解决问题的想法的人，可以先尝试用我们的单机版图数据库。因为它的部署非常简单，如果跑起来没有问题，那么再考虑是否需要分布式版本。如果确实需要，我们可以再跟进这个问题。  
我们的单机版图数据库已经能够支持 TB 级别的数据，我们内部也有很多情况使用单机版图数据库。在单台机器上，我们最大的数据量也达到了 2TB 多，在线上运行，能够处理百亿级别的点边。事实上，大多数用户使用单机版图数据库都是足够的。由于单机版的图数据库很容易优化，我们对它进行了极致的优化，因此单机版图数据库在性能上可以满足绝大多数场景的需求。此外，它的系统特性也很全面，包括高可用性、多图支持、权限管理、日志记录等，它可以被看作是一个成熟、易用的图数据库，类似于 MySQL。  
开源TuGraph特点包括:  
-   单机版图数据库能够处理数据量几个 TB 的数据，前提是磁盘足够大。' metadata={'Header 1': 'TuGraph在图计算系统建设中的作用', 'Header 2': 'TuGraph 技术优势', 'Header 3': 'TuGraph 开源版特色'}","page_content='环境准备

2.软件环境

2.1. 操作系统

TuGraph 能够兼容主流操作系统，包括Ubuntu、CentOS、SUSE、银河麒麟、 中标麒麟、UOS等，均通过测试认证。  
其中最稳定使用的系统版本是 Ubuntu 18.04、CentOS 7、CentOS 8。' metadata={'Header 1': '环境准备', 'Header 2': '2.软件环境', 'Header 3': '2.1. 操作系统'}","page_content='功能概览

6.生态工具

6.2.可视化交互

TuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.2.可视化交互'}",空,空,空,空,空
TuGraph的REST API中，POST请求主要用于什么目的？,"page_content='RESTful API Legacy

2.请求与数据格式

2.1请求

TuGraph 支持 HTTP GET/POST/PUT/DELETE 请求。其中：  
- GET 请求用于只读请求，如读取点属性，边属性等操作；
- POST 请求用于创建实体，提交 Cypher，以及加载和调用存储过程；
- PUT 请求用于修改已有实体，如修改点属性，边属性等；
- DELETE 请求用于删除已有实体，如删除点，边等。  
在高可用模式下，用户可以在请求的报头(request header)中设置 `server_version` 来保证请求的服务器有足够新的数据。
当前的 `server_version` 可以从服务器返回的报头中获取。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '2.请求与数据格式', 'Header 3': '2.1请求'}","page_content='RESTful API

2.请求与响应格式

2.2请求类型

接口用于将本地文件上传至TuGraph所在机器。可以上传文本文件，二进制文件，可以上传大文件，也可以上传小文件，对于大文件，客户端在上传时应该对文件做切分，每个文件分片不大于1MB，参数Begin-Pos和Size对应本次分片在完整文件中的偏移量与分片大小。参数需要放在http请求的报文头，请求内容对应文件分片内容。本接口请求头不止有token参数  
- **URI**:     /upload_file
- **METHOD**:  POST
- **REQUEST**:  
| header参数  | 参数说明        | 参数类型             | 是否必填       |
| ------- |-------------|------------------|------------|
| File-Name   | 文件名称        | 字符串类型            | 是          |' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式', 'Header 3': '2.2请求类型'}","page_content='RESTful API

2.请求与响应格式

2.2请求类型

| body参数  | 参数说明 | 参数类型    | 是否必填       |
| ------- |------|---------|------------|
| result   | 查询结果 | json字符串 | 是          |  
**Example request.**  
```
{""script"" : ""Match (n) return n"", ""graph"" : ""default""}
```  
#### 2.2.5. 上传文件
接口用于将本地文件上传至TuGraph所在机器。可以上传文本文件，二进制文件，可以上传大文件，也可以上传小文件，对于大文件，客户端在上传时应该对文件做切分，每个文件分片不大于1MB，参数Begin-Pos和Size对应本次分片在完整文件中的偏移量与分片大小。参数需要放在http请求的报文头，请求内容对应文件分片内容。本接口请求头不止有token参数  
- **URI**:     /upload_file
- **METHOD**:  POST
- **REQUEST**:' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式', 'Header 3': '2.2请求类型'}","page_content='RESTful API

1.简介

TuGraph 提供遵从 REST 规范的 HTTP API，以供开发者通过 HTTP 请求远程调用 TuGraph 提供的服务。  
本文档描述 TuGraph 的 HTTP API 使用方式。' metadata={'Header 1': 'RESTful API', 'Header 2': '1.简介'}","page_content='RESTful API

2.请求与响应格式

2.2请求类型

用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起  
- **URI**:     /cypher
- **METHOD**:  POST
- **REQUEST**:  
| body参数  | 参数说明     | 参数类型  | 是否必填       |
| ------- |----------|-------|------------|
| graph   | 查询的子图名称  | 字符串类型   | 是          |
| script   | cypher语句 | 字符串类型 | 是          |  
- **RESPONSE**:
如果成功，返回的响应信息中success为00，data中包含查询结果  
| body参数  | 参数说明 | 参数类型    | 是否必填       |
| ------- |------|---------|------------|
| result   | 查询结果 | json字符串 | 是          |' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式', 'Header 3': '2.2请求类型'}",空,空,空,空,空
安装部署TuGraph时，外存配置的最低和建议要求分别是多少？,"page_content='环境准备

1.硬件环境

1.3. 外存

我们强烈建议用户使用 NVMe SSD 作为外存，数据库有大量的写操作需要同步的外存，通常为随机写，外存的读写性能很容易成为整体数据库运行的性能瓶颈。因此，高IOPS、低延迟的 NVMe SSD 是最优的选择。  
如果现实条件只能使用 SATA接口的SSD，或者云上的网盘，性能虽然会受到影响，但 TuGraph 依然能正确的运行。  
外存大小建议为实际数据大小的4倍，比如数据为1TB，则准备4TB的硬盘会比较稳妥。' metadata={'Header 1': '环境准备', 'Header 2': '1.硬件环境', 'Header 3': '1.3. 外存'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='云部署

2.实例说明

TuGraph部署的为社区开源版本，源码参考Github Repo，目前可以选择的实例规格如下：  
| 规格族         | vCPU与内存                 | 系统盘              | 公网带宽      |
|----------------|-------------------------|-------------------|-----------|
| ecs.r7a.xlarge | AMD 内存型 r7a，4vCPU 32GiB | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |
| ecs.r6.xlarge  | 内存型r6，4vCPU 32GiB       | ESSD云盘 200GiB PL0 | 固定带宽1Mbps |  
预估费用在创建实例时可实时看到（目前为免费）。 如需更多规格、其他服务（如集群高可用性要求、企业级支持服务等），请联系我们 tugraph@service.alipay.com。' metadata={'Header 1': '云部署', 'Header 2': '2.实例说明'}","page_content='OlapBase API

2. 配置要求

如果要使用TuGraph图计算编写以及编译自己的应用程序，需要的配置要求为：  
- linux操作系统，目前在Ubuntu16.04, Ubuntu18.04, Ubuntu20.04和Centos7, Centos8系统上可成功运行。
- 支持C++17的编译器，要求GCC版本为8.4.0或更新的版本。' metadata={'Header 1': 'OlapBase API', 'Header 2': '2. 配置要求'}","page_content='从源码编译

1.前置条件

推荐在linux系统下搭建TuGraph。同时docker环境是个不错的选择,如果你想设置一个新的环境，请参考[Dockerfile](3.docker-deployment.md)。' metadata={'Header 1': '从源码编译', 'Header 2': '1.前置条件'}",空,空,空,空,空
在创建一个TuGraph数据库时，如果指定的目录不存在，构造函数会如何处理？,空,空,空,空,空,空,空,空,空,空
VertexIterator 的 GetNumOutEdges 方法默认的 n_limit 参数值是多少？,"page_content='src/core/graph.cpp/ LOG_DEBUG() << ""_ScanAndDelete(batch_size="" << batch_size << "")"";
    bool is_vertex = (should_delete_node != nullptr);
    size_t n_node = 0;
    size_t n_edge = 0;
    size_t n_last_commit = 0;
    std::unique_ptr<VertexIterator> vit(new VertexIterator(GetUnmanagedVertexIterator(&txn)));' metadata={'file_name': 'graph.cpp', 'file_path': 'src/core/graph.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/graph.cpp'}","page_content='src/lgraph_api/lgraph_vertex_iterator.cpp/ void VertexIterator::SetFields(const std::vector<std::string>& field_names,
                               const std::vector<FieldData>& field_values) {
    ThrowIfInvalid();
    txn_->SetVertexProperty(*it_, field_names, field_values);
    txn_->RefreshIterators();
}

void VertexIterator::SetFields(const std::vector<size_t>& field_ids,
                               const std::vector<FieldData>& field_values) {
    ThrowIfInvalid();
    txn_->SetVertexProperty(*it_, field_ids, field_values);
    txn_->RefreshIterators();
}

std::vector<int64_t> VertexIterator::ListSrcVids(size_t n_limit, bool* more_to_go) {
    ThrowIfInvalid();
    return it_->ListSrcVids(nullptr, nullptr, n_limit, more_to_go);
}

std::vector<int64_t> VertexIterator::ListDstVids(size_t n_limit, bool* more_to_go) {
    ThrowIfInvalid();
    return it_->ListDstVids(nullptr, nullptr, n_limit, more_to_go);
}

size_t VertexIterator::GetNumInEdges(size_t n_limit, bool* more_to_go) {
    ThrowIfInvalid();
    return it_->GetNumInEdges(n_limit, more_to_go);
}

size_t VertexIterator::GetNumOutEdges(size_t n_limit, bool* more_to_go) {
    ThrowIfInvalid();
    return it_->GetNumOutEdges(n_limit, more_to_go);
}

void VertexIterator::Delete(size_t* n_in, size_t* n_out) {
    ThrowIfInvalid();
    txn_->DeleteVertex(*it_, n_in, n_out);
    txn_->RefreshIterators();
}

std::string VertexIterator::ToString() const {
    ThrowIfInvalid();
    return txn_->VertexToString(*it_);
}
}' metadata={'file_name': 'lgraph_vertex_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_vertex_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_vertex_iterator.cpp'}","page_content='src/lgraph_api/c.cpp/ size_t lgraph_api_vertex_iterator_get_num_in_edges(lgraph_api_vertex_iterator_t* it, size_t n_limit,
                                                   bool* more_to_go, char** errptr) {
    try {
        return it->repr.GetNumInEdges(n_limit, more_to_go);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return -1;
    }
}

size_t lgraph_api_vertex_iterator_get_num_out_edges(lgraph_api_vertex_iterator_t* it,
                                                    size_t n_limit, bool* more_to_go,
                                                    char** errptr) {
    try {
        return it->repr.GetNumOutEdges(n_limit, more_to_go);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
        return -1;
    }
}

void lgraph_api_vertex_iterator_delete(lgraph_api_vertex_iterator_t* it, size_t* n_in_edges,
                                       size_t* n_out_edges, char** errptr) {
    try {
        it->repr.Delete(n_in_edges, n_out_edges);
    } catch (const std::exception& e) {
        *errptr = strdup(e.what());
    }
}

char* lgraph_api_vertex_iterator_to_string(lgraph_api_vertex_iterator_t* it, char** errptr) {
    return strdup(it->repr.ToString().c_str());
}

void lgraph_api_vertex_index_iterator_destroy(lgraph_api_vertex_index_iterator_t* it) { delete it; }

void lgraph_api_vertex_index_iterator_close(lgraph_api_vertex_index_iterator_t* it) {
    it->repr.Close();
}' metadata={'file_name': 'c.cpp', 'file_path': 'src/lgraph_api/c.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/c.cpp'}","page_content='src/python/python_api.cpp/ ""GetNumOutEdges"",
            [](VertexIterator& vit, size_t n_limit) {
                bool more_to_go = false;
                auto n = vit.GetNumOutEdges(n_limit, &more_to_go);
                return std::make_pair(n, more_to_go);
            },
            ""Gets the number of out edges of this vertex.\n""
            ""n_limit specifies the maximum number of vids to scan.""
            ""Returns a tuple containing the number of out-edges and a bool value ""
            ""indicating whether the limit is exceeded."",
            pybind11::arg(""n_limit"") = std::numeric_limits<size_t>::max(),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}","page_content='src/python/python_api.cpp/ ""GetNumInEdges"",
            [](VertexIterator& vit, size_t n_limit) {
                bool more_to_go = false;
                auto n = vit.GetNumInEdges(n_limit, &more_to_go);
                return std::make_pair(n, more_to_go);
            },
            ""Gets the number of in-coming edges of this vertex.\n""
            ""n_limit specifies the maximum number of edges to scan.\n""
            ""Returns a tuple containing the number of in-edges and a bool value ""
            ""indicating whether the limit is exceeded."",
            pybind11::arg(""n_limit"") = std::numeric_limits<size_t>::max(),
            pybind11::call_guard<SignalsGuard>())' metadata={'file_name': 'python_api.cpp', 'file_path': 'src/python/python_api.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/python/python_api.cpp'}",空,空,空,空,空
在尝试加入高可用集群时，节点的默认等待秒数是多少？,"page_content='数据库运行

4.服务配置

4.1.配置参数

| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |
| ha_bootstrap_role            | 整形                    | 是否使用bootstrap方式启动，以及使用该方式启动的服务器角色，0代表不使用bootstrap方式启动，1代表使用bootstrap方式启动且本节点为leader，2代表使用bootstrap方式启动且本节点为follower，只有这3种选项。 默认值为 0。                                              |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| ha_conf                      | 字符串                   | 根据 host1:port1,host2:port2,host3:port3 初始化HA集群，默认值为空。                                                                                                                             |
| ha_node_join_group_s         | 整形                    | 节点尝试加入高可用集群的等待时长，单位秒，默认是 10。                                                                                                                                                      |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}",空,空,空,空,空,空,空,空
在生成Mapper接口的时候，XMLMAPPER类型是如何实现接口方法的？,空,空,空,空,空,空,空,空,空,空
GCN模型的主要组成部分是什么？,空,空,空,空,空,空,空,空,空,空
TuGraph-DB的单元测试使用的是什么测试框架？,"page_content='单元测试

1.简介

TuGraph单元测试采用gtest框架，可以选择一次跑全部test或者制定某些test。' metadata={'Header 1': '单元测试', 'Header 2': '1.简介'}","page_content='集成测试

2.TuGraph集成测试框架

TuGraph采用pytest框架作为自己的集成测试框架，pytest框架作为目前使用最广泛的cs端集成测试框架，以其灵活简单，容易上手，并且支持参数化的使用方式而著称，TuGraph基于pytest提供的功能，抽象出了不同的工具，通过参数来控制各个工具的处理逻辑，以方便大家进行高效的测试代码开发。  
更多pytest信息请参考官网: [https://docs.pytest.org/en/7.2.x/getting-started.html](https://docs.pytest.org/en/7.2.x/getting-started.html)' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架'}","page_content='集成测试

1.TuGraph集成测试的意义

在单元测试与功能测试中，有部分用例直接开启galaxy或statemachine来进行测试，这并不是一个完整的流程。在完整的cs架构中，用户请求是通过客户端发往服务端，网络通信是必不可少的，为了避免单元测试不完整带来的bug，针对这种情况，使用集成测试框架进行全链路的完整测试。' metadata={'Header 1': '集成测试', 'Header 2': '1.TuGraph集成测试的意义'}","page_content='集成测试

2.TuGraph集成测试框架

2.3.测试样例

ret = client.callCypher(""MATCH (n) RETURN n LIMIT 100"", ""default"")
assert ret[0]
res = json.loads(ret[1])
log.info(""res : %s"", res)
assert len(res) == 21
```  
#### 2.3.4.其他测试
更多用例请参考集成测试代码 [https://github.com/TuGraph-family/tugraph-db/tree/master/test/integration](https://github.com/TuGraph-family/tugraph-db/tree/master/test/integration)' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.3.测试样例'}","page_content='集成测试

2.TuGraph集成测试框架

2.2.组件用法

采用python字典传入
+ cmd是启动命令
+ cleanup_dir是执行完成后需要清理的目录，可以是多个，通过python列表传入  
```python
EXPORT_DEF_OPT = {""cmd"":""./lgraph_export -d ./testdb -e ./export/default -g default -u admin -p 73@TuGraph"",
""cleanup_dir"":[""./export""]}
```  
##### 2.2.4.2.启动命令  
通过fixtures组件引入工具，并通过启动参数来控制导出不同的数据，函数开始执行前会导出数据到指定的目录，函数执行完成后会清理cleanup_dir指定的目录  
```python
@pytest.mark.parametrize(""exportor"", [EXPORT_DEF_OPT], indirect=True)
def test_exportor(self, exportor):
pass
```' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.2.组件用法'}",空,空,空,空,空
可以使用TuGraph-DB中的Cypher查询来找到一个子图，然后在该子图上执行图分析算法，例如PageRank和K-Core等。请问具体的操作步骤或示例代码可以提供吗？,"page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

2、左边栏：查询、筛选、外观功能操作区域；
3、画布区域：展示图数据的区域，展示点和边数据，支持点扩展查询、收起节点、固定节点、删除节点、画布图数据统计、缩放、居中等功能；
4、右边栏：选中一个点数据或边数据后，会展示对应的属性信息；
5、布局切换：标签布局和卡片布局的切换。  
![图分析-操作区域](../../../images/browser/graphanalysis-operation-area.png)  
##### 2.4.4.1.语句查询  
在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。
- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='TuGraph DB BROWSER

启动TuGraph DB Browser

TuGraph DB BROWSER 是 TuGraph 图数据库的可视化平台。可以完成图谱、模型、数据等的创建和导入。同时可用使用 TuGraph Cypher 进行数据的操作。  
0. 环境准备  
- node.js >= 16  
1. 安装项目依赖  
```bash
npm install --force
```  
2. 本地研发  
```bash
npm run dev
```  
浏览器访问 http://localhost:8000  
3. 编译构建  
```bash
npm run build
```' metadata={'Header 1': 'TuGraph DB BROWSER', 'Header 2': '启动TuGraph DB Browser'}","page_content='Traversal API

1. 简介

TuGraph 强大的在线分析处理（OLAP）能力是其区别于其它图数据库的一个重要特性。
借助 C++ OLAP API（olap_on_db.h），用户可以快速地导出一个需要进行复杂分析的子图，然后在其上运行诸如 PageRank、连通分量、社区发现等迭代式图计算过程，最后根据结果做出相应决策。
导出和计算的过程都可以通过并行处理的方式进行加速，从而实现几乎实时的分析处理，避免了传统解决方案需要将数据导出、转换、再导入（ETL）到专门的分析系统进行离线处理的冗长步骤。  
TuGraph 内置了大量常用的图分析算法和丰富的辅助接口，因此用户几乎不需要自己来实现具体的图计算过程，只需在实现自己的存储过程时将相应算法库的头文件（.h 文件）包含到自己程序中，并在编译时链接相应的动态库文件（.so）即可。
一般情况下，用户需要自己实现的只有将需要分析的子图抽取出来的过程。  
目前 Traversal API 仅支持 C++。' metadata={'Header 1': 'Traversal API', 'Header 2': '1. 简介'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.6 通过OGM进行查操作**

**QUERY WITH CYPHER**  
OGM支持通过queryForObject、query方法向TuGraph发送Cypher查询，由于Cypher查询的灵活性，需要用户自行指定返回结果格式。  
session.queryForObject方法：需要在方法第一个参数处指定返回类型，可设定为某一实体类或数字类型。  
session.query方法：Cypher查询的返回结果被存储为Result类型，其内部数据需要用户自行解析，以下方代码为例，传入数据库的Cypher为CREATE查询，返回结果createResult可被解析为QueryStatistics，可获取到此次查询被创建的节点与边的数目。  
![](https://mdn.alipayobjects.com/huamei_qcdryc/afts/img/A*lkxXS660eEgAAAAAAAAAAAAADgOBAQ/original)' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.6 通过OGM进行查操作**'}",空,空,空,空,空
"HA集群的快照（snapshot）一般在以下情况下会被删除：  
1. 当系统管理员手动删除快照时。  
2. 在系统存储空间不足时，可能会自动删除较旧的快照以释放空间。  
3. 在执行备份或恢复操作后，有时会按照预定策略自动删除不再需要的快照。  
请根据具体的HA集群配置和策略来确定快照删除的具体时间和条件。","page_content='数据库运行

4.服务配置

4.1.配置参数

| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |
| ha_heartbeat_interval_ms     | 整型                    | 心跳间隔（以毫秒为单位）。 默认值为 1000。                                                                                                                                                          |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| disable_auth                 | 布尔值                   | 关闭 REST 验证。默认为 false。                                                                                                                                                             |
| ha_snapshot_interval_s       | 整型                    | 快照间隔（以秒为单位），默认值为 604800。-1表示不自动生成快照。                                                                                                                                              |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| ha_node_remove_ms            | 整型                    | 节点被视为完全死亡并从列表中删除的间隔（以毫秒为单位）。默认值为 120000。                                                                                                                                          |
| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为""HH:MM:SS""，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为""""，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| backup_log_dir               | 字符串                   | 存储备份文件的目录。 默认值为空。                                                                                                                                                                 |
| snapshot_dir                 | 字符串                   | 存储快照文件的目录。 默认值为空。                                                                                                                                                                 |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}","page_content='数据库运行

4.服务配置

4.1.配置参数

| ha_first_snapshot_start_time | 字符串                   | 第一次打快照的时间，格式为""HH:MM:SS""，表示为在下一个HH:MM:SS时间点第一次打snapshot，以后每ha_snapshot_interval_s秒打一次。默认值为""""，表示在0-ha_snapshot_interval_s内的任一时刻随机打第一次snapshot，以后每ha_snapshot_interval_s秒打一次snapshot |
| enable_ip_check              | 布尔值                   | 允许 IP 白名单，默认值为 false。                                                                                                                                                             |' metadata={'Header 1': '数据库运行', 'Header 2': '4.服务配置', 'Header 3': '4.1.配置参数'}",空,空,空,空,空
TuGraph-DB目前支持哪种查询语言？未来计划支持哪种查询语言？,"page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='TuGraph-db

1. 简介

TuGraph 是支持大数据容量、低延迟查找和快速图分析功能的高效图数据库。
TuGraph的支持邮箱：tugraph@service.alipay.com  
主要功能：  
- 标签属性图模型
- 完善的 ACID 事务处理
- 内置 34 图分析算法
- 支持全文/主键/二级索引
- OpenCypher 图查询语言
- 基于 C++/Python 的存储过程  
性能和可扩展性：  
- LDBC SNB世界记录保持者 (2022/9/1)
- 支持存储多达数十TB的数据
- 每秒访问数百万个顶点
- 快速批量导入' metadata={'Header 1': 'TuGraph-db', 'Header 2': '1. 简介'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持RESTful API

除了支持Cypher查询语言，TuGraph还提供了RESTful API接口。这使得我可以通过编程方式与图数据库进行交互，更好地将TuGraph集成到我的应用程序中。API设计合理，易于使用，为我提供了灵活性和自由度。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持RESTful API'}","page_content='ISO GQL

1.GQL简介

Graph Query Language(GQL, 图查询语言)是一种国际标准语言，用于属性图查询，该语言建立在SQL的基础上，并整合了现有的[openCypher、PGQL、GSQL和G-CORE](https://gql.today/comparing-cypher-pgql-and-g-core/)语言的成熟思想。目前该标准仍然处于草稿阶段。  
TuGraph基于[ISO GQL (ISO/IEC 39075) Antlr4 语法文件](https://github.com/TuGraph-family/gql-grammar)实现了GQL，并做了一些扩展与改造。目前并未完全支持所有的GQL语法，我们会在未来逐步完善。' metadata={'Header 1': 'ISO GQL', 'Header 2': '1.GQL简介'}","page_content='RPC API

5.存储过程

为满足用户较为复杂的查询/更新逻辑，TuGraph支持 C 语言和 Python 语言编写的存储过程。
用户可以使用RPC请求对存储过程进行增删改查操作。' metadata={'Header 1': 'RPC API', 'Header 2': '5.存储过程'}",空,空,空,空,空
在TuGraph中，有哪些关键字用于开启和结束事务？,"page_content='TuGraph图模型说明

2. 图项目、点、边、属性命名规则和建议

2.2 使用限制

|**描述**|**最大个数**|
|-------- |--------- |
|用户数、角色数|65536|
|图项目的个数|4096|
|每个图项目的点和边类型数量之和|4096|
|每个点或边类型的属性数量|1024|  
注：
1、特殊字符和关键字说明：使用特殊字符或非保留关键字时，需要使用反单引号/backquote（``）进行引用；  
示例： ```match (`match`:match) return `match`.id limit 1```  
2、大小写敏感性：TuGraph大小写敏感；  
3、图项目、点/边、属性名称之间可以重复使用，同一点或边下的属性名称不可以重复；  
4、属性名字保留关键字：SRC_ID / DST_ID / SKIP' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '2. 图项目、点、边、属性命名规则和建议', 'Header 3': '2.2 使用限制'}","page_content='数据库运行

2.运行模式

2.1.运行普通进程

[20240730 15:34:27.869970 0x00006e7d435ff700 INFO  src/server/bolt_server.cpp:36] bolt server run
[20240730 15:34:27.870040 0x00007f81bb3889c0 INFO  src/server/lgraph_server.cpp:302] Server started.
```  
普通进程模式下，用户可以通过按 `CTRL+C` 来提前终止 TuGraph 进程。' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.1.运行普通进程'}","page_content='数据库运行

2.运行模式

2.1.运行普通进程

`lgraph_server -d run`命令可以将 TuGraph 作为普通进程运行。普通进程依赖命令行终端，因此终端结束时，TuGraph 进程也会自动终止。普通进程模式配合`--log_dir """"`可以将进程日志直接输出到终端，因此更方便调试。注：当不使用`-d run`命令时，将默认运行普通进程。  
lgraph_server的默认路径为：/usr/local/bin/lgraph_server 。  
lgraph.json的默认路径为：/usr/local/etc/lgraph.json 。  
启动命令：  
```shell
$ ./lgraph_server -d run -c lgraph.json --log_dir """"
```
或者：
```shell
$ ./lgraph_server -c lgraph.json --log_dir """"
```  
普通模式的运行输出示例：  
```shell' metadata={'Header 1': '数据库运行', 'Header 2': '2.运行模式', 'Header 3': '2.1.运行普通进程'}","page_content='数据库运行

3.服务操作

3.1.启动服务

TuGraph 需要通过 `lgraph_server -d start` 命令行启动，启动命令示例如下：  
```bash
$ ./lgraph_server -d start -c lgraph.json
Starting lgraph...
The service process is started at pid 12109.
```  
此命令启动的 TuGraph 服务器进程为守护进程，它将从文件`lgraph.json`加载相关配置。服务器启动后，它将开始在日志文件中打印日志，之后可用该日志文件确定服务器的状态。' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.1.启动服务'}","page_content='数据库运行

3.服务操作

3.2.停止服务

用户可以使用`kill`命令以及`lgraph_server -d stop`命令停止 TuGraph 守护进程。由于可能在同一台计算机上运行多个 TuGraph 服务器进程，因此我们使用`.pid`文件区分不同的服务器进程，该文件写入启动该进程的工作目录。因此，需要在相同工作目录中运行`lgraph_server-d stop`命令，以停止正确的服务器进程。  
```shell
user@host:~/tugraph$ ./lgraph_server -d start -c lgraph.json
20200508122306.378: Starting lgraph...
20200508122306.379: The service process is started at pid 93.

user@host:~/tugraph$ cat ./lgraph.pid
93' metadata={'Header 1': '数据库运行', 'Header 2': '3.服务操作', 'Header 3': '3.2.停止服务'}",空,空,空,空,空
如何使用命令创建一个新的角色，并为该角色提供描述信息？,空,空,空,空,空,空,空,空,空,空
TuGraph的查询语句是否支持任意长度路径？,"page_content='TuGraph-Restful-Server

7.接口

7.6 文件认证请求

用户通过此类请求验证发送到server端的文件是否与期望一致，server端使用两种验证方式，md5值和文件长度，目前已支持文件长度验证。
#### 7.6.1 URL
http://${ip}:${rpc_port}/LGraphHttpService/Query/check_file
#### 7.6.2 REQUEST
|  body参数  |          参数说明           |  参数类型  |  是否必填  |
|:--------:|:-----------------------:|:------:| :-----: |
| fileName |           文件名           |  字符串  |  是  |
| checkSum |        文件对应md5值         |  字符串  |  否  |
| fileSize |       文件长度(以字节计算)       |  字符串  |  否  |' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '7.接口', 'Header 3': '7.6 文件认证请求'}","page_content='TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态

2 使用示例

**2.3 通过OGM进行增操作**

OGM支持对TuGraph的实体执行CRUD 操作，同时支持发送任意TuGraph支持的Cypher语句，包括通过CALL调用存储过程。  
**CREATE**  
在完成图对象的构建后，即可通过类的实例化创建节点，当两个节点互相存储在对方的集合（该集合在构建时被标注为边）中，就形成了一条边，最后使用session.save方法将数据存入数据库。  
注意：TuGraph数据库为强schema类型数据库，在创建实体前需要该数据的label已经存在，且新建过程中需要提供唯一的主键。  
```
Movie jokes = new Movie（""Jokes""，1990）； // 新建Movie节点jokes session.save(jokes); // 将jokes存储在TuGraph中

Movie speed = new Movie(""Speed"", 2019);

Actor alice = new Actor(""Alice Neeves"");

alice.actsIn(speed);

session.save(speed);' metadata={'Header 1': 'TuGraph开源JAVA客户端工具TuGraph-OGM，无缝对接JAVA开发生态', 'Header 2': '2 使用示例', 'Header 3': '**2.3 通过OGM进行增操作**'}","page_content='数据导入

3.配置文件

3.1.配置文件格式

- path（必选，字符串，可以是文件路径或者目录的路径，如果是目录会导入此目录下的所有文件，需要保证有相同的 schema）
- header（可选，数字，头信息占文件起始的几行，没有就是 0）
- format（必须选，只能是 JSON 或者 CSV）
- label（必选，字符串）
- columns（数组形式）
- SRC_ID (特殊字符串，仅边有，代表这列是起始点数据)
- DST_ID (特殊字符串，仅边有，代表这列是目的点数据)
- SKIP  (特殊字符串，代表跳过这列数据)
- [property]
- SRC_ID (仅边配置，值是起始点标签)
- DST_ID (仅边配置，值是目的点标签)  
#### 3.1.2.索引长度
因为TuGraph对key的长度有限制，唯一索引不允许建立超过限制长度的索引，而非唯一索引会对超过长度限制的属性进行截断处理，并且在通过迭代器遍历非唯一索引时，拿到的key也是经过截断的，可能和预期不一致。针对不同类型的非唯一索引，截断长度是不同的。
##### 3.1.2.1.unique索引' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.1.配置文件格式'}","page_content='TuGraph图模型说明

1. 数据模型

1.3. 索引

TuGraph支持对点或边的属性创建索引，以提升查询效率。其特点如下：
- 索引包括普通索引和组合索引，普通索引基于一个点或边的一个属性创建，而组合索引基于一个点或边的多个属性创建（不超过16个），可以对同一点或边的多个（组）属性创建索引。
- 如果为点标签创建了唯一索引，在修改该标签的点时，会先执行数据完整性检查，以确保该索引的唯一性。
- BLOB类型的属性不能建立索引。  
TuGraph的点边均有多种索引类型，不同的索引类型的功能和限制不同，具体如下：  
#### 1.3.1 普通索引
##### 1.3.1.1 点索引
###### 1.3.1.1.1 unique索引  
点的unique索引指的是全局唯一的索引，即若一个属性设置了unique索引，在同一个图中，相同label的点的该属性不会存在相同的值，
unique索引key的最大长度是480bytes，**超过480bytes的属性不能建立unique索引**。
primary作为特殊的unique索引，因此最大key的长度也是480bytes。' metadata={'Header 1': 'TuGraph图模型说明', 'Header 2': '1. 数据模型', 'Header 3': '1.3. 索引'}",空,空,空,空,空,空
在Java运行时，如何在XML配置文件中配置targetProject？,空,空,空,空,空,空,空,空,空,空
在2024年功能更新计划中，将支持哪些角色和工具？,"page_content='技术规划

3. 2024年功能更新

在2024年度，我们计划的功能更新包括：  
| 版本号   | 功能                 | 计划时间    |
|-------|--------------------|---------|
| 4.2.x | HA支持Witness角色和管理工具 | 2024.3  |
| 4.2.x | Bolt支持流处理和参数化查询    | 2024.3  |
| x.x.x | GeaX支持Cypher       | 2024.6  |
| x.x.x | 支持组合索引             | 2024.6  |
| x.x.x | 数据导入功能优化           | 2024.6  |
| x.x.x | 【社区功能】支持地理数据类型使用   | 2024.6  |
| x.x.x | Cypher能力提升         | 2024.9  |
| x.x.x | 支持Schema快速变更       | 2024.9  |
| x.x.x | 向量化支持              | 2024.12 |' metadata={'Header 1': '技术规划', 'Header 2': '3. 2024年功能更新'}","page_content='技术规划

3. 2024年功能更新

| x.x.x | 支持组合索引             | 2024.6  |
| x.x.x | 数据导入功能优化           | 2024.6  |
| x.x.x | 【社区功能】支持地理数据类型使用   | 2024.6  |
| x.x.x | Cypher能力提升         | 2024.9  |
| x.x.x | 支持Schema快速变更       | 2024.9  |
| x.x.x | 向量化支持              | 2024.12 |
| x.x.x | RPQ支持              | 2024.12 |
| x.x.x | 【可选】查询引擎升级         | 2024.12 |
| x.x.x | 【社区功能】支持GraphAr    | 2024.12 |' metadata={'Header 1': '技术规划', 'Header 2': '3. 2024年功能更新'}",空,空,空,空,空,空,空,空
"在调用 ""CallGql"" 接口时，如何指定要查询的图的名称？","page_content='Java客户端

2.使用示例

2.4.调用GQL

```java
String res = client.callGql(""CALL db.edgeLabels()"", ""default"", 10);
log.info(""db.edgeLabels() : "" + res);
```
```
@param gql: inquire statement.
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@param url: (Optional) Node address of calling GQL
@return: the result of GQL query execution
public String callGql(String gql, String graph, double timeout, String url)
```' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.4.调用GQL'}","page_content='C++客户端

2.使用示例

2.4.调用GQL

```C++
std::string str;
bool ret = client.CallGql(str,
""CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)"");
```
```
bool CallGql(std::string& result, const std::string& gql,
const std::string& graph = ""default"", bool json_format = true,
double timeout = 0, const std::string& url = """");
@param [out] result      The result.
@param [in]  gql         inquire statement.
@param [in]  graph       (Optional) the graph to query.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.4.调用GQL'}","page_content='Java客户端

2.使用示例

2.5.向leader发送GQL请求

```java
String res = client.callGqlToLeader(""CALL db.edgeLabels()"", ""default"", 10);
log.info(""db.edgeLabels() : "" + res);
```
```
@param gql: inquire statement.
@param graph: the graph to query.
@param timeout: Maximum execution time, overruns will be interrupted
@return: the result of cypher query execution
public String callGqlToLeader(String cypher, String graph, double timeout)
```
本接口只支持在HA模式下使用，在HA模式下的client中，为防止向未同步数据的follower发送请求，
用户可以直接向leader发送请求，leader由集群选出。' metadata={'Header 1': 'Java客户端', 'Header 2': '2.使用示例', 'Header 3': '2.5.向leader发送GQL请求'}","page_content='C++客户端

2.使用示例

2.5.向leader发送GQL请求

```C++
std::string str;
bool ret = client.CallGqlToLeader(str,
""CALL db.createVertexLabel('actor', 'name', 'name', string, false, 'age', int8, true)"");
```
```
bool CallGqlToLeader(std::string& result, const std::string& gql,
const std::string& graph = ""default"", bool json_format = true,
double timeout = 0);
@param [out] result      The result.
@param [in]  gql         inquire statement.
@param [in]  graph       (Optional) the graph to query.' metadata={'Header 1': 'C++客户端', 'Header 2': '2.使用示例', 'Header 3': '2.5.向leader发送GQL请求'}",空,空,空,空,空,空
在图中如何展示属性值？,"page_content='可视化操作手册

2.操作指南

2.4.图项目

##### 2.4.4.4.属性筛选  
在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`属性筛选`进行筛选过滤。用户可以选择要筛选的点或边类型，以及对应的属性值进行设置，检索到筛选组条件的数据后会在画布上高亮选中对应的点或边数据。
- 请选择点/边类型：选择需要检索的点类型或边类型。
- 属性条件：设置需要检索的属性条件，可以设置多组，取并集筛选结果。
- 添加筛选组：可以多组筛选条件，取并集筛选结果。
- 重置：可以清空筛选条件。  
![图分析-筛选-属性筛选](../../../images/browser/graphanalysis-queryfilter-attributefilter.png)  
##### 2.4.4.5.统计筛选  
在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

##### 2.4.4.5.统计筛选  
在`操作栏`区域点击`筛选`按钮，在`左边栏`点击`统计筛选`进行画布数据统计。用户可以选择要统计的点或边类型，以及对应的属性值进行设置，系统会自动根据用户选择的点/边类型和属性进行分组统计，支持按照图表和列表两种方式展示结果，同时点击图表或列表区域的数值可以高亮选中画布中的数据。  
![图分析-筛选-统计筛选](../../../images/browser/graphanalysis-queryfilter-statisticalfilter.png)
![图分析-统计筛选-图表切换](../../../images/browser/graphanalysis-queryfilter-statisticalfilter-chartswitch.png)  
##### 2.4.4.6.点边布局' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

2、左边栏：查询、筛选、外观功能操作区域；
3、画布区域：展示图数据的区域，展示点和边数据，支持点扩展查询、收起节点、固定节点、删除节点、画布图数据统计、缩放、居中等功能；
4、右边栏：选中一个点数据或边数据后，会展示对应的属性信息；
5、布局切换：标签布局和卡片布局的切换。  
![图分析-操作区域](../../../images/browser/graphanalysis-operation-area.png)  
##### 2.4.4.1.语句查询  
在`语句查询`功能中，用户可以输入查询语句来查询图数据，并加载数据至画布区域进行展示。
- 语法说明：TuGraph的[查询语言及语法说明文档](../8.query/1.cypher.md)。
- 清空画布数据：未选择此按钮，每次执行查询的结果会追加至画布区域；选择此按钮，每次执行查询前会先清空画布。  
![图分析-语句查询](../../../images/browser/graphanalysis-queryfilter-query.png)' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}","page_content='可视化操作手册

2.操作指南

2.4.图项目

###### c.插入数据  
Browser提供可视化方式在对应图项目中插入点或边数据。点击`插入数据`按钮，在`插入数据`页签选择点类型或边类型，输入属性值，点击确定完成数据插入。  
![插入数据-按钮](../../../images/browser/query-result-insert-button.png)  
![插入数据](../../../images/browser/query-result-insert.png)  
###### d.下载执行结果  
Browser提供图查询结果导出成文本文件功能。点击`下载执行结果`按钮，系统会自动将结果保存成文本文件并下载至本地。  
![下载执行结果-按钮](../../../images/browser/query-result-download.png)
![下载执行结果-按钮](../../../images/browser/query-result-downloadtxt.png)  
###### e.全屏展示' metadata={'Header 1': '可视化操作手册', 'Header 2': '2.操作指南', 'Header 3': '2.4.图项目'}",空,空,空,空,空,空
如何将TuGraph-DB与Neo4j驱动连接？,"page_content='业务开发指南

连接tugraph-db

驱动连接

tugraph-db兼容neo4j的通讯协议，因此可以使用neo4j的驱动连接tugraph-db的server。  
[bolt driver 使用介绍](./7.client-tools/5.bolt-client.md)  
[bolt driver 使用例子](https://github.com/TuGraph-family/tugraph-db/tree/master/demo/Bolt)' metadata={'Header 1': '业务开发指南', 'Header 2': '连接tugraph-db', 'Header 3': '驱动连接'}","page_content='QA汇总

数据导入QA

数据导出到csv

Q：怎么把存储于tugraph的某些指定的点/边类型的全量数据，导出到csv文件中？
A：使用neo4j driver 连接tugraph，直接发送cypher 语句 ""match (n) return n"" 就可以了。结果是流式返回的，不管多少数据都可以读出来，不会引发内存oom' metadata={'Header 1': 'QA汇总', 'Header 2': '数据导入QA', 'Header 3': '数据导出到csv'}","page_content='图数据库智能化建设与探索

**02\. 技术分享｜TuGraph-DB兼容Neo4j客户端：Bolt协议设计与实现**

“兼容Neo4j客户端的最大优势在于生态支持。以客户端为例，Neo4j官方自身支持五种编程语言的客户端，社区又贡献了两种，共计七种语言的客户端得以直接使用。此外，还有一系列与上下游生态相接的组件，如与Apache Spark或Apache Kafka的连接，都有现成的代码可供利用。在编程框架方面，特别是Java，例如OGM（Object-Graph Mapping，对象图映射）以及一些业务开发框架，如Spring，这些所需的相关代码都已现成，无需重新编写。这种做法极大地节约了研发资源，我们可以将这些资源重新投入到提升数据库本身能力上。”' metadata={'Header 1': '图数据库智能化建设与探索', 'Header 2': '**02\\. 技术分享｜TuGraph-DB兼容Neo4j客户端：Bolt协议设计与实现**'}","page_content='demo/Bolt/python_example.py/ from neo4j import GraphDatabase

URI = ""bolt://localhost:7687""
AUTH = (""admin"", ""73@TuGraph"")
with GraphDatabase.driver(URI, auth=AUTH) as client:
    session = client.session(database=""default"")
    session.run(""CALL db.dropDB()"")
    session.run(""CALL db.createVertexLabel('person', 'id' , 'id' ,INT32, false, 'name' ,STRING, false)"")
    session.run(""CALL db.createEdgeLabel('is_friend','[[\""person\"",\""person\""]]')"")
    session.run(""create (n1:person {name:'jack',id:1}), (n2:person {name:'lucy',id:2})"")
    session.run(""match (n1:person {id:1}), (n2:person {id:2}) create (n1)-[r:is_friend]->(n2)"")
    ret = session.run(""match (n)-[r]->(m) return n,r,m"")
    for item in ret.data():
        print(item)' metadata={'file_name': 'python_example.py', 'file_path': 'demo/Bolt/python_example.py', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/Bolt/python_example.py'}","page_content='demo/Bolt/go_example.go/ package main

import (
	""context""
	""fmt""
	""github.com/neo4j/neo4j-go-driver/v5/neo4j""
)

func main() {
	driver, err := neo4j.NewDriverWithContext(""bolt://localhost:7687"", neo4j.BasicAuth(""admin"", ""73@TuGraph"", """"))
	if err != nil {
		panic(err)
	}

	ctx := context.Background()
	defer driver.Close(ctx)

	session := driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: ""default""})
	defer session.Close(ctx)

	_, err = session.Run(ctx, ""CALL db.dropDB()"", nil)
	if err != nil {
		panic(err)
		return
	}
	_, err = session.Run(ctx, ""CALL db.createVertexLabel('person', 'id' , 'id' ,INT32, false, 'name' ,STRING, false)"", nil)
	if err != nil {
		panic(err)
		return
	}
	_, err = session.Run(ctx, ""CALL db.createEdgeLabel('is_friend','[[\""person\"",\""person\""]]')"", nil)
	if err != nil {
		panic(err)
		return
	}
	_, err = session.Run(ctx, ""create (n1:person {name:'jack',id:1}), (n2:person {name:'lucy',id:2})"", nil)
	if err != nil {
		panic(err)
		return
	}
	_, err = session.Run(ctx, ""match (n1:person {id:1}), (n2:person {id:2}) create (n1)-[r:is_friend]->(n2)"", nil)
	if err != nil {
		panic(err)
		return
	}
	res, err := session.Run(ctx, ""match (n)-[r]->(m) return n,r,m"", nil)
	if err != nil {
		panic(err)
		return
	}
	records, err := res.Collect(ctx)
	if err != nil {
		panic(err)
		return
	}
	for _, record := range records {
		fmt.Printf(""record = %#v\n"", record)
	}
}' metadata={'file_name': 'go_example.go', 'file_path': 'demo/Bolt/go_example.go', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/demo/Bolt/go_example.go'}",空,空,空,空,空
在图模型中，如果某些边设置了属性，但在导入数据后无法查询到这些有属性的边，可能出现了哪些问题，应该如何解决这个问题？,"page_content='性能优先

4.数据编码

对于属性图模型而言，除了图拓扑编码外，属性数据也会很大程度影响功能和性能，我们先讨论属性数据如何与拓扑数据共存的编码格式。从目前的调研来看，属性编码有两种方式，我们称之为基于指针索引将属性数据单独存储的离散编码，和将属性数据和拓扑数据打包在一起的紧凑编码。离散编码根据程度的不同，可以每个属性都单独存储，或者每条边的属性打包后各自存储，下面的讨论对两种情况都适用。  
点查询。属性编码主要针对边，不涉及点查询。  
单边查询。离散编码通过指针定位边，紧凑编码则需要二分查找定位边的位置，离散编码有略微的优势。  
边遍历。离散编码在边遍历过程需要不断地进行指针跳转进行随机数据访问，而紧凑编码提前把数据排列在一起，顺序访问的特性使得效率大大提升。 由规律三知对边的遍历操作很普遍，紧凑编码在边遍历的优势明显。  
单边更新。离散编码对边的更新仅需找到对应的指针位置，插入数据后修改前后指针指向。紧凑编码则需要对紧凑排列的数据进行重编码，对整个边值进行重新写入，开销显著大于离散编码的情形。' metadata={'Header 1': '性能优先', 'Header 2': '4.数据编码'}",空,空,空,空,空,空,空,空,空
"如何通过""TuGraph-DataX""项目中的job配置文件将""actors.csv""导入到TuGraph？","page_content='TuGraph-DataX

3. 导入TuGraph

3.1.文本数据通过DataX导入TuGraph

tt0286112,Shaolin Soccer,2001,7.3
tt4701660,The Mermaid,2016,6.3
```  
`roles.csv`  
```
nm015950,Tianchou Yin,tt0188766
nm015950,Steel Leg,tt0286112
nm0628806,,tt0188766
nm0628806,coach,tt0286112
nm0156444,PiaoPiao Liu,tt0188766
nm2514879,Ruolan Li,tt4701660
```  
然后建三个 DataX 的 job 配置文件：
`job_actors.json`  
```json
{
""job"": {
""setting"": {
""speed"": {
""channel"": 1
}
},
""content"": [
{
""reader"": {
""name"": ""txtfilereader"",
""parameter"": {
""path"": [""actors.csv""],' metadata={'Header 1': 'TuGraph-DataX', 'Header 2': '3. 导入TuGraph', 'Header 3': '3.1.文本数据通过DataX导入TuGraph'}","page_content='TuGraph-DataX

3. 导入TuGraph

3.1.文本数据通过DataX导入TuGraph

nm2514879,Ruolan Li,tt4701660
```  
然后建三个 DataX 的 job 配置文件：
`job_actors.json`  
```json
{
""job"": {
""setting"": {
""speed"": {
""channel"": 1
}
},
""content"": [
{
""reader"": {
""name"": ""txtfilereader"",
""parameter"": {
""path"": [""actors.csv""],
""encoding"": ""UTF-8"",
""column"": [
{
""index"": 0,
""type"": ""string""
},
{
""index"": 1,
""type"": ""string""
}
],
""fieldDelimiter"": "",""
}
},
""writer"": {
""name"": ""tugraphwriter"",
""parameter"": {
""url"": ""bolt://127.0.0.1:27687"",
""username"": ""admin"",' metadata={'Header 1': 'TuGraph-DataX', 'Header 2': '3. 导入TuGraph', 'Header 3': '3.1.文本数据通过DataX导入TuGraph'}","page_content='数据导入

3.配置文件

3.2.配置文件示例

还描述了三个数据文件，两个点的数据文件`actors.csv`和`movies.csv`，一个边的数据文件`roles.csv`。每个部分都描述了：文件的路径（path）、数据类型（format）、信息头占开头几行（header）、是哪个 label 的数据（label）、文件中每行数据中的每个列对应的字段是哪个。  
对于上述配置文件，import 工具在执行的过程中会先在 TuGraph 中创建`actor`、`movie`、`role`这三个 label，然后再执行三个文件的数据导入。' metadata={'Header 1': '数据导入', 'Header 2': '3.配置文件', 'Header 3': '3.2.配置文件示例'}","page_content='TuGraph-DataX

3. 导入TuGraph

3.1.文本数据通过DataX导入TuGraph

""password"": ""73@TuGraph"",
""graphName"": ""default"",
""labelType"": ""VERTEX"",
""labelName"": ""actor"",
""batchNum"": 1000,
""properties"": [""aid"", ""name""]
}
}
}
]
}
}
```  
`job_movies.json`  
```json
{
""job"": {
""setting"": {
""speed"": {
""channel"": 1
}
},
""content"": [
{
""reader"": {
""name"": ""txtfilereader"",
""parameter"": {
""path"": [""movies.csv""],
""encoding"": ""UTF-8"",
""column"": [
{
""index"": 0,
""type"": ""string""
},
{
""index"": 1,
""type"": ""string""
},
{
""index"": 2,
""type"": ""string""
},
{' metadata={'Header 1': 'TuGraph-DataX', 'Header 2': '3. 导入TuGraph', 'Header 3': '3.1.文本数据通过DataX导入TuGraph'}","page_content='TuGraph-DataX

3. 导入TuGraph

3.1.文本数据通过DataX导入TuGraph

""graphName"": ""default"",
""labelType"": ""EDGE"",
""labelName"": ""play_in"",
""batchNum"": 1000,
""properties"": [""SRC_ID"", ""role"", ""DST_ID""],
""startLabel"": {""type"": ""actor"", ""key"": ""SRC_ID""},
""endLabel"": {""type"": ""movie"", ""key"": ""DST_ID""}
}
}
}
]
}
}
```  
`./lgraph_server -c lgraph_standalone.json -d 'run'` 启动 TuGraph 后依次执行如下三个命令：  
```
python3 datax/bin/datax.py  job_actors.json
```  
```
python3 datax/bin/datax.py  job_movies.json
```  
```
python3 datax/bin/datax.py  job_roles.json' metadata={'Header 1': 'TuGraph-DataX', 'Header 2': '3. 导入TuGraph', 'Header 3': '3.1.文本数据通过DataX导入TuGraph'}",空,空,空,空,空
创建新子图时需要哪些参数？,"page_content='Cypher API

5.附录2. 内置procedures列表

* dbms.graph.createGraph(graph_name, description, max_size_GB)

create a new subgraph in this graph database .  
**Parameters:**  
| parameter   | parameter type | description              |
| ----------- | -------------- | -------------------------------- |
| graph_name  | string     | the name of new subgraph     |
| description | string     | description of new subgraph      |
| max_size_GB | integer    | Upper limit of subgraph capacity |  
**Output:**  
if successful , it will return true.  
**Example input:**  
```' metadata={'Header 1': 'Cypher API', 'Header 2': '5.附录2. 内置procedures列表', 'Header 3': '* dbms.graph.createGraph(graph_name, description, max_size_GB)'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

- 然后点击“一键创建模型”——>""一键创建数据""，就可以完成内置的 Movie 数据图谱的构建  
#### 3.2 创建子图和示例  
##### 3.2.1 创建子图  
- 点击新建子图
![alt 创建子图](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/4.tugraph-browser-create-subgraph-01.png)
- 填写表单信息
![alt 填写表单](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/5.tugraph-browser-create-subgraph-02.png)
- 子图名称
- 子图描述
- 配置信息
- 点击确认，提示创建成功
- 切换子图' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}","page_content='RESTful API Legacy

6.Deprecated

6.5.子图管理

TuGraph 支持多子图，子图之间完全独立，不同的子图可以对不同用户开放不同权限。管理员可以添加和删除子图。  
#### 6.5.1.创建新子图  
- **URI**: `/db`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| name | 子图名 | 字符串 |
| config | 配置 | 字典，格式为 { {列名 1}:{列值 1},... } |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/db
• Accept: application/json; charset=UTF-8
• Content-Type: application/json
Input:
{
""name"":""graph1"",
""config"" : {
""max_size_GB"":2048,' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.5.子图管理'}",空,空,空,空,空,空,空
如何在test_export_default函数中验证导出后再次导入的数据是否与原始数据一致？,"page_content='集成测试

2.TuGraph集成测试框架

2.3.测试样例

assert res == None
```  
#### 2.3.3.exportor/importor  
样例代码中在test_export_default函数执行之前先执行了数据离线导入逻辑，导入成功后将当前db的数据导出，然后再次通过离线导入逻辑将exportor导出的数据导入到新的目录中，以新导入的数据启动db，并且创建链接。在test_export_default函数主体中判断导出后再次导入的数据是否与原始数据一致  
```python
SERVEROPT = {""cmd"":""./lgraph_server -c lgraph_standalone.json --directory ./testdb1 --license _FMA_IGNORE_LICENSE_CHECK_SALTED_ --port 7073 --rpc_port 9093"",
""cleanup_dir"":[""./testdb1""]}' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.3.测试样例'}","page_content='集成测试

2.TuGraph集成测试框架

2.3.测试样例

ret = client.callCypher(""MATCH (n) RETURN n LIMIT 100"", ""default"")
assert ret[0]
res = json.loads(ret[1])
assert len(res) == 21
ret = client.callCypher(""CALL db.flushDB()"", ""default"")
assert ret[0]
res = json.loads(ret[1])
assert res == None
```  
#### 2.3.3.exportor/importor  
样例代码中在test_export_default函数执行之前先执行了数据离线导入逻辑，导入成功后将当前db的数据导出，然后再次通过离线导入逻辑将exportor导出的数据导入到新的目录中，以新导入的数据启动db，并且创建链接。在test_export_default函数主体中判断导出后再次导入的数据是否与原始数据一致  
```python' metadata={'Header 1': '集成测试', 'Header 2': '2.TuGraph集成测试框架', 'Header 3': '2.3.测试样例'}",空,空,空,空,空,空,空,空
在使用TuGraph时，Work函数在处理节点vi时，返回值代表什么？,"page_content='OlapBase API

7. 图类OlapBase

7.4 批处理操作

TuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程。分别是：  
```c++
/*
函数名称:ReducedSum ProcessVertexInRange(std::function<ReducedSum(size_t)> work, size_t lower, size_t upper,
ReducedSum zero = 0,std::function<ReducedSum(ReducedSum, ReducedSum)> reduce =reduce_plus<ReducedSum>)

函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；
第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。
具体实现请参考include/lgraph/olap_base.h中具体代码

使用示例:统计数组parent数组中有出边的点个数
*/' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.4 批处理操作'}","page_content='OlapBase API

7. 图类OlapBase

7.4 批处理操作

函数用途:对active_vertices中对应为1的节点执行work函数，第三个参数表示累加的基数，默认为0；
第四个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。
具体实现请参考/include/lgraph/olap_base.h中具体代码

使用示例:输出Graph中节点1，2，3的所有出度邻居，并统计这三个节点的总出度
*/' metadata={'Header 1': 'OlapBase API', 'Header 2': '7. 图类OlapBase', 'Header 3': '7.4 批处理操作'}","page_content='Python Olap API

4. Olap API

图类OlapBase

```python
# 函数名称:ProcessVertexInRange[ReducedSum, Algorithm](
#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,
#           lower: size_t, upper: size_t,
#           algo: Algorithm,
#           zero: ReducedSum = 0,
#           reduce: (a: ReducedSum, b: ReducedSum)-> ReducedSum = reduce_plus[ReducedSum])
#
#     函数用途:对Graph中节点编号介于lower和upper之间的节点执行work函数。第四个参数表示累加的基数，默认为0；
#     第五个参数表示对每个work处理后的节点返回值进行迭代reduce函数操作，默认为累加操作。' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}","page_content='Python Olap API

4. Olap API

图类OlapBase

- `AcquireVertexLock(vid: size_t)-> cython.void`：对点vid加锁，禁止其它线程对该锁对应的点数据进行访存
- `void ReleaseVertexLock(vid: size_t)-> cython.void`：对点vid解锁，所有线程均可访存该锁对应的点数据  
TuGraph提供了两个批处理操作来并行地进行以点为中心的批处理过程，在Python中与C++使用方法稍有不同。  
```python
# 函数名称:ProcessVertexInRange[ReducedSum, Algorithm](
#           work: (algo: Algorithm, vi: size_t)-> ReducedSum,
#           lower: size_t, upper: size_t,
#           algo: Algorithm,
#           zero: ReducedSum = 0,' metadata={'Header 1': 'Python Olap API', 'Header 2': '4. Olap API', 'Header 3': '图类OlapBase'}","page_content='RESTful API Legacy

2.请求与数据格式

2.3.返回值

TuGraph 返回的 HTTP 状态码包含以下四种：  
- 200 OK: 操作成功
- 307 Temporary Redirect: 操作被重定向，一般用于高可用模式下，把操作重定向到 master 上
- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误
- 500 Internal Server Error: 服务器端错误  
当操作成功时，返回的 JSON 中包含操作的返回值。当操作重定向时，返回的 HTTP 报头中的 `location` 域包含重定向目的地址。
当发生输入错误或者服务器错误时，返回的 JSON 中包含 `error_message` 域，其内容是错误提示。  
在高可用模式下，服务器还会在报头中设置 `server_version`，以告知客户端当前服务器的数据版本号。当客户端在不同的服务器之间切换时，该数据版本号可以保证客户端不会读到错误的历史数据。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '2.请求与数据格式', 'Header 3': '2.3.返回值'}",空,空,空,空,空
TuGraph Explorer 的功能现在可以在哪里找到？,"page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.4.2 权限管理  
- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/18.tugraph-browser-auth.png)  
##### 3.4.3 实时状态  
- 这里展示了数据库实时状态，包括：CPU 使用率、内存用率、磁盘使用率、数据请求次数、磁盘 IO
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/19.tugraph-browser-status.png)  
##### 3.4.4 任务管理  
- 在这里用户可以看到在正在执行中的任务，可以在此进行停止任务的操作' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.3.6 帮助  
- 其中记录了 TuGraph-browser 的使用方式
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)  
#### 3.4 控制台  
##### 3.4.1 数据库基础信息  
- 展示数据库相关的基础配置信息
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/17.tugraph-browser-config.png)  
##### 3.4.2 权限管理  
- 用来创建用户和角色的功能模块，用户可以在这里进行权限的管理操作' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}","page_content='功能概览

6.生态工具

6.2.可视化交互

TuGraph Browser 是面向图数据库直接使用者的可视化交互界面，功能上覆盖了 TuGraph 的绝大部分能力，包括数据导入、图模型建立、数据增删查改、监控运维等操作链路。' metadata={'Header 1': '功能概览', 'Header 2': '6.生态工具', 'Header 3': '6.2.可视化交互'}","page_content='可视化操作手册（旧版）

作用

TuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '作用'}","page_content='可视化操作手册（旧版）

操作详情

3.工作台

##### 3.3.5 插件  
- 存储过程的使用  
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/15.tugraph-browser-plugin.png)  
- 用户可以上传本地编写的 Plugin 程序，并在可视化页面进行执行，并查看执行结果
- 用户可以在可视化对插件进行、卸载、执行、下载等操作  
##### 3.3.6 帮助  
- 其中记录了 TuGraph-browser 的使用方式
![alt 查询](https://tugraph-web-static.oss-cn-beijing.aliyuncs.com/%E6%96%87%E6%A1%A3/2.Operating/16.TuGraph-browser-help.png)  
#### 3.4 控制台  
##### 3.4.1 数据库基础信息  
- 展示数据库相关的基础配置信息' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '操作详情', 'Header 3': '3.工作台'}",空,空,空,空,空
在批量创建点的操作中，如果请求成功，TuGraph 会返回什么样的结果？,"page_content='RESTful API Legacy

2.请求与数据格式

2.3.返回值

TuGraph 返回的 HTTP 状态码包含以下四种：  
- 200 OK: 操作成功
- 307 Temporary Redirect: 操作被重定向，一般用于高可用模式下，把操作重定向到 master 上
- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误
- 500 Internal Server Error: 服务器端错误  
当操作成功时，返回的 JSON 中包含操作的返回值。当操作重定向时，返回的 HTTP 报头中的 `location` 域包含重定向目的地址。
当发生输入错误或者服务器错误时，返回的 JSON 中包含 `error_message` 域，其内容是错误提示。  
在高可用模式下，服务器还会在报头中设置 `server_version`，以告知客户端当前服务器的数据版本号。当客户端在不同的服务器之间切换时，该数据版本号可以保证客户端不会读到错误的历史数据。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '2.请求与数据格式', 'Header 3': '2.3.返回值'}","page_content='TuGraph-Restful-Server

5.返回值

通用返回格式  
|  body参数  | 参数说明  |  参数类型  |  是否必填  |
|:--------:|:-----:|:------:| :-----: |
| errorCode |  状态码  |  字符串  |  是  |
| errorMessage | 错误信息  |  字符串  |  是  |
| data | 返回的数据 |  字符串  |  是  |  
TuGraph 返回的 HTTP 状态码包含以下四种：  
- 200 OK: 操作成功
- 400 Bad Request: 输入有误，例如 URI 错误，或者请求中的 JSON 参数错误
- 401 Unauthorized: 未通过鉴权认证，例如用户名密码错误，token超过有效期等
- 500 Internal Server Error: 服务器端错误
当操作成功时，返回的 data 中包含操作的返回值。
当发生输入错误或者服务器错误时，返回的 errorMessage 中包含错误提示。' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '5.返回值'}","page_content='RESTful API Legacy

6.Deprecated

6.7.点操作

}
```  
**Example response.**  
```
• 200: OK
• Content-Type: application/json; charset=UTF-8
Output:
{
21
}
```  
#### 6.7.3.批量创建点  
TuGraph 允许一次性插入多个点，以减少网络开销。  
- **URI**: `/db/{graph_name}/node`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| label | Label 名 | 字符串 |
| fields | 点属性 | 列表 |
| values | 点数据 | 列表 |  
其中 fields 是一个字符串列表，列出一系列列名；values 是一个列表，其中每个元素是一个列表，列表中每个元素是列数据。' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.7.点操作'}","page_content='TuGraph-Restful-Server

7.接口

7.7 批量创建schema请求

用户通过此类请求批量创建schema，请求报文在http body 中将创建schema的目标子图和schema信息发送给server，如果拿到返回errorCode为200的响应报文即为正常创建
#### 7.7.1 URL
http://${ip}:${rpc_port}/LGraphHttpService/Query/import_schema
#### 7.7.2 REQUEST
|  body参数  |    参数说明    |  参数类型  |  是否必填  |
|:--------:|:----------:|:------:| :-----: |
| graph |   创建目标子图   |  字符串  |  是  |
| schema | schema描述信息 |  字符串  |  是  |' metadata={'Header 1': 'TuGraph-Restful-Server', 'Header 2': '7.接口', 'Header 3': '7.7 批量创建schema请求'}","page_content='RESTful API

2.请求与响应格式

2.2请求类型

- **RESPONSE**:
如果成功，返回的响应信息中success为00，data中包含令牌  
| body参数  | 参数说明 | 参数类型  | 是否必填       |
| ------- |------|-------|------------|
| authorization   | 令牌  | 字符串类型   | 是          |  
#### 2.2.4. 调用cypher
用户对TuGraph的增删改查请求需要调用cypher接口，并通过标准的cypher查询语言发起  
- **URI**:     /cypher
- **METHOD**:  POST
- **REQUEST**:  
| body参数  | 参数说明     | 参数类型  | 是否必填       |
| ------- |----------|-------|------------|
| graph   | 查询的子图名称  | 字符串类型   | 是          |' metadata={'Header 1': 'RESTful API', 'Header 2': '2.请求与响应格式', 'Header 3': '2.2请求类型'}",空,空,空,空,空
TuGraph能否支持混合检索，即同时进行向量检索和知识图谱检索？,"page_content='QA汇总

内核引擎QA

边支持索引

Q: TuGraph 的边是否支持索引？
A: TuGraph 在引擎层支持边索引，可通过存储过程使用。Cypher的边索引功能正在开发支持中。' metadata={'Header 1': 'QA汇总', 'Header 2': '内核引擎QA', 'Header 3': '边支持索引'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持Cypher查询语言

TuGraph对Cypher查询语言的支持令人印象深刻。Cypher是一种直观且强大的查询语言，能够轻松地对图数据进行复杂的查询和操作。我很快就学会了使用Cypher进行查询，发现它非常适合图数据库的需求。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持Cypher查询语言'}","page_content='图算法介绍

2\. 流图推理简介

TuGraph计算引擎（TuGraph Analytics\[1\]）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持了丰富的图计算算法。TuGraph Analytics的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大得提高了数据的计算效率和实时性。TuGraph Analytics解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。  
随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等AI模型的推理逻辑，是无法基于传统的图迭代计算模式直接高效地表达的。' metadata={'Header 1': '图算法介绍', 'Header 2': '2\\. 流图推理简介'}","page_content='什么是TuGraph

3. TuGraph特性

TuGraph是支持大数据量、低延迟查找和快速图分析功能的高效图数据库。TuGraph也是基于磁盘的数据库，支持存储多达数十TB的数据。TuGraph提供多种API，使用户能够轻松构建应用程序，并使其易于扩展和优化。  
它具有如下功能特征：  
- 属性图模型
- 实时增删查改
- 多重图（点间允许多重边）
- 多图（大图与多个子图）
- 完善的ACID事务处理，隔离级别为可串行化（serializable）
- 点边索引
- 混合事务和分析处理（HTAP），支持图查询、图分析、图学习
- 主流图查询语言（OpenCypher、ISO GQL等）
- 支持OLAP API，内置30多种图分析算法
- 基于C++/Python的存储过程，含事务内并行Traversal API
- 提供图可视化工具  
在性能和可扩展性方面的支持：  
- 千万点/秒的高吞吐率
- TB级大容量
- 高可用性支持
- 高性能批量导入
- 在线/离线的备份恢复' metadata={'Header 1': '什么是TuGraph', 'Header 2': '3. TuGraph特性'}","page_content='试用体验：TuGraph — 简单高效的图数据库

支持RESTful API

除了支持Cypher查询语言，TuGraph还提供了RESTful API接口。这使得我可以通过编程方式与图数据库进行交互，更好地将TuGraph集成到我的应用程序中。API设计合理，易于使用，为我提供了灵活性和自由度。' metadata={'Header 1': '试用体验：TuGraph — 简单高效的图数据库', 'Header 2': '支持RESTful API'}",空,空,空,空,空
TuGraph 数据预热的主要目的是什么？,"page_content='数据预热

1.简介

TuGraph 是基于磁盘的数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '数据预热', 'Header 2': '1.简介'}","page_content='功能概览

4.核心功能

4.5 数据预热

TuGraph 是基于磁盘的图数据库，仅当访问数据时，数据才会加载到内存中。因此在服务器刚开启后的一段时间内，系统性能可能会由于频繁的 IO 操作而变差。此时我们可以通过事先进行数据预热来改善这一问题。' metadata={'Header 1': '功能概览', 'Header 2': '4.核心功能', 'Header 3': '4.5 数据预热'}","page_content='数据预热

1.数据预热命令

数据预热可以通过工具 `lgraph_warmup` 来进行。它的使用示例如下：  
```bash
$ lgraph_warmup -d {directory} -g {graph_list}
```  
其中：  
- `-d {db_dir}` 选项指定了 TuGraph 服务器的数据目录  
- `-g {graph_list}` 选项指定需要进行数据预热的图名称，用逗号分隔  
根据数据大小和所使用的磁盘类型不同，预热过程运行时间也不同。机械磁盘上预热一个大数据库可能耗时较长，请耐心等待。' metadata={'Header 1': '数据预热', 'Header 2': '1.数据预热命令'}","page_content='TuGraph与ARM架构

内容：

**测试介绍：**

TuGraph在测试中使用Client/Server分离的模式，来模拟真实的用户使用场景。在结果中，TuGraph在不同规模的数据集下均表现优异，在大规模100GB的数据集（2.8亿个点，18亿条边）上，TuGraph的吞吐率较上一次官方纪录提升了31%。在300GB数据集上，TuGraph测试了超过内存容量的数据吞吐量，虽然较100GB的性能有所下降，但考虑内存和硬盘的读写性能鸿沟，该结果也在预期之内。**除了性能测试，TuGraph在****系统事务性、可恢复性、正确性、稳定性等方面均达到官方标准，体现了TuGraph高并发低延迟的强大性能优势。**  
在性能测试中，我们发现并解决了一些值得注意的问题。其一是有的系统页大小默认为64KB，这个对图系统随机数据读写并不友好，调整为X86更普遍的4KB有助于提升性能。其二是在云上使用云盘，会比本地硬盘的读写带宽和稳定性差很多，如果能够在测试前进行数据预热和及时的硬盘性能监控，更有助于获得理想的结果。' metadata={'Header 1': 'TuGraph与ARM架构', 'Header 2': '内容：', 'Header 3': '**测试介绍：**'}","page_content='可视化操作手册（旧版）

作用

TuGraph Browser 的主要功能是为使用图数据库的开发人员，提供可视化的图数据开发，图数据管理和维护等功能。' metadata={'Header 1': '可视化操作手册（旧版）', 'Header 2': '作用'}",空,空,空,空,空
InEdgeIterator 类的 GetSrc 方法返回什么信息？,"page_content='src/lgraph_api/lgraph_edge_iterator.cpp/ int64_t InEdgeIterator::GetTemporalId() const {
    ThrowIfInvalid();
    return it_->GetTemporalId();
}

bool InEdgeIterator::IsValid() const { return it_->IsValid(); }

const std::string& InEdgeIterator::GetLabel() const {
    ThrowIfInvalid();
    return txn_->GetEdgeLabel(*it_);
}

int16_t InEdgeIterator::GetLabelId() const {
    ThrowIfInvalid();
    return txn_->GetEdgeLabelId(*it_);
}

FieldData InEdgeIterator::GetField(const std::string& field_name) const {
    ThrowIfInvalid();
    return txn_->GetEdgeField(*it_, field_name);
}

FieldData InEdgeIterator::GetField(size_t field_id) const {
    ThrowIfInvalid();
    return txn_->GetEdgeField(*it_, field_id);
}

std::vector<FieldData> InEdgeIterator::GetFields(
    const std::vector<std::string>& field_names) const {
    ThrowIfInvalid();
    return txn_->GetEdgeFields(*it_, field_names);
}

std::vector<FieldData> InEdgeIterator::GetFields(const std::vector<size_t>& field_ids) const {
    ThrowIfInvalid();
    return txn_->GetEdgeFields(*it_, field_ids);
}

std::map<std::string, FieldData> InEdgeIterator::GetAllFields() const {
    ThrowIfInvalid();
    auto props = txn_->GetEdgeFields(*it_);
    return std::map<std::string, FieldData>(props.begin(), props.end());
}' metadata={'file_name': 'lgraph_edge_iterator.cpp', 'file_path': 'src/lgraph_api/lgraph_edge_iterator.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/lgraph_api/lgraph_edge_iterator.cpp'}","page_content='src/core/transaction.cpp/ emplate <typename EIT>
typename std::enable_if<IS_EIT_TYPE(EIT), std::vector<std::pair<std::string, FieldData>>>::type
Transaction::GetEdgeFields(const EIT& it) {
    Value prop = it.GetProperty();
    FMA_DBG_ASSERT(prop.IsSlice());
    auto schema = curr_schema_->e_schema_manager.GetSchema(it.GetLabelId());
    FMA_DBG_ASSERT(schema);
    if (schema->DetachProperty()) {
        prop = schema->GetDetachedEdgeProperty(*txn_, it.GetUid());
    }
    std::vector<std::pair<std::string, FieldData>> values;
    for (size_t i = 0; i < schema->GetNumFields(); i++) {
        auto fe = schema->GetFieldExtractor(i);
        values.emplace_back(fe->Name(), GetField(schema, prop, i, blob_manager_, *txn_));
    }
    return values;
}

/**
 * Gets edge field
 *
 * \tparam  E   Edge iterator type, InEdgeIterator or OutEdgeIterator.
 * \tparam  T   Field specifier type, std::string or size_t.
 * \param [in,out]  it  The iterator.
 * \param           fd  The fd.
 *
 * \return  The edge field.
 */
t' metadata={'file_name': 'transaction.cpp', 'file_path': 'src/core/transaction.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/transaction.cpp'}","page_content='src/core/transaction.cpp/ emplate <typename E, typename T>
typename std::enable_if<IS_EIT_TYPE(E) && IS_FIELD_TYPE(T), FieldData>::type
Transaction::GetEdgeField(const E& it, const T& fd) {
    Value prop = it.GetProperty();
    FMA_DBG_ASSERT(prop.IsSlice());
    auto schema = curr_schema_->e_schema_manager.GetSchema(it.GetLabelId());
    FMA_DBG_ASSERT(schema);
    if (schema->DetachProperty()) {
        prop = schema->GetDetachedEdgeProperty(*txn_, it.GetUid());
    }
    return GetField(schema, prop, fd, blob_manager_, *txn_);
}

/**
 * Sets edge property
 *
 * \tparam  EIT     Type of the edge iterator, InEdgeIterator or
 * OutEdgeIterator. \tparam  FieldT  Type of the field specifier, std::string
 * or size_t. \tparam  DataT   Type of the data t, std::string or FieldData
 * \param [in,out]  it          The iterator.
 * \param           n_fields    The fields.
 * \param           fields      The fields.
 * \param           values      The values.
 */
t' metadata={'file_name': 'transaction.cpp', 'file_path': 'src/core/transaction.cpp', 'url': 'https://github.com/Sun-HR02/tugraph-db/blob/master/src/core/transaction.cpp'}",空,空,空,空,空,空,空
OPTIONAL MATCH在查询中有什么作用？,"page_content='ISO GQL

2.Clauses

2.2.OPTIONAL MATCH

`OPTIONAL MATCH`匹配图模式，如果未命中，则返回`null`。  
#### 查询命中  
```
OPTIONAL MATCH (n:Person{name:'Michael Redgrave'})
RETURN n.birthyear
```  
返回结果
```JSON
[{""n.birthyear"":1908}]
```  
#### 查询未命中  
```
OPTIONAL MATCH (n:Person{name:'Redgrave Michael'})
RETURN n.birthyear
```  
返回结果  
```JSON
[{""n.birthyear"":null}]
```' metadata={'Header 1': 'ISO GQL', 'Header 2': '2.Clauses', 'Header 3': '2.2.OPTIONAL MATCH'}",空,空,空,空,空,空,空,空,空
GraphDB 实例无法使用的情况有哪些？,空,空,空,空,空,空,空,空,空,空
在运行 TuGraph 时，需要保证其依赖的库文件的位置在环境变量 LD_LIBRARY_PATH 中，以确保正确加载相关动态链接库。请问具体需要保证哪个库文件的位置在 LD_LIBRARY_PATH 中？,"page_content='数据库运行

1.前置条件

TuGraph 运行的前置条件为 TuGraph 正确安装，参考[安装流程](1.environment.md)。  
TuGraph 运行需要保证库文件 liblgraph.so 的文件位置在环境变量 LD_LIBRARY_PATH。  
运行 TuGraph 进程的用户不需要超级权限，但需要对配置文件（一般为lgraph.json）及文件中涉及的文件有读权限，并且对数据文件夹、日志文件夹等有写权限。' metadata={'Header 1': '数据库运行', 'Header 2': '1.前置条件'}","page_content='环境分类

2.依赖系统库

针对三种环境，除去TuGraph的运行包，所需要的系统库如下：
* 编译环境，包括gcc、python、java等编译器，也包含antlr4、pybind11等，具体参见tugraph-db源码目录 ci/images/tugraph-compile-*-Dockerfile。
* 运行环境，主要由存储过程引入，包括gcc、boost、cmake等，具体参见tugraph-db源码目录 ci/images/tugraph-runtime-*-Dockerfile。
* 精简运行环境，无，可以参见tugraph-db源码目录 ci/images/ tugraph-mini-runtime-*-Dockerfile。' metadata={'Header 1': '环境分类', 'Header 2': '2.依赖系统库'}","page_content='环境分类

1.分类

根据环境所承载功能的不同，区分为编译环境，运行环境，以及精简运行环境。
* 编译环境，具备TuGraph编译的所有依赖库，包含运行环境的所有依赖，并且能够编译TuGraph源码，但不包含预编译好的TuGraph可执行文件和库文件，供开发者编译源码使用。
* 运行环境，具备GCC/Java/Python环境，能够运行TuGraph的所有功能，并且能承载全文索引，java client，c++源码上传为plugin，以及python plugin的完整功能，内置TuGraph预编译好的可执行文件和库文件，供客户直接安装使用，无需编译源码。
* 精简运行环境，约等于裸系统加预编译TuGraph，仅能运行TuGraph的基本功能，无C++ plugin编译运行，仅so上传，无全文索引，无python plugin，供快速搭建试用。  
TuGraph编译后，会把所有的依赖库以.a的形式打包在一起，因此原则上运行不需要的其他的依赖库。但TuGraph支持存储过程，即在服务端编译C++代码，因此在环境中依然需要涉及的编译器。' metadata={'Header 1': '环境分类', 'Header 2': '1.分类'}","page_content='功能概览

1.2.软硬件环境

TuGraph核心是由C++开发，默认使用的编译器为GCC8.4，使用c++17标准。此外，存储过程中额外提供了Python Procedure API，该功能需要Python环境。TuGraph不需要特殊的硬件比如GPU，对RDMA、HBM等高延迟低带宽的通用硬件升级可以天然适配。  
TuGraph测试过基于X86和ARM的CPU，包括Intel、AMD、Kunpeng、Hygon、飞腾等，也同时在多个操作系统上运行，包括Ubuntu、CentOS、SUSE、银河麒麟、中标麒麟、UOS的主流版本，对操作系统和CPU没有特殊的要求。  
软硬件环境也包括依赖库的环境，由于TuGraph的存储层中默认的KV存储是LMDB，需要文件系统能够支持POSIX接口。在不同的环境下编译和参数配置会略有不同，比如在图存储的点边数据打包中，应和操作系统的页表大小匹配，默认为4KB，建议将系统的页表大小也设置为4KB。' metadata={'Header 1': '功能概览', 'Header 2': '1.2.软硬件环境'}","page_content='dbgpt-tugraph-plugins

代码目的？

Tu Graph插件使用cpp编写，并编译成动态链接库。该库的目的是将这些插件打包成一个python包，以便于在DB - GPT中安装和使用。' metadata={'Header 1': 'dbgpt-tugraph-plugins', 'Header 2': '代码目的？'}",空,空,空,空,空
GetNumOutEdges函数在达到限制时是如何响应的？,空,空,空,空,空,空,空,空,空,空
文本中的 BFS 算法在每次迭代中是如何更新活跃顶点数量的？,空,空,空,空,空,空,空,空,空,空
角色名的允许的最大长度是多少字节？,"page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

角色名只能由字母，数字以及下划线构成，密码则可以包含任意字符。角色名长度不能超过 64 字节。  
角色描述可以是任意字符串，长度不超过 512 字节。  
- **URI**: `/role`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| role | 角色名 | 字符串 |
| description | 角色描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

| WRITE | 可读写子图中的点和边                                                           |
| FULL  | 完全权限，包括更改元数据（label, index），管理存储过程，以及删除子图中的所有数据 |  
管理员对所有子图都有完全权限，新建的用户对所有子图都没有权限。将用户加入管理员角色中可以将用户提升为管理员。  
#### 6.2.1.添加角色  
添加一个新的角色，并设置其描述。只有管理员有权限进行此操作。  
角色名只能由字母，数字以及下划线构成，密码则可以包含任意字符。角色名长度不能超过 64 字节。  
角色描述可以是任意字符串，长度不超过 512 字节。  
- **URI**: `/role`
- **METHOD**: POST
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| role | 角色名 | 字符串 |
| description | 角色描述 | 字符串 |' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.2.2.修改角色描述  
修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。  
- **URI**: `/role/{role_name}/description`
- **METHOD**: PUT
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |
| description | 新描述 | 字符串 |  
- **RESPONSE**: 如果成功，返回代码 200。  
**Example request.**  
```
• POST http://localhost:7070/role/role1/description
• Accept: application/json; charset=UTF-8
• Content-Type: application/json; charset=UTF-8' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}","page_content='RESTful API Legacy

6.Deprecated

6.2.角色管理

• Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiaXNzIjoiZm1hLmFpIiwidXNlcl9pZCI6ImFkbWluIn0.SHaqrjKLaI4byjbEYVAH4D88dOTD_zYQ_uAvdizTMek
Input:
{
""role"": ""new_role"",
""description"": ""This is a new role."",
}
```  
**Example response.**  
```
• 200: OK
```  
#### 6.2.2.修改角色描述  
修改角色的描述。只有管理员有权限进行此操作。角色描述可以是任意字符串，长度不超过 512 字节。  
- **URI**: `/role/{role_name}/description`
- **METHOD**: PUT
- **REQUEST**:
| 域名 | 说明 | 类型 |
| --- | --- | --- |' metadata={'Header 1': 'RESTful API Legacy', 'Header 2': '6.Deprecated', 'Header 3': '6.2.角色管理'}",空,空,空,空,空,空
用于修改和启用角色的 HTTP 方法是什么？,空,空,空,空,空,空,空,空,空,空
